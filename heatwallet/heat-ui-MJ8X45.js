var heat;
(function (heat) {
    handleURLQueryParams();
    heat.isTestnet = window.localStorage.getItem('testnet') == 'true';
    heat.isBetanet = window.localStorage.getItem('betanet') == 'true';
    heat.serverDescriptionKey = "heat.usingServer." + (heat.isTestnet ? "testnet" : (heat.isBetanet ? "betanet" : "mainnet"));
    function fullApplicationScopeReload() { }
    heat.fullApplicationScopeReload = fullApplicationScopeReload;
    function handleURLQueryParams() {
        var url = window.location.href;
        var pos = url.indexOf("?");
        if (pos == -1)
            return;
        var urlQuery = url.substring(pos + 1);
        if (urlQuery.indexOf("network=testnet") > -1) {
            window.localStorage.setItem('testnet', 'true');
        }
        else if (urlQuery.indexOf("network=mainnet") > -1) {
            window.localStorage.setItem('testnet', 'false');
        }
    }
    var Loader = (function () {
        function Loader() {
            Loader.controller('AppController', ['$router', 'user', '$location', '$scope', '$rootScope',
                function ($router, user, $location, $scope, $rootScope) {
                    heat.$inject = angular.element(document).injector();
                    var unlockedRouteCheckers = [
                        /\/p2pmessagingprobe.*/,
                        /\/trader.*/,
                        /\/explorer.*/,
                        /\/explore-account.*/,
                        /\/peers.*/,
                        /\/wallet.*/
                    ];
                    function isUnlocked() {
                        if (!user.unlocked) {
                            if (!unlockedRouteCheckers.find(function (regexp) { return regexp.test($location.path()); })) {
                                if (!/\/login\/\w+/.test($location.path())) {
                                    $location.path('login');
                                }
                            }
                        }
                    }
                    isUnlocked();
                    $scope['userUnlocked'] = user.unlocked;
                    $rootScope['isTestnet'] = heat.isTestnet;
                    $rootScope.$on('$locationChangeSuccess', isUnlocked);
                    user.on(UserService.EVENT_UNLOCKED, function () {
                        $scope.$evalAsync(function () { $scope['userUnlocked'] = true; });
                    });
                    user.on(UserService.EVENT_LOCKED, function () {
                        $scope.$evalAsync(function () { $scope['userUnlocked'] = false; });
                    });
                    $scope['showApp'] = true;
                    heat.fullApplicationScopeReload = function () {
                        $scope.$evalAsync(function () {
                            $scope['showApp'] = false;
                            setTimeout(function () {
                                $scope.$evalAsync(function () {
                                    $scope['showApp'] = true;
                                });
                            }, 250);
                        });
                    };
                    var startMoment = Date.now();
                    $rootScope.$on('HEAT_SERVER_LOCATION', function (event, usingServer) {
                        if (usingServer) {
                            if (Date.now() - startMoment < 5000) {
                                setTimeout(function () {
                                    if (!utils.isBaseDate()) {
                                        sessionStorage.setItem(heat.serverDescriptionKey, JSON.stringify(usingServer));
                                        window.location.reload();
                                    }
                                }, 300);
                            }
                        }
                    });
                }]);
            this.init('heatApp', [
                'ngNewRouter',
                'ngAnimate',
                'ngMaterial',
                'ngMessages',
                'noCAPTCHA',
                'ngSanitize',
                'duScroll',
                'dc.inputAddOn',
                'jsonFormatter',
                'luegg.directives',
                'angular-popover',
                'ui.scroll', 'ui.scroll.grid'
            ]);
        }
        Loader.prototype.init = function (appName, externalModules) {
            var app = Loader.app = angular.module(appName, externalModules);
            angular.forEach(Loader.config_fn, function (v) { app.config(v); });
            angular.forEach(Loader.factory_fn, function (v) { app.factory(v.name, v.factory); });
            angular.forEach(Loader.directive_fn, function (v) { app.directive(v.name, v.factory); });
            angular.forEach(Loader.controller_fn, function (v) { app.controller(v.name, v.factory); });
            angular.forEach(Loader.run_fn, function (v) { app.run(v); });
            Loader.config_fn = null;
            Loader.run_fn = null;
            Loader.controller_fn = null;
            Loader.factory_fn = null;
            angular.bootstrap(document, [appName]);
        };
        Loader.config = function (array) { Loader.config_fn.push(array); };
        Loader.run = function (array) { Loader.run_fn.push(array); };
        Loader.controller = function (name, factory) {
            if (Loader.controller_fn)
                Loader.controller_fn.push({ name: name, factory: factory });
            else
                Loader.app.controller(name, factory);
        };
        Loader.factory = function (name, factory) {
            if (Loader.factory_fn)
                Loader.factory_fn.push({ name: name, factory: factory });
            else
                Loader.app.factory(name, factory);
        };
        Loader.directive = function (name, factory) {
            if (Loader.directive_fn)
                Loader.directive_fn.push({ name: name, factory: factory });
            else
                Loader.app.directive(name, factory);
        };
        Loader.config_fn = [];
        Loader.run_fn = [];
        Loader.controller_fn = [];
        Loader.factory_fn = [];
        Loader.directive_fn = [];
        return Loader;
    }());
    heat.Loader = Loader;
})(heat || (heat = {}));
heat.Loader.config(['$mdThemingProvider', 'noCAPTCHAProvider', '$locationProvider',
    function ($mdThemingProvider, noCAPTCHAProvider, $locationProvider) {
        $mdThemingProvider.theme('default');
        noCAPTCHAProvider.setSiteKey("6Le7pBITAAAAANPHWrIsoP_ZvlxWr0bSjOPrlszc");
        noCAPTCHAProvider.setTheme('light');
        $locationProvider.hashPrefix('');
    }]);
function Inject() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (target, key, index) {
        if (angular.isNumber(index)) {
            target.$inject = target.$inject || [];
            target.$inject[index] = args[0];
        }
        else {
            target.$inject = args;
        }
    };
}
function Component(options) {
    return function (target) {
        var d = {
            controller: target,
            controllerAs: 'vm',
            scope: {}
        };
        target.$$selector = options.selector;
        if (angular.isArray(options.styles)) {
            angular.forEach(options.styles, function (s) {
                angular.element(document).find('head').append("<style type=\"text/css\">".concat(s, "</style>"));
            });
        }
        if (angular.isString(options.style)) {
            angular.element(document).find('head').append("<style type=\"text/css\">".concat(options.style, "</style>"));
        }
        if (angular.isString(options.template)) {
            d['template'] = options.template;
        }
        if (angular.isArray(options.inputs)) {
            d['bindToController'] = {};
            options.inputs.forEach(function (input) {
                var bind = input.charAt(0) == '@' ? '@' : '=';
                if (bind == '@') {
                    input = input.substring(1);
                }
                d['bindToController'][input] = bind;
            });
            target.$$inputs = options.inputs;
        }
        if (angular.isArray(options.outputs)) {
            d['bindToController'] = d['bindToController'] || {};
            options.outputs.forEach(function (output) { return d['bindToController'][output] = '&'; });
        }
        if (angular.isFunction(options.link)) {
            d['link'] = options.link;
        }
        if (angular.isDefined(options.transclude)) {
            d['transclude'] = !!options.transclude;
        }
        if (angular.isDefined(options.replace)) {
            d['replace'] = !!options.replace;
        }
        heat.Loader.directive(options.selector, function () { return (d); });
    };
}
function Service(name) {
    return function (target) {
        var arr = target.$inject ? [].concat(target.$inject) : [];
        function F(args) {
            return target.apply(this, args);
        }
        F.prototype = target.prototype;
        arr.push(function () {
            return new F(arguments);
        });
        heat.Loader.factory(name, arr);
    };
}
function dashCase(str) {
    return str.replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); });
}
function controllerNameFromPath(str) {
    return str.split('/')[1].split('-').map(function (s) { return s.charAt(0).toUpperCase() + s.slice(1); }).join('') + 'Controller';
}
function createControllerTemplate(selector, inputs) {
    var dashName = dashCase(selector);
    var t = [];
    t.push('<', dashName, ' ng-if="1" flex layout="column" layout-fill');
    angular.forEach(inputs, function (name) {
        t.push(' ', name, '="', selector, '.$$routeParams.', name, '"');
    });
    t.push('></', dashName, '>');
    return t.join('');
}
function createController(inputs) {
    Controller.$inject = ['$routeParams'];
    function Controller($routeParams) {
        this.$$routeParams = {};
        if (angular.isArray(inputs)) {
            for (var i = 0; i < inputs.length; i++) {
                this.$$routeParams[inputs[i]] = $routeParams[inputs[i]];
            }
        }
    }
    return Controller;
}
function RouteConfig() {
    var paths = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        paths[_i] = arguments[_i];
    }
    return function (target) {
        heat.Loader.controller(controllerNameFromPath(paths[0]), createController(target.$$inputs));
        heat.Loader.run(['$templateCache', '$router', function ($templateCache, $router) {
                var dashName = dashCase(target.$$selector);
                $templateCache.put('./components/' + dashName + '/' + dashName + '.html', createControllerTemplate(target.$$selector, target.$$inputs));
                angular.forEach(paths, function (p) { return $router.config({ path: p, component: target.$$selector }); });
            }]);
    };
}
var AbstractBatchViewerComponent = (function () {
    function AbstractBatchViewerComponent($scope, $q, $timeout) {
        this.$scope = $scope;
        this.$q = $q;
        this.$timeout = $timeout;
        this.batches = [];
        this.batchSize = 10;
    }
    AbstractBatchViewerComponent.prototype.clear = function () {
        this.batches = [];
    };
    AbstractBatchViewerComponent.prototype.getFirst = function () {
        return this.batches[0];
    };
    AbstractBatchViewerComponent.prototype.getLast = function () {
        return this.batches[this.batches.length - 1];
    };
    AbstractBatchViewerComponent.prototype.getFirstIndex = function () {
        return this.getLast().firstIndex;
    };
    AbstractBatchViewerComponent.prototype.getParentScope = function () {
        return this.$scope.$parent['vm'];
    };
    AbstractBatchViewerComponent.prototype.getBatch = function (index) {
        var deferred = this.$q.defer();
        if (angular.isDefined(this.batches[index])) {
            deferred.resolve(this.batches[index]);
        }
        else {
            this.getBatchInternal(index).then(deferred.resolve, deferred.reject);
        }
        return deferred.promise;
    };
    AbstractBatchViewerComponent.prototype.getBatchInternal = function (index) {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.batches[index - 1])) {
            var previousFirstIndex = this.batches[index - 1].firstIndex;
            var firstIndex = Math.max(0, previousFirstIndex - this.batchSize);
            var lastIndex = previousFirstIndex - 1;
            this.getItems(firstIndex, lastIndex).then(function (items) {
                _this.batches[index] = new Batch(_this, items, firstIndex, lastIndex);
                deferred.resolve(_this.batches[index]);
            }, deferred.reject);
        }
        else {
            this.getCount().then(function (count) {
                var batchIndex = Math.floor(count / _this.batchSize);
                var firstIndex = batchIndex * _this.batchSize;
                var lastIndex = count;
                firstIndex = Math.max(0, firstIndex - _this.batchSize);
                _this.getItems(firstIndex, lastIndex).then(function (items) {
                    _this.batches[index] = new Batch(_this, items, firstIndex, lastIndex);
                    deferred.resolve(_this.batches[index]);
                }, deferred.reject);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    AbstractBatchViewerComponent.prototype.scrollUp = function () {
        var _this = this;
        if (this.getFirstIndex() > 0) {
            var batchIndex = this.batches.length - 1;
            var topBatch = this.batches[batchIndex];
            var topEntryId = topBatch.getFirst().__id;
            var topEntryElement = angular.element(document.getElementById(topEntryId));
            this.$scope.$evalAsync(function () { _this.getParentScope().loading = true; });
            this.getBatch(batchIndex + 1).then(function () {
                _this.$scope.$evalAsync(function () {
                    _this.$timeout(0).then(function () {
                        _this.getScrollContainer().duScrollToElement(topEntryElement, 0, 0, null).then(function () {
                            _this.$scope.$evalAsync(function () {
                                _this.getParentScope().loading = false;
                                _this.$timeout(0).then(function () {
                                    var offset = _this.getScrollContainer()[0].clientHeight -
                                        topEntryElement[0].offsetHeight;
                                    _this.getScrollContainer().duScrollToElement(topEntryElement, offset, 1200, heat.easing.easeOutCubic);
                                });
                            });
                        });
                    });
                });
            });
        }
    };
    return AbstractBatchViewerComponent;
}());
var Batch = (function () {
    function Batch(viewer, entries, firstIndex, lastIndex) {
        this.viewer = viewer;
        this.entries = entries;
        this.firstIndex = firstIndex;
        this.lastIndex = lastIndex;
        entries.forEach(function (e) { e["__id"] = e["__id"] || "batch-entry-".concat(Batch.COUNTER++); });
    }
    Batch.prototype.loadMore = function () {
        var batch = this;
        var deferred = this.viewer.$q.defer();
        this.viewer.getCount().then(function (count) {
            if (count > batch.lastIndex) {
                batch.viewer.getItems(batch.lastIndex, count).then(function (items) {
                    items.forEach(function (item) {
                        item["__id"] = "batch-entry-".concat(Batch.COUNTER++);
                        batch.entries.push(item);
                        batch.lastIndex++;
                    });
                    deferred.resolve(items);
                }, deferred.reject);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    Batch.prototype.getFirst = function () {
        return this.entries[0];
    };
    Batch.prototype.getLast = function () {
        return this.entries[this.entries.length - 1];
    };
    Batch.COUNTER = 0;
    return Batch;
}());
var ApplicationSystemTimeComponent = (function () {
    function ApplicationSystemTimeComponent(settings, $scope, $interval) {
        var _this = this;
        this.settings = settings;
        this.$scope = $scope;
        this.time = '           ';
        var interval = $interval(function () { return _this.update(); }, 1000, 0, false);
        $scope.$on('$destroy', function () { $interval.cancel(interval); });
        this.update();
    }
    ApplicationSystemTimeComponent.prototype.update = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.time = dateFormat(new Date(), _this.settings.get(SettingsService.DATEFORMAT_DEFAULT));
        });
    };
    ApplicationSystemTimeComponent = __decorate([
        Component({
            selector: 'applicationSystemTime',
            template: "\n  <span>{{vm.time}}</span>\n  "
        }),
        Inject('settings', '$scope', '$interval'),
        __metadata("design:paramtypes", [SettingsService, Object, Function])
    ], ApplicationSystemTimeComponent);
    return ApplicationSystemTimeComponent;
}());
var ArdorTransactionsProviderFactory = (function () {
    function ArdorTransactionsProviderFactory(http, $q, ardorBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
    }
    ArdorTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new ArdorTransactionsProvider(this.http, this.$q, this.ardorBlockExplorerService, account);
    };
    ArdorTransactionsProviderFactory = __decorate([
        Service('ardorTransactionsProviderFactory'),
        Inject('http', '$q', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, ArdorBlockExplorerService])
    ], ArdorTransactionsProviderFactory);
    return ArdorTransactionsProviderFactory;
}());
var ArdorTransactionsProvider = (function () {
    function ArdorTransactionsProvider(http, $q, ardorBlockExplorerService, account) {
        this.http = http;
        this.$q = $q;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.account = account;
    }
    ArdorTransactionsProvider.prototype.destroy = function () { };
    ArdorTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.ardorBlockExplorerService.getTransactionsCount(this.account).then(function (result) {
            deferred.resolve(result);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    ArdorTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.ardorBlockExplorerService.getTransactions(this.account, firstIndex, lastIndex);
    };
    return ArdorTransactionsProvider;
}());
var BchTransactionsProviderFactory = (function () {
    function BchTransactionsProviderFactory(http, $q, bchBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.bchBlockExplorerService = bchBlockExplorerService;
    }
    BchTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new BchTransactionsProvider(this.http, this.$q, this.bchBlockExplorerService, account);
    };
    BchTransactionsProviderFactory = __decorate([
        Service('bchTransactionsProviderFactory'),
        Inject('http', '$q', 'bchBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, BchBlockExplorerService])
    ], BchTransactionsProviderFactory);
    return BchTransactionsProviderFactory;
}());
var BchTransactionsProvider = (function () {
    function BchTransactionsProvider(http, $q, bchBlockExplorerService, account) {
        this.http = http;
        this.$q = $q;
        this.bchBlockExplorerService = bchBlockExplorerService;
        this.account = account;
    }
    BchTransactionsProvider.prototype.destroy = function () { };
    BchTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.bchBlockExplorerService.getAddressInfo(this.account).then(function (result) {
            deferred.resolve(result.txs);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    BchTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        var pageNum = (lastIndex / 10) || 0;
        var pageSize = (lastIndex - firstIndex) || 10;
        return this.bchBlockExplorerService.getTransactions(this.account, pageNum, pageSize);
    };
    return BchTransactionsProvider;
}());
var BtcTransactionsProviderFactory = (function () {
    function BtcTransactionsProviderFactory(http, $q, btcBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.btcBlockExplorerService = btcBlockExplorerService;
    }
    BtcTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new BtcTransactionsProvider(this.http, this.$q, this.btcBlockExplorerService, account);
    };
    BtcTransactionsProviderFactory = __decorate([
        Service('btcTransactionsProviderFactory'),
        Inject('http', '$q', 'btcBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, BtcBlockExplorerService])
    ], BtcTransactionsProviderFactory);
    return BtcTransactionsProviderFactory;
}());
var BtcTransactionsProvider = (function () {
    function BtcTransactionsProvider(http, $q, btcBlockExplorerService, account) {
        this.http = http;
        this.$q = $q;
        this.btcBlockExplorerService = btcBlockExplorerService;
        this.account = account;
    }
    BtcTransactionsProvider.prototype.destroy = function () { };
    BtcTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.btcBlockExplorerService.getAddressInfo(this.account).then(function (result) {
            deferred.resolve(result.transactions.length);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    BtcTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.btcBlockExplorerService.getTransactions(this.account, firstIndex, lastIndex);
    };
    return BtcTransactionsProvider;
}());
var CopyText = (function () {
    function CopyText(clipboard) {
        this.clipboard = clipboard;
    }
    CopyText.prototype.copy = function (element, successMsg) {
        this.clipboard.copyWithUI(document.getElementById(element), successMsg);
    };
    CopyText = __decorate([
        Component({
            selector: 'copyText',
            inputs: ['@elementId', '@message'],
            styles: ["\n    copy-text .clickable-icon {\n      cursor: pointer;\n    }\n  "],
            template: "\n    <md-icon md-font-library=\"material-icons\" ng-click=\"vm.copy(vm.elementId, vm.message)\" class=\"clickable-icon\">content_copy</md-icon>\n  "
        }),
        Inject('clipboard'),
        __metadata("design:paramtypes", [ClipboardService])
    ], CopyText);
    return CopyText;
}());
var DownloadingBlockchainComponent = (function () {
    function DownloadingBlockchainComponent($rootScope, $scope, heat, $interval, settings, router, $mdToast) {
        var _this = this;
        this.$rootScope = $rootScope;
        this.$scope = $scope;
        this.heat = heat;
        this.$interval = $interval;
        this.settings = settings;
        this.router = router;
        this.$mdToast = $mdToast;
        this.showComponent = false;
        this.lastBlockHeight = 0;
        this.lastBlockTime = 0;
        this.preHeight = 0;
        setTimeout(function () { return _this.refresh(); }, 1000);
        var skip = 0;
        this.refreshInterval = $interval(function () {
            if (skip > 0) {
                skip--;
                return;
            }
            _this.refresh();
            if (_this.lastBlockHeight - _this.preHeight > 20) {
                skip = 0;
            }
            else {
                skip = 10;
            }
            _this.preHeight = _this.lastBlockHeight;
        }, 6 * 1000, 0, false);
        setTimeout(function () { return _this.notifyOnServerLocationUpdating(); }, 1000);
        var checkServerHealthInterval;
        settings.initialized.then(function (value) {
            checkServerHealthInterval = $interval(function () {
                if (_this.settings.failoverEnabled) {
                    _this.checkServerHealth(_this.settings);
                }
            }, 33 * 1000, 0, false);
            setTimeout(function () {
                if (_this.settings.failoverEnabled) {
                    _this.checkServerHealth(_this.settings, true);
                }
            }, 300);
        });
        $scope.$on('$destroy', function () {
            $interval.cancel(_this.refreshInterval);
            if (checkServerHealthInterval)
                $interval.cancel(checkServerHealthInterval);
        });
    }
    DownloadingBlockchainComponent.prototype.refresh = function () {
        var _this = this;
        this.heat.api.getBlockchainStatus().then(function (status) {
            _this.$scope.$evalAsync(function () {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                var date = utils.timestampToDate(status.lastBlockTimestamp);
                _this.lastBlockTime = dateFormat(date, format);
                _this.lastBlockHeight = status.numberOfBlocks;
                if ((Date.now() - date.getTime()) > 1000 * 60 * 60) {
                    _this.showComponent = true;
                }
                else {
                    _this.showComponent = false;
                }
            });
        }, function () {
            _this.$scope.$evalAsync(function () {
                _this.showComponent = false;
            });
        });
    };
    DownloadingBlockchainComponent.prototype.checkServerHealth = function (settings, firstTime) {
        var _this = this;
        var knownServers = SettingsService.getFailoverDescriptor().knownServers || [];
        var currentServerHealth;
        var promises = [];
        knownServers.forEach(function (server) {
            var p = new Promise(function (resolve, reject) {
                _this.heat.api.getServerHealth(server.host, server.port).then(function (health) {
                    server.health = health;
                    server.statusError = null;
                    resolve(server);
                }, function (reason) {
                    server.health = null;
                    server.statusError = reason;
                    resolve(server);
                });
            });
            promises.push(p);
        });
        var minEqualityServersNumber = heat.isTestnet ? 3 : 10;
        var onHealthResponse = function () {
            var currentServerIsAlive = false;
            var currentServer = null;
            knownServers.forEach(function (server) {
                var health = server.health;
                server.statusScore = null;
                if (health)
                    server.statusScore = 0;
                if (server.host == settings.get(SettingsService.HEAT_HOST) && (server.port || "") == settings.get(SettingsService.HEAT_PORT)) {
                    currentServerHealth = health;
                    currentServer = server;
                    currentServerIsAlive = !server.statusError;
                    server.statusScore = currentServerIsAlive ? 0 : null;
                }
            });
            if (!currentServer)
                return;
            if (currentServerIsAlive && !currentServerHealth)
                return;
            knownServers.forEach(function (server) {
                var health = server.health;
                if (!health || !currentServerHealth || !(health.balancesEquality[1] >= minEqualityServersNumber))
                    return;
                var blocksEstimation = _this.calculateBlockchainEstimation(currentServerHealth, health);
                var balancesEqualityEstimation = _this.calculateBalancesEqualityEstimation(currentServerHealth, health);
                var peerEstimation = _this.calculatePeerEstimation(currentServerHealth, health);
                server.statusScore = (blocksEstimation == 1 && balancesEqualityEstimation >= 0 && peerEstimation >= 0)
                    ? blocksEstimation + balancesEqualityEstimation + peerEstimation
                    : 0;
            });
            var best = currentServer;
            var causeToSelectBest;
            knownServers.forEach(function (server) {
                if (best == currentServer && !currentServerIsAlive) {
                    best = server;
                    var se = currentServer.statusError;
                    causeToSelectBest = "Current host is unavailable"
                        + (se.code ? ". Code: " + se.code : "") + (se.description ? ". Description: " + se.description : "");
                    return;
                }
                if (server.statusScore >= 0 || !currentServerIsAlive) {
                    if ((server.statusScore != null && best.statusScore == null) || server.statusScore > best.statusScore) {
                        best = server;
                        causeToSelectBest = "Status score is better";
                        return;
                    }
                    if (server.statusScore == best.statusScore && server.priority < best.priority && best != server) {
                        best = server;
                        causeToSelectBest = "Server priority";
                        return;
                    }
                }
            });
            if (best && best != currentServer) {
                var bestIsAlive = !best.statusError;
                if (bestIsAlive) {
                    _this.switchToBestServer(settings, best, currentServer, firstTime, causeToSelectBest);
                }
            }
        };
        Promise.all(promises)
            .then(onHealthResponse, function (reason) { return console.error(reason); })
            .catch(function (reason) {
            console.error(reason);
        });
    };
    DownloadingBlockchainComponent.prototype.switchToBestServer = function (settings, bestServer, currentServer, firstTime, causeToSelectBest) {
        settings.setCurrentServer(bestServer);
        console.debug("api server is changed from " + currentServer.host + ":" + (currentServer.port || "") + " to " + bestServer.host + ":" + (bestServer.port || ""));
        this.notifyOnServerLocationUpdating(bestServer);
        this.heat.resetSubscriber();
        if (!firstTime) {
            var message = currentServer
                ? "Client API address switched from \n" + currentServer.host + ":" + (currentServer.port || "")
                    + "\n to \n" + bestServer.host + ":" + bestServer.port
                : "Client API address switched to\n" + bestServer.host + ":" + (bestServer.port || "");
            if (causeToSelectBest)
                message = message + " \n" + "Reason: " + causeToSelectBest;
            this.$mdToast.show(this.$mdToast.simple()
                .textContent(message)
                .highlightAction(true)
                .action('close')
                .highlightClass('md-warn')
                .hideDelay(0));
        }
    };
    DownloadingBlockchainComponent.prototype.calculateBlockchainEstimation = function (currentServerHealth, health) {
        var cumulativeDifficulty = new BigInteger(health.cumulativeDifficulty);
        var difficultyDelta = cumulativeDifficulty.compareTo(new BigInteger(currentServerHealth.cumulativeDifficulty));
        var threshold = SettingsService.getFailoverDescriptor().heightDeltaThreshold;
        if (Math.abs(health.lastBlockHeight - currentServerHealth.lastBlockHeight) > threshold) {
            if (difficultyDelta > 0)
                return 1;
            if (difficultyDelta < 0)
                return -1;
        }
        return 0;
    };
    DownloadingBlockchainComponent.prototype.calculateBalancesEqualityEstimation = function (currentServerHealth, health) {
        var mismatches = health.balancesEquality[0] / health.balancesEquality[1];
        var currentServerMismatches = currentServerHealth.balancesEquality[0] / currentServerHealth.balancesEquality[1];
        var mismatchesThreshold = SettingsService.getFailoverDescriptor().balancesMismatchesThreshold;
        var equalityThreshold = SettingsService.getFailoverDescriptor().balancesEqualityThreshold;
        return (mismatches < mismatchesThreshold * currentServerMismatches
            && health.balancesEquality[2] > equalityThreshold * currentServerHealth.balancesEquality[2])
            ? 1
            : (mismatches > currentServerMismatches || health.balancesEquality[2] < 0.7 * currentServerHealth.balancesEquality[2])
                ? -1
                : 0;
    };
    DownloadingBlockchainComponent.prototype.calculatePeerEstimation = function (currentServerHealth, health) {
        if (!health.peersIndicator)
            return -1;
        if (!currentServerHealth.peersIndicator)
            return 1;
        var connected = health.peersIndicator.connected / health.peersIndicator.all;
        var currentServerConnected = currentServerHealth.peersIndicator.connected / currentServerHealth.peersIndicator.all;
        var threshold = SettingsService.getFailoverDescriptor().connectedPeersThreshold;
        return (threshold * connected > currentServerConnected)
            ? 1
            : (connected < 0.8 * currentServerConnected)
                ? -1
                : 0;
    };
    DownloadingBlockchainComponent.prototype.notifyOnServerLocationUpdating = function (bestServer) {
        this.$rootScope.$emit('HEAT_SERVER_LOCATION', bestServer);
    };
    DownloadingBlockchainComponent = __decorate([
        Component({
            selector: 'downloadingBlockchain',
            template: "\n    <div layout=\"column\" flex layout-fill ng-show=\"vm.showComponent\">\n      <md-progress-linear md-mode=\"indeterminate\"></md-progress-linear>\n      <center><div><b>Attention!!</b></div>\n      <div>Downloading blockchain last block height: {{vm.lastBlockHeight}}, time {{vm.lastBlockTime}}</div></center>\n    </div>\n  "
        }),
        Inject('$rootScope', '$scope', 'heat', '$interval', 'settings', '$router', '$mdToast'),
        __metadata("design:paramtypes", [Object, Object, HeatService, Function, SettingsService, Object, Object])
    ], DownloadingBlockchainComponent);
    return DownloadingBlockchainComponent;
}());
var ElipsesLoadingComponent = (function () {
    function ElipsesLoadingComponent() {
    }
    ElipsesLoadingComponent = __decorate([
        Component({
            selector: 'elipsesLoading',
            styles: ["\n    .elipses-loading-one {\n        opacity: 0;\n        -webkit-animation: elipses-loading-dot 1.3s infinite;\n        -webkit-animation-delay: 0.0s;\n        animation: elipses-loading-dot 1.3s infinite;\n        animation-delay: 0.0s;\n    }\n\n    .elipses-loading-two {\n        opacity: 0;\n        -webkit-animation: elipses-loading-dot 1.3s infinite;\n        -webkit-animation-delay: 0.2s;\n          animation: elipses-loading-dot 1.3s infinite;\n          animation-delay: 0.2s;\n    }\n\n    .elipses-loading-three {\n        opacity: 0;\n        -webkit-animation: elipses-loading-dot 1.3s infinite;\n        -webkit-animation-delay: 0.3s;\n        animation: elipses-loading-dot 1.3s infinite;\n        animation-delay: 0.3s;\n    }\n\n    @-webkit-keyframes elipses-loading-dot {\n          0% { opacity: 0; }\n        50% { opacity: 0; }\n        100% { opacity: 1; }\n    }\n\n    @keyframes elipses-loading-dot {\n          0% { opacity: 0; }\n        50% { opacity: 0; }\n        100% { opacity: 1; }\n    }\n  "],
            template: "\n  <span class=\"elipses-loading-one\">.</span><span class=\"elipses-loading-two\">.</span><span class=\"elipses-loading-three\">.</span>\n  "
        })
    ], ElipsesLoadingComponent);
    return ElipsesLoadingComponent;
}());
var EthTransactionsProviderFactory = (function () {
    function EthTransactionsProviderFactory(http, $q, ethBlockExplorerService, ethTransactionParser) {
        this.http = http;
        this.$q = $q;
        this.ethBlockExplorerService = ethBlockExplorerService;
        this.ethTransactionParser = ethTransactionParser;
    }
    EthTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new EthTransactionsProvider(this.http, this.$q, this.ethBlockExplorerService, this.ethTransactionParser, account);
    };
    EthTransactionsProviderFactory = __decorate([
        Service('ethTransactionsProviderFactory'),
        Inject('http', '$q', 'ethBlockExplorerService', 'ethTransactionParser'),
        __metadata("design:paramtypes", [HttpService, Function, EthBlockExplorerService,
            EthTransactionParserService])
    ], EthTransactionsProviderFactory);
    return EthTransactionsProviderFactory;
}());
var EthTransactionsProvider = (function () {
    function EthTransactionsProvider(http, $q, ethBlockExplorerService, ethTransactionParser, account) {
        this.http = http;
        this.$q = $q;
        this.ethBlockExplorerService = ethBlockExplorerService;
        this.ethTransactionParser = ethTransactionParser;
        this.account = account;
        this.lastIndex = 0;
    }
    EthTransactionsProvider.prototype.destroy = function () { };
    EthTransactionsProvider.prototype.getPaginatedLength = function () {
        var _this = this;
        var deferred = this.$q.defer();
        if (this.ethBlockExplorerService.getProviderName() === 'Ethplorer') {
            if (!this.paginator) {
                var ethplorer = heat.$inject.get('ethplorer');
                this.paginator = ethplorer.createPaginator(this.account);
            }
            this.paginator.getCount().then(function (count) {
                deferred.resolve(Math.min(_this.lastIndex + 40, count));
            }, deferred.reject);
        }
        else {
            this.ethBlockExplorerService.getTransactionCount(this.account).then(function (result) {
                deferred.resolve(result);
            }, function () {
                deferred.reject();
            });
        }
        return deferred.promise;
    };
    EthTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        var _this = this;
        var deferred = this.$q.defer();
        if (this.ethBlockExplorerService.getProviderName() === 'Ethplorer') {
            if (lastIndex > this.lastIndex) {
                this.lastIndex = lastIndex;
            }
            if (!this.paginator) {
                var ethplorer = heat.$inject.get('ethplorer');
                this.paginator = ethplorer.createPaginator(this.account);
            }
            this.paginator.getItems(firstIndex, lastIndex).then(function (transactions) {
                deferred.resolve(_this.ethTransactionParser.parse(transactions));
            }, deferred.reject);
        }
        else {
            var pageNum = (lastIndex / 20) || 0;
            this.ethBlockExplorerService.getAddressTransactions(this.account, pageNum).then(function (transactions) {
                deferred.resolve(_this.ethTransactionParser.parse(transactions));
            }, deferred.reject);
        }
        return deferred.promise;
    };
    return EthTransactionsProvider;
}());
var ExplorerPaymentsProviderFactory = (function () {
    function ExplorerPaymentsProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    ExplorerPaymentsProviderFactory.prototype.createProvider = function (account) {
        return new PmtProvider(this.heat, this.$q, account);
    };
    ExplorerPaymentsProviderFactory = __decorate([
        Service('explorerPaymentsProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], ExplorerPaymentsProviderFactory);
    return ExplorerPaymentsProviderFactory;
}());
var PmtProvider = (function () {
    function PmtProvider(heat, $q, account) {
        this.heat = heat;
        this.$q = $q;
        this.account = account;
    }
    PmtProvider.prototype.destroy = function () { };
    PmtProvider.prototype.getPaginatedLength = function () {
        return this.heat.api.getPaymentsCount(this.account, "all");
    };
    PmtProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.heat.api.getPayments(this.account, "all", "timestamp", false, firstIndex, lastIndex);
    };
    return PmtProvider;
}());
var ExplorerTradesProviderFactory = (function () {
    function ExplorerTradesProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    ExplorerTradesProviderFactory.prototype.createProvider = function (account) {
        return new TraProvider(this.heat, this.$q, account);
    };
    ExplorerTradesProviderFactory = __decorate([
        Service('explorerTradesProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], ExplorerTradesProviderFactory);
    return ExplorerTradesProviderFactory;
}());
var TraProvider = (function () {
    function TraProvider(heat, $q, account) {
        this.heat = heat;
        this.$q = $q;
        this.account = account;
    }
    TraProvider.prototype.destroy = function () { };
    TraProvider.prototype.getPaginatedLength = function () {
        return this.heat.api.getAllAccountTradesCount(this.account);
    };
    TraProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.heat.api.getAllAccountTrades(this.account, "0", 0, firstIndex, lastIndex);
    };
    return TraProvider;
}());
var FimkTransactionsProviderFactory = (function () {
    function FimkTransactionsProviderFactory(http, $q, mofoSocketService) {
        this.http = http;
        this.$q = $q;
        this.mofoSocketService = mofoSocketService;
    }
    FimkTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new FimkTransactionsProvider(this.http, this.$q, this.mofoSocketService, account);
    };
    FimkTransactionsProviderFactory = __decorate([
        Service('fimkTransactionsProviderFactory'),
        Inject('http', '$q', 'mofoSocketService'),
        __metadata("design:paramtypes", [HttpService, Function, MofoSocketService])
    ], FimkTransactionsProviderFactory);
    return FimkTransactionsProviderFactory;
}());
var FimkTransactionsProvider = (function () {
    function FimkTransactionsProvider(http, $q, mofoSocketService, account) {
        this.http = http;
        this.$q = $q;
        this.mofoSocketService = mofoSocketService;
        this.account = account;
    }
    FimkTransactionsProvider.prototype.destroy = function () { };
    FimkTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.mofoSocketService.getTransactionsCount(this.account).then(function (result) {
            deferred.resolve(result);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    FimkTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        var pageNum = 0;
        pageNum = (lastIndex / 15) - 1;
        return this.mofoSocketService.getTransactions(this.account, pageNum);
    };
    return FimkTransactionsProvider;
}());
var IotaTransactionsProviderFactory = (function () {
    function IotaTransactionsProviderFactory(http, $q, iotaBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.iotaBlockExplorerService = iotaBlockExplorerService;
    }
    IotaTransactionsProviderFactory.prototype.createProvider = function (seed) {
        return new iotaTransactionsProvider(this.http, this.$q, this.iotaBlockExplorerService, seed);
    };
    IotaTransactionsProviderFactory = __decorate([
        Service('iotaTransactionsProviderFactory'),
        Inject('http', '$q', 'iotaBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, IotaBlockExplorerService])
    ], IotaTransactionsProviderFactory);
    return IotaTransactionsProviderFactory;
}());
var iotaTransactionsProvider = (function () {
    function iotaTransactionsProvider(http, $q, iotaBlockExplorerService, seed) {
        this.http = http;
        this.$q = $q;
        this.iotaBlockExplorerService = iotaBlockExplorerService;
        this.seed = seed;
    }
    iotaTransactionsProvider.prototype.destroy = function () { };
    iotaTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.iotaBlockExplorerService.getAccountInfo(this.seed)
            .then(function (result) {
            deferred.resolve(result.transfers.length);
        }, function (reason) {
            deferred.reject(reason);
        })
            .catch(function (reason) { return console.error(reason); });
        return deferred.promise;
    };
    iotaTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.iotaBlockExplorerService.getAccountInfo(_this.seed)
                .then(function (result) {
                return resolve(result.transfers);
            })
                .catch(function (reason) { return console.error(reason); });
        });
    };
    return iotaTransactionsProvider;
}());
var LatestBlocksProviderFactory = (function () {
    function LatestBlocksProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    LatestBlocksProviderFactory.prototype.createProvider = function (blockObject, account) {
        return new LatestBlocksProvider(this.heat, this.$q, blockObject, account);
    };
    LatestBlocksProviderFactory = __decorate([
        Service('latestBlocksProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], LatestBlocksProviderFactory);
    return LatestBlocksProviderFactory;
}());
var LatestBlocksProvider = (function () {
    function LatestBlocksProvider(heat, $q, blockObject, account) {
        this.heat = heat;
        this.$q = $q;
        this.blockObject = blockObject;
        this.account = account;
    }
    LatestBlocksProvider.prototype.destroy = function () { };
    LatestBlocksProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        if (angular.isDefined(this.blockObject)) {
            deferred.resolve(1);
        }
        else {
            if (this.account) {
                this.heat.api.getAccountBlocksCount(this.account).then(function (count) {
                    deferred.resolve(count);
                }, deferred.reject);
            }
            else {
                this.heat.api.getBlockchainStatus().then(function (status) {
                    deferred.resolve(status.numberOfBlocks);
                }, deferred.reject);
            }
        }
        return deferred.promise;
    };
    LatestBlocksProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (angular.isDefined(this.blockObject)) {
            var deferred = this.$q.defer();
            deferred.resolve([this.blockObject]);
            return deferred.promise;
        }
        else {
            if (this.account) {
                return this.heat.api.getAccountBlocks(this.account, firstIndex, lastIndex);
            }
            else {
                return this.heat.api.getBlocks(firstIndex, lastIndex);
            }
        }
    };
    return LatestBlocksProvider;
}());
var LtcTransactionsProviderFactory = (function () {
    function LtcTransactionsProviderFactory(http, $q, ltcBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.ltcBlockExplorerService = ltcBlockExplorerService;
    }
    LtcTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new LtcTransactionsProvider(this.http, this.$q, this.ltcBlockExplorerService, account);
    };
    LtcTransactionsProviderFactory = __decorate([
        Service('ltcTransactionsProviderFactory'),
        Inject('http', '$q', 'ltcBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, LtcBlockExplorerService])
    ], LtcTransactionsProviderFactory);
    return LtcTransactionsProviderFactory;
}());
var LtcTransactionsProvider = (function () {
    function LtcTransactionsProvider(http, $q, ltcBlockExplorerService, account) {
        this.http = http;
        this.$q = $q;
        this.ltcBlockExplorerService = ltcBlockExplorerService;
        this.account = account;
    }
    LtcTransactionsProvider.prototype.destroy = function () { };
    LtcTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.ltcBlockExplorerService.getAddressInfo(this.account).then(function (result) {
            deferred.resolve(result.txs);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    LtcTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        var pageNum = (lastIndex / 10) || 0;
        var pageSize = (lastIndex - firstIndex) || 10;
        return this.ltcBlockExplorerService.getTransactions(this.account, pageNum, pageSize);
    };
    return LtcTransactionsProvider;
}());
var NxtTransactionsProviderFactory = (function () {
    function NxtTransactionsProviderFactory(http, $q, nxtBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.nxtBlockExplorerService = nxtBlockExplorerService;
    }
    NxtTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new NxtTransactionsProvider(this.http, this.$q, this.nxtBlockExplorerService, account);
    };
    NxtTransactionsProviderFactory = __decorate([
        Service('nxtTransactionsProviderFactory'),
        Inject('http', '$q', 'nxtBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, NxtBlockExplorerService])
    ], NxtTransactionsProviderFactory);
    return NxtTransactionsProviderFactory;
}());
var NxtTransactionsProvider = (function () {
    function NxtTransactionsProvider(http, $q, nxtBlockExplorerService, account) {
        this.http = http;
        this.$q = $q;
        this.nxtBlockExplorerService = nxtBlockExplorerService;
        this.account = account;
    }
    NxtTransactionsProvider.prototype.destroy = function () { };
    NxtTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.nxtBlockExplorerService.getTransactionsCount(this.account).then(function (result) {
            deferred.resolve(result);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    NxtTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.nxtBlockExplorerService.getTransactions(this.account, firstIndex, lastIndex);
    };
    return NxtTransactionsProvider;
}());
var Timestamp = (function () {
    function Timestamp(settings, $scope) {
        this.settings = settings;
        this.$scope = $scope;
    }
    Timestamp.prototype.$onInit = function () {
        var _this = this;
        this.$scope.$watch(function () { return _this.timestampValue; }, function () { _this.update(); });
        this.update();
    };
    Timestamp.prototype.update = function () {
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var date = utils.timestampToDate(parseInt(this.timestampValue));
        this.timestampFormatted = this.timestampValue != "0" ? dateFormat(date, format) : "GENESIS";
    };
    Timestamp = __decorate([
        Component({
            selector: 'timestamp',
            inputs: ['timestampValue'],
            template: "\n    <span>{{ vm.timestampFormatted }}</span>\n  "
        }),
        Inject('settings', '$scope'),
        __metadata("design:paramtypes", [SettingsService, Object])
    ], Timestamp);
    return Timestamp;
}());
var TransactionVerificationError = (function () {
    function TransactionVerificationError(name, expected, actual) {
        this.name = name;
        this.expected = expected;
        this.actual = actual;
    }
    return TransactionVerificationError;
}());
var Appendix = (function () {
    function Appendix(bytes) {
        this.version = bytes.byteArray[bytes.pos];
        bytes.pos++;
    }
    return Appendix;
}());
var AppendixMessage = (function (_super) {
    __extends(AppendixMessage, _super);
    function AppendixMessage(bytes) {
        var _this = _super.call(this, bytes) || this;
        var length = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        _this.isText = length < 0;
        if (length < 0) {
            length &= 2147483647;
        }
        if (_this.isText) {
            _this.message = converters.byteArrayToString(bytes.byteArray, bytes.pos, length);
        }
        else {
            var slice = bytes.byteArray.slice(bytes.pos, bytes.pos + length);
            _this.message = converters.byteArrayToHexString(slice);
        }
        bytes.pos += length;
        return _this;
    }
    return AppendixMessage;
}(Appendix));
var AbstractEncryptedMessage = (function (_super) {
    __extends(AbstractEncryptedMessage, _super);
    function AbstractEncryptedMessage(bytes, data) {
        var _this = _super.call(this, bytes) || this;
        var length = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        _this.isText = length < 0;
        if (length < 0) {
            length &= 2147483647;
        }
        _this.encryptedMessageData = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + length));
        bytes.pos += length;
        _this.encryptedMessageNonce = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + 32));
        bytes.pos += 32;
        return _this;
    }
    return AbstractEncryptedMessage;
}(Appendix));
var AppendixEncryptedMessage = (function (_super) {
    __extends(AppendixEncryptedMessage, _super);
    function AppendixEncryptedMessage(bytes) {
        return _super.call(this, bytes, null) || this;
    }
    return AppendixEncryptedMessage;
}(AbstractEncryptedMessage));
var AppendixPublicKeyAnnouncement = (function (_super) {
    __extends(AppendixPublicKeyAnnouncement, _super);
    function AppendixPublicKeyAnnouncement(bytes) {
        var _this = _super.call(this, bytes) || this;
        _this.publicKey = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + 32));
        bytes.pos += 32;
        return _this;
    }
    return AppendixPublicKeyAnnouncement;
}(Appendix));
var AppendixEncryptToSelfMessage = (function (_super) {
    __extends(AppendixEncryptToSelfMessage, _super);
    function AppendixEncryptToSelfMessage(bytes) {
        return _super.call(this, bytes, null) || this;
    }
    return AppendixEncryptToSelfMessage;
}(AbstractEncryptedMessage));
var AppendixPrivateNameAnnouncement = (function (_super) {
    __extends(AppendixPrivateNameAnnouncement, _super);
    function AppendixPrivateNameAnnouncement(bytes) {
        var _this = _super.call(this, bytes) || this;
        _this.privateNameAnnouncement = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        return _this;
    }
    return AppendixPrivateNameAnnouncement;
}(Appendix));
var AppendixPrivateNameAssignment = (function (_super) {
    __extends(AppendixPrivateNameAssignment, _super);
    function AppendixPrivateNameAssignment(bytes) {
        var _this = _super.call(this, bytes) || this;
        _this.privateNameAssignment = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        _this.signature = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + 64));
        bytes.pos += 64;
        return _this;
    }
    return AppendixPrivateNameAssignment;
}(Appendix));
var AppendixPublicNameAnnouncement = (function (_super) {
    __extends(AppendixPublicNameAnnouncement, _super);
    function AppendixPublicNameAnnouncement(bytes) {
        var _this = _super.call(this, bytes) || this;
        var length = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        _this.publicNameAnnouncement = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + length));
        bytes.pos += length;
        return _this;
    }
    return AppendixPublicNameAnnouncement;
}(Appendix));
var AppendixPublicNameAssignment = (function (_super) {
    __extends(AppendixPublicNameAssignment, _super);
    function AppendixPublicNameAssignment(bytes) {
        var _this = _super.call(this, bytes) || this;
        var length = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        _this.publicNameAssignment = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + length));
        bytes.pos += length;
        _this.signature = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + 64));
        bytes.pos += 64;
        return _this;
    }
    return AppendixPublicNameAssignment;
}(Appendix));
var AbstractTransaction = (function () {
    function AbstractTransaction() {
    }
    AbstractTransaction.prototype.confirm = function (name, expected, actual) {
        if (expected != actual) {
            throw new TransactionVerificationError(name, expected, actual);
        }
    };
    AbstractTransaction.prototype.verifyAndSignTransactionBytes = function (transactionBytes, signature, data) {
        var transaction = {};
        var byteArray = converters.hexStringToByteArray(transactionBytes);
        transaction.type = byteArray[0];
        transaction.version = (byteArray[1] & 0xF0) >> 4;
        transaction.subtype = byteArray[1] & 0x0F;
        transaction.timestamp = converters.byteArrayToSignedInt32(byteArray, 2);
        transaction.deadline = converters.byteArrayToSignedShort(byteArray, 6);
        this.confirm("deadline", data.deadline, transaction.deadline);
        transaction.senderPublicKey = converters.byteArrayToHexString(byteArray.slice(8, 40));
        this.confirm("senderPublicKey", data.publicKey, transaction.senderPublicKey);
        transaction.recipient = String(converters.byteArrayToBigInteger(byteArray, 40));
        if (data.recipient)
            this.confirm("recipient", data.recipient, transaction.recipient);
        else {
            if (data.recipientPublicKey)
                this.confirm("recipientPublicKey", heat.crypto.getAccountIdFromPublicKey(data.recipientPublicKey), transaction.recipient);
            else
                this.confirm("recipient", "8150091319858025343", transaction.recipient);
        }
        transaction.amount = String(converters.byteArrayToBigInteger(byteArray, 48));
        if (data.OrdinaryPayment)
            this.confirm("amount", data.OrdinaryPayment.amountHQT, transaction.amount);
        else
            this.confirm("amount", "0", transaction.amount);
        transaction.fee = String(converters.byteArrayToBigInteger(byteArray, 56));
        this.confirm("fee", data.fee, transaction.fee);
        transaction.signature = converters.byteArrayToHexString(byteArray.slice(64, 128));
        transaction.flags = converters.byteArrayToSignedInt32(byteArray, 128);
        transaction.ecBlockHeight = converters.byteArrayToSignedInt32(byteArray, 132);
        transaction.ecBlockId = String(converters.byteArrayToBigInteger(byteArray, 136));
        var attachment = {
            byteArray: byteArray,
            pos: 145,
            attachmentVersion: byteArray[144]
        };
        if (!this.verify(transaction, attachment, data)) {
            return;
        }
        var position = 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixMessage(attachment);
            if (data.message !== false) {
                this.confirm("Message.message", data.message, appendix.message);
                this.confirm("Message.messageIsText", data.messageIsText, appendix.isText);
            }
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixEncryptedMessage(attachment);
            this.confirm("EncryptedMessage.encryptedMessageData", data.encryptedMessageData, appendix.encryptedMessageData);
            this.confirm("EncryptedMessage.encryptedMessageNonce", data.encryptedMessageNonce, appendix.encryptedMessageNonce);
            this.confirm("EncryptedMessage.messageToEncryptIsText", data.messageToEncryptIsText, appendix.isText);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPublicKeyAnnouncement(attachment);
            this.confirm("PublicKeyAnnouncement.recipientPublicKey", data.recipientPublicKey, appendix.publicKey);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixEncryptToSelfMessage(attachment);
            this.confirm("EncryptToSelfMessage.encryptedMessageData", data.encryptToSelfMessageData, appendix.encryptedMessageData);
            this.confirm("EncryptToSelfMessage.encryptedMessageNonce", data.encryptToSelfMessageNonce, appendix.encryptedMessageNonce);
            this.confirm("EncryptToSelfMessage.messageToEncryptIsText", data.messageToEncryptToSelfIsText, appendix.isText);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPrivateNameAnnouncement(attachment);
            this.confirm("PrivateNameAnnouncement.privateNameAnnouncement", data.privateNameAnnouncement, appendix.privateNameAnnouncement);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPrivateNameAssignment(attachment);
            this.confirm("PrivateNameAssignment.privateNameAssignment", data.privateNameAssignment, appendix.privateNameAssignment);
            this.confirm("PrivateNameAssignment.privateNameAssignmentSignature", data.privateNameAssignmentSignature, appendix.signature);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPublicNameAnnouncement(attachment);
            this.confirm("PublicNameAnnouncement.privateNameAssignment", data.publicNameAnnouncement, appendix.publicNameAnnouncement);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPublicNameAssignment(attachment);
            this.confirm("PublicNameAssignment.publicNameAssignment", data.publicNameAssignment, appendix.publicNameAssignment);
            this.confirm("PublicNameAssignment.publicNameAssignmentSignature", data.publicNameAssignmentSignature, appendix.signature);
        }
        var tmp1 = converters.hexStringToByteArray(transactionBytes);
        var tmp2 = converters.hexStringToByteArray(signature);
        Array.prototype.splice.apply(tmp1, [64, 64].concat(tmp2));
        return converters.byteArrayToHexString(tmp1);
    };
    AbstractTransaction.checkType = function (transaction, type, subtype) {
        return transaction.type === type && transaction.subtype === subtype;
    };
    return AbstractTransaction;
}());
var GenericDialogState;
(function (GenericDialogState) {
    GenericDialogState[GenericDialogState["EDIT"] = 0] = "EDIT";
    GenericDialogState[GenericDialogState["CREATE"] = 1] = "CREATE";
    GenericDialogState[GenericDialogState["SIGN"] = 2] = "SIGN";
    GenericDialogState[GenericDialogState["BROADCAST"] = 3] = "BROADCAST";
})(GenericDialogState || (GenericDialogState = {}));
var GenericDialogBroadcastState;
(function (GenericDialogBroadcastState) {
    GenericDialogBroadcastState[GenericDialogBroadcastState["INTERNAL_TIMEOUT"] = 0] = "INTERNAL_TIMEOUT";
    GenericDialogBroadcastState[GenericDialogBroadcastState["INTERNAL_ERROR"] = 1] = "INTERNAL_ERROR";
    GenericDialogBroadcastState[GenericDialogBroadcastState["SERVER_ERROR"] = 2] = "SERVER_ERROR";
})(GenericDialogBroadcastState || (GenericDialogBroadcastState = {}));
var GenericDialog = (function () {
    function GenericDialog($event) {
        this.okBtnTitle = 'OK';
        this.fields = {};
        this.state = GenericDialogState.EDIT;
        this.busy = false;
        this.error = false;
        this.cancelled = false;
        this.instantSend = false;
        this.bindToController = true;
        this.controllerAs = 'vm';
        this.controller = GenericDialogCreateController(this);
        this.parent = angular.element(document.body);
        this.template = "\n    <md-dialog class=\"{{ vm.dialogClass }}\">\n      <form name=\"dialogForm\">\n        <md-toolbar>\n          <div class=\"md-toolbar-tools\">\n            <h2>{{ vm.dialogTitle }}</h2>\n            <div class=\"wrapper\">&nbsp;</div>\n            <h2>\n              <span ng-if=\"vm.fields.recipient && vm.fields.recipient.value && vm.fields.recipient.accountExists && vm.fields.recipientPublicKey.value\">\n                {{vm.fields.recipient.value}}\n              </span>\n              <span ng-if=\"vm.fields.recipient && vm.fields.recipient.value && vm.fields.recipient.accountExists && !vm.fields.recipientPublicKey.value\"\n                    style=\"color: red\">NO PUBLIC KEY</span>\n              <span ng-if=\"vm.fields.recipient && vm.fields.recipient.value && vm.fields.recipient.accountExists === false\"\n                    style=\"color: red\">UNKNOWN DESTINATION</span>\n            </h2>\n          </div>\n        </md-toolbar>\n        <md-dialog-content style=\"min-width:500px\" layout=\"column\" layout-padding ng-switch=\"vm.state\">\n\n          <!-- EDIT -->\n          <div ng-switch-when=\"0\">\n            <div ng-repeat=\"field in vm.fields\">\n              <field selector=\"{{field._selector}}\" f=\"field\" label=\"field._label\" value=\"field.value\" changed=\"field.changed()\"></field>\n            </div>\n          </div>\n\n          <!-- CREATE -->\n          <div layout=\"column\" layout-align=\"center center\" ng-switch-when=\"1\" layout-padding>\n            <div layout=\"column\" layout-align=\"center center\">\n              <md-progress-circular md-mode=\"indeterminate\" ng-show=\"vm.busy\"></md-progress-circular>\n              <md-button class=\"md-fab md-warn\" ng-click=\"vm.state=0;vm.error=false;vm.maybeClose()\" ng-show=\"vm.error\">\n                <md-icon md-font-library=\"material-icons\">warning</md-icon>\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <div ng-show=\"vm.busy\">Creating transaction</div>\n              <div ng-show=\"vm.error\">{{vm.message}}</div>\n            </div>\n          </div>\n\n          <!-- SIGN -->\n          <div layout=\"column\" layout-align=\"center center\" ng-switch-when=\"2\" layout-padding>\n            <div layout=\"column\" layout-align=\"center center\">\n              <md-progress-circular md-mode=\"indeterminate\" ng-show=\"vm.busy\"></md-progress-circular>\n              <md-button class=\"md-fab md-warn\" ng-show=\"vm.error\" ng-click=\"vm.cancelBtn()\">\n                <md-icon md-font-library=\"material-icons\">warning</md-icon>\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <div ng-show=\"vm.busy\">Signing transaction</div>\n              <div ng-show=\"vm.error\">{{vm.message}}</div>\n            </div>\n          </div>\n\n          <!-- BROADCAST -->\n          <div layout=\"column\" layout-align=\"center center\" ng-switch-when=\"3\" layout-padding>\n            <div layout=\"column\" layout-align=\"center center\">\n              <md-progress-circular md-mode=\"indeterminate\" ng-show=\"vm.busy\"></md-progress-circular>\n              <md-button class=\"md-fab md-warn\" ng-show=\"vm.error && vm.broadcastState == 0\" ng-click=\"vm.broadcast()\">\n                <md-icon md-font-library=\"material-icons\">refresh</md-icon>\n              </md-button>\n              <md-button class=\"md-fab md-warn\" ng-show=\"vm.error && (vm.broadcastState == 1 || vm.broadcastState == 2)\"\n                    ng-click=\"vm.state=0;vm.error=false;vm.maybeClose()\">\n                <md-icon md-font-library=\"material-icons\">warning</md-icon>\n              </md-button>\n              <md-button class=\"md-fab md-primary\" ng-show=\"!vm.broadcastState && !vm.error && !vm.busy\" ng-click=\"vm.dialogHide()\">\n                <md-icon md-font-library=\"material-icons\">check</md-icon>\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <div ng-show=\"vm.busy\">Broadcasting transaction</div>\n              <div ng-show=\"vm.error\" layout=\"column\" layout-align=\"center center\">\n                <div>{{ vm.message }}</div>\n                <div>{{ vm.secondaryMessage }}</div>\n              </div>\n              <div ng-show=\"!vm.broadcastState && !vm.error && !vm.busy\" layout=\"column\" layout-align=\"center center\">\n                <!-- <div>Succesully broadcasted transaction</div> -->\n                <div>Transaction completed</div>\n              </div>\n            </div>\n          </div>\n        </md-dialog-content>\n        <md-dialog-actions layout=\"row\" ng-switch=\"vm.state\">\n          <md-button ng-if=\"!vm.customFeeTitle\" ng-click=\"0\" ng-disabled=\"true\" class=\"fee\" style=\"max-width:140px !important\">Fee {{vm.feeFormatted}} HEAT</md-button>\n          <md-button ng-if=\"vm.customFeeTitle\" ng-click=\"0\" ng-disabled=\"true\" class=\"fee\" style=\"max-width:140px !important\">{{vm.customFeeTitle}}</md-button>\n          <span flex></span>\n\n          <!-- EDIT -->\n          <div ng-switch-when=\"0\">\n            <md-button class=\"md-warn\" ng-click=\"vm.cancelBtn()\">Cancel</md-button>\n            <!--<md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.okBtn['processing']\"></md-progress-circular>-->\n            <span class=\"text-center\" ng-hide=\"!vm.okBtnReplacingText\"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{vm.okBtnReplacingText}}&nbsp;</i></span>\n            <md-button class=\"md-primary\" ng-hide=\"!!vm.okBtnReplacingText\" ng-click=\"vm.okBtn()\" ng-disabled=\"!dialogForm.$valid || vm.okBtnReplacingText || vm.okBtn['disabled']\">\n              {{vm.okBtnTitle}}\n            </md-button>\n          </div>\n\n          <!-- CREATE -->\n          <div ng-switch-when=\"1\" ng-show=\"vm.busy\">\n            <md-button class=\"md-warn\" ng-click=\"vm.cancelBtn()\">Cancel</md-button>\n          </div>\n\n          <!-- SIGN -->\n          <div ng-switch-when=\"2\">\n            <md-button class=\"md-warn\" ng-click=\"vm.cancelBtn()\" ng-show=\"vm.busy\">Cancel</md-button>\n            <md-button class=\"md-primary\" ng-click=\"vm.cancelBtn()\" ng-show=\"vm.error\">Close</md-button>\n          </div>\n\n          <!-- BROADCAST -->\n          <div ng-switch-when=\"3\">\n            <md-button class=\"md-warn\" ng-click=\"vm.cancelBtn()\" ng-show=\"vm.broadcastState==1 || vm.broadcastState==2\">Cancel</md-button>\n            <!-- <md-button class=\"md-primary\" ng-click=\"vm.reset()\" ng-show=\"!vm.broadcastState && !vm.error && !vm.busy\">More</md-button> -->\n          </div>\n        </md-dialog-actions>\n      </form>\n    </md-dialog>\n  ";
        this.targetEvent = $event;
    }
    GenericDialog.prototype.fieldsReady = function ($scope) { };
    GenericDialog.prototype.send = function () {
        this.instantSend = true;
        return this.show();
    };
    GenericDialog.prototype.show = function () {
        var $mdDialog = heat.$inject.get('$mdDialog');
        return $mdDialog.show(this);
    };
    return GenericDialog;
}());
function GenericDialogCreateController(dialog) {
    return function ($scope, $mdDialog, settings) {
        var _this = this;
        this.fields = dialog.getFields($scope);
        this.fields.forEach(function (field) {
            dialog.fields[field.name] = field;
            _this.fields[field.name] = field;
        });
        dialog.fieldsReady($scope);
        this.builder = null;
        this.visualization_delay = settings.get(SettingsService.TRANSACTION_PROCESSING_VISUALIZATION);
        this.stateRecipient = null;
        this.stateRecipientExists = false;
        this.stateRecipientNoPublicKey = false;
        this.dialogCancel = function () {
            $mdDialog.cancel();
        };
        this.dialogHide = function () {
            $mdDialog.hide(this.builder.transactionId);
        };
        this.reset = function () {
            this.state = GenericDialogState.EDIT;
            this.error = null;
            this.message = null;
            this.broadcastState = null;
            this.secondaryMessage = null;
            for (var i = 0; i < this.fields.length; i++) {
                this.fields[i].value = undefined;
            }
        };
        this.maybeClose = function () {
            if (dialog.instantSend) {
                this.dialogCancel();
            }
        };
        var overridedOkBtn = dialog['okBtn'];
        if (overridedOkBtn) {
            overridedOkBtn['mdDialog'] = $mdDialog;
            overridedOkBtn['scope'] = $scope;
        }
        this.okBtn = overridedOkBtn ? overridedOkBtn : function () {
            var _this = this;
            this.builder = dialog.getTransactionBuilder();
            this.state = GenericDialogState.CREATE;
            this.busy = true;
            this.error = false;
            this.message = null;
            var promise = utils.delayPromise(this.builder.create(), this.visualization_delay);
            promise.then(function () {
                if (_this.cancelled)
                    return;
                promise = utils.delayPromise(_this.builder.sign(), _this.visualization_delay);
                $scope.$evalAsync(function () {
                    _this.state = GenericDialogState.SIGN;
                    promise.then(function () {
                        if (_this.cancelled)
                            return;
                        _this.broadcast();
                    }, function (error) {
                        $scope.$evalAsync(function () {
                            _this.busy = false;
                            _this.error = true;
                            _this.message = error.description;
                        });
                    });
                });
            }, function (error) {
                $scope.$evalAsync(function () {
                    _this.busy = false;
                    _this.error = true;
                    _this.message = error.description;
                });
            });
        };
        this.cancelBtn = function () {
            this.cancelled = true;
            this.dialogCancel();
        };
        this.broadcast = function () {
            var _this = this;
            var promise = utils.delayPromise(this.builder.broadcast(), this.visualization_delay);
            $scope.$evalAsync(function () {
                _this.busy = true;
                _this.error = false;
                _this.state = GenericDialogState.BROADCAST;
                _this.broadcastState = null;
                promise.then(function (response) {
                    if (_this.cancelled)
                        return;
                    $scope.$evalAsync(function () {
                        _this.busy = false;
                        if (response.internalTimeout) {
                            _this.error = true;
                            _this.broadcastState = GenericDialogBroadcastState.INTERNAL_TIMEOUT;
                            _this.message = 'Internal timeout';
                            _this.secondaryMessage = 'Click to retry';
                        }
                        else if (response.internalError) {
                            _this.error = true;
                            _this.broadcastState = GenericDialogBroadcastState.INTERNAL_ERROR;
                            _this.message = 'Internal error';
                            _this.secondaryMessage = 'Unable to confirm broadcast succeeded';
                        }
                        else if (response.serverError) {
                            _this.error = true;
                            _this.broadcastState = GenericDialogBroadcastState.SERVER_ERROR;
                            _this.message = 'Server error';
                            _this.secondaryMessage = response.serverError;
                        }
                        else {
                            setTimeout(function () { _this.dialogHide(); }, 666);
                        }
                    });
                });
            });
        };
        if (this.instantSend) {
            this.okBtn();
        }
    };
}
var AssetIssueService = (function (_super) {
    __extends(AssetIssueService, _super);
    function AssetIssueService($q, user, assetInfo, heat, $interval) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.assetInfo = assetInfo;
        _this.heat = heat;
        _this.$interval = $interval;
        return _this;
    }
    AssetIssueService.prototype.dialog = function (currency, readonly, $event) {
        return new AssetIssueDialog($event, this, this.$q, this.user, this.assetInfo, this.heat, readonly, this.$interval);
    };
    AssetIssueService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 0)
            return false;
        var descriptionUrlLen = attachment.byteArray[attachment.pos];
        attachment.pos += 1;
        transaction.descriptionUrl = converters.byteArrayToString(attachment.byteArray, attachment.pos, descriptionUrlLen);
        attachment.pos += descriptionUrlLen;
        transaction.descriptionHash = converters.byteArrayToHexString(attachment.byteArray.slice(attachment.pos, attachment.pos + 32));
        attachment.pos += 32;
        transaction.quantity = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.decimals = attachment.byteArray[attachment.pos];
        attachment.pos += 1;
        transaction.dilutable = attachment.byteArray[attachment.pos] == 1;
        attachment.pos += 1;
        var result = transaction.descriptionUrl === data.AssetIssuance.descriptionUrl &&
            transaction.descriptionHash === data.AssetIssuance.descriptionHash &&
            transaction.quantity === data.AssetIssuance.quantityQNT &&
            transaction.decimals === data.AssetIssuance.decimals &&
            transaction.dilutable === data.AssetIssuance.dilutable;
        if (attachment.attachmentVersion >= 3) {
            transaction.expiration = converters.byteArrayToSignedInt32(attachment.byteArray, attachment.pos);
            attachment.pos += 4;
            result = result && transaction.expiration === data.AssetIssuance.expiration;
        }
        if (attachment.attachmentVersion >= 2) {
            transaction.assetType = attachment.byteArray[attachment.pos];
            attachment.pos += 1;
            result = result && transaction.assetType === data.AssetIssuance.type;
        }
        return result;
    };
    AssetIssueService = __decorate([
        Service('assetIssue'),
        Inject('$q', 'user', 'assetInfo', 'heat', '$interval'),
        __metadata("design:paramtypes", [Function, UserService,
            AssetInfoService,
            HeatService, Function])
    ], AssetIssueService);
    return AssetIssueService;
}(AbstractTransaction));
var AssetIssueDialog = (function (_super) {
    __extends(AssetIssueDialog, _super);
    function AssetIssueDialog($event, transaction, $q, user, assetInfo, heat, readonly, $interval) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.assetInfo = assetInfo;
        _this.heat = heat;
        _this.readonly = readonly;
        _this.$interval = $interval;
        _this.dialogTitle = 'Issue asset';
        _this.dialogDescription = 'Description on how to issue an asset';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.assetIssue, 8).replace(/000000$/, '');
        _this.okBtnTitle = 'SEND';
        return _this;
    }
    AssetIssueDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.switcher('assetType', false)
                .label('Asset type')
                .valueLabels("PRIVATE", "STANDARD")
                .valueNotes("PRIVATE ASSETS CAN ONLY BE TRADED OR TRANSFERRED BY ACCOUNTS YOU APPROVE", ""),
            builder.text('symbol').
                label('Asset symbol (3-4 chars)').
                validate("Symbol must have 3 to 4 chars", function (symbol) {
                var len = angular.isString(symbol) ? symbol.trim().length : 0;
                return len >= 3 && len <= 4;
            }).
                asyncValidate("Symbol name already in use", function (symbol) {
                var deferred = _this.$q.defer();
                _this.heat.api.getAssetProtocol1(symbol).then(function (asset) {
                    deferred.reject();
                }, function (response) {
                    var v = response && response.data && response.data.response ? response.data.response : response;
                    var error = v.description || v.errorDescription;
                    if (error == "Unknown asset")
                        deferred.resolve();
                    else
                        deferred.reject();
                });
                return deferred.promise;
            }).
                required(),
            builder.text('name').
                label('Asset name').
                validate("Name can be at most 100 characters long", function (name) {
                var len = angular.isString(name) ? name.trim().length : 0;
                return len <= 100;
            }).
                required(),
            builder.text('quantity').
                label('Quantity').
                required(),
            builder.text('decimals').
                label('Decimals').
                required().
                validate("Allowed range 0 .. 8", function (decimals) {
                var num = parseInt(decimals);
                if (isNaN(num))
                    return false;
                return num >= 0 && num <= 8;
            }),
            builder.switcher('dilutable', false)
                .label('Dilutable')
                .valueNotes("FOR DILUTABLE ASSETS MORE UNITS CAN BE ADDED LATER", ""),
            builder.text('expiration', 0)
                .label('Expiration timestamp (after timestamp the trading of asset will be disabled)'),
            builder.staticText("expirationDate", ''),
            builder.staticText("systemtimestamp", ''),
            builder.text('descriptionUrl', 'http://').
                label('Description URL (http:// or https://) (can be changed later)').
                validate("Either leave blank or has to start with http:// or https://", function (value) {
                return !value || value.indexOf('http://') == 0 || value.indexOf('https://') == 0;
            }).
                required(false),
            builder.text('descriptionHash').
                label('Description hash (SHA256) of the description url contents (can be changed later)').
                validate("Either leave blank or provide SHA256 hash in hex encoding", function (value) {
                if (value) {
                    if (!/[0-9A-Fa-f]{6}/g.test(value))
                        return false;
                    var bytes = converters.hexStringToByteArray(value);
                    if (bytes.length != 32)
                        return false;
                }
                return true;
            }).
                required(false),
        ];
    };
    AssetIssueDialog.prototype.fieldsReady = function ($scope) {
        var _this = this;
        var interval = this.$interval(function () {
            $scope.$evalAsync(function () {
                var expirationValue = parseInt(_this.fields['expiration'].value || '0');
                _this.fields['expirationDate'].value = expirationValue > 0
                    ? 'Entered expiration value date: ' + utils.timestampToDate(expirationValue).toLocaleString()
                    : '';
                _this.fields['systemtimestamp'].value = "Current timestamp: " + Math.round(utils.epochTime());
            });
        }, 1000, 0, false);
        $scope.$on('$destroy', function () { _this.$interval.cancel(interval); });
    };
    AssetIssueDialog.prototype.getTransactionBuilder = function () {
        var decimals = parseInt(this.fields['decimals'].value);
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.assetIssue)
            .attachment('AssetIssuance', {
            decimals: decimals,
            dilutable: this.fields['dilutable'].value == 'true',
            expiration: parseInt(this.fields['expiration'].value || '0'),
            quantityQNT: utils.convertToQNT(this.fields['quantity'].value, decimals),
            descriptionHash: this.fields['descriptionHash'].value || "0".repeat(64),
            descriptionUrl: this.fields['descriptionUrl'].value || 'http://',
            type: this.fields['assetType'].value ? 1 : 0
        });
        var properties = this.assetInfo.stringifyProperties({
            symbol: this.fields['symbol'].value,
            name: this.fields['name'].value
        });
        var messageHex = heat.bundle.createAssetProperties({
            asset: "0",
            protocol: 1,
            value: properties
        });
        builder.message(messageHex, TransactionMessageType.PUBLIC, true);
        return builder;
    };
    return AssetIssueDialog;
}(GenericDialog));
var SendmoneyService = (function (_super) {
    __extends(SendmoneyService, _super);
    function SendmoneyService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    SendmoneyService.prototype.dialog = function ($event, recipient, recipientPublicKey, amount, userMessage) {
        return new SendmoneyDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey, amount, userMessage);
    };
    SendmoneyService.prototype.verify = function (transaction, attachment) {
        return transaction.type === 0 && transaction.subtype === 0;
    };
    SendmoneyService = __decorate([
        Service('sendmoney'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], SendmoneyService);
    return SendmoneyService;
}(AbstractTransaction));
var SendmoneyDialog = (function (_super) {
    __extends(SendmoneyDialog, _super);
    function SendmoneyDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey, amount, userMessage) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.amount = amount;
        _this.userMessage = userMessage;
        _this.dialogTitle = 'Send HEAT';
        _this.dialogDescription = 'Description on how to send money';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.amount = _this.amount || '0';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    SendmoneyDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.account('recipient', this.recipient).
                label('Recipient').
                onchange(function () {
                _this.fields['recipientPublicKey'].value = null;
                _this.fields['message'].changed();
                _this.heat.api.getPublicKeyOrEmptyString(_this.fields['recipient'].value).then(function (publicKey) {
                    if (publicKey == '') {
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                    else {
                        _this.fields['recipientPublicKey'].value = publicKey;
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                }, function () {
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = false;
                    });
                });
            }).
                required(),
            builder.money('amount', this.amount).
                label('Amount').
                required().
                precision(8).
                symbol('HEAT').
                asyncValidate("Not enough funds", function (amount) {
                var deferred = _this.$q.defer();
                _this.heat.api.getAccountBalance(_this.user.account, '0').then(function (balance) {
                    try {
                        var avail = new Big(balance.unconfirmedBalance);
                        var total = new Big(amount).add(new Big(HeatAPI.fee.standard));
                        if (avail.gte(total) > 0) {
                            deferred.resolve();
                        }
                        else {
                            deferred.reject();
                        }
                    }
                    catch (e) {
                        deferred.reject();
                    }
                }, deferred.reject);
                return deferred.promise;
            }),
            builder.text('message', this.userMessage).
                rows(2).
                asyncValidate("No recipient public key", function (message) {
                var deferred = _this.$q.defer();
                if (String(message).trim().length == 0) {
                    deferred.resolve();
                }
                else {
                    if (_this.fields['recipientPublicKey'].value) {
                        deferred.resolve();
                    }
                    else {
                        _this.heat.api.getPublicKey(_this.fields['recipient'].value).then(function (publicKey) {
                            _this.fields['recipientPublicKey'].value = publicKey;
                            deferred.resolve();
                        }, deferred.reject);
                    }
                }
                return deferred.promise;
            }).
                label('Message'),
            builder.hidden('recipientPublicKey', this.recipientPublicKey)
        ];
    };
    SendmoneyDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('OrdinaryPayment', {
            amountHQT: this.fields['amount'].value
        });
        builder.recipient(this.fields['recipient'].value);
        builder.recipientPublicKey(this.fields['recipientPublicKey'].value);
        if (this.fields['message'].value) {
            builder.message(this.fields['message'].value, TransactionMessageType.TO_RECIPIENT);
        }
        return builder;
    };
    return SendmoneyDialog;
}(GenericDialog));
var ToolbarComponent = (function () {
    function ToolbarComponent($rootScope, $scope, $mdSidenav, user, sendmoney, electron, env, assetTransfer, assetIssue, whitelistAssetAccountService, assetAssignFees, whitelistMarket, assetExpiration, supervisoryAccount, accountAssetLimit, balanceLease, masternodeService, storage, $window, $mdToast, walletFile, localKeyStore, panel, $location, clipboard, p2pMessaging, settings) {
        var _this = this;
        this.$rootScope = $rootScope;
        this.$scope = $scope;
        this.$mdSidenav = $mdSidenav;
        this.user = user;
        this.sendmoney = sendmoney;
        this.electron = electron;
        this.env = env;
        this.assetTransfer = assetTransfer;
        this.assetIssue = assetIssue;
        this.whitelistAssetAccountService = whitelistAssetAccountService;
        this.assetAssignFees = assetAssignFees;
        this.whitelistMarket = whitelistMarket;
        this.assetExpiration = assetExpiration;
        this.supervisoryAccount = supervisoryAccount;
        this.accountAssetLimit = accountAssetLimit;
        this.balanceLease = balanceLease;
        this.masternodeService = masternodeService;
        this.storage = storage;
        this.$window = $window;
        this.$mdToast = $mdToast;
        this.walletFile = walletFile;
        this.localKeyStore = localKeyStore;
        this.panel = panel;
        this.$location = $location;
        this.clipboard = clipboard;
        this.p2pMessaging = p2pMessaging;
        this.settings = settings;
        this.isNodeEnv = false;
        this.isTestnet = heat.isTestnet;
        this.isBetanet = heat.isBetanet;
        this.hasUnreadP2PMessage = false;
        this.localHeatMasterAccounts = [];
        this.isNodeEnv = env.type == EnvType.NODEJS;
        var refresh = utils.debounce(this.refreshLocalWallet.bind(this), 1000, false);
        this.user.on(UserService.EVENT_UNLOCKED, refresh);
        this.refreshLocalWallet();
        $rootScope.$on('HEAT_SERVER_LOCATION', function (event, nothing) {
            _this.heatServerLocation = settings.get(SettingsService.HEAT_HOST) + ":" + settings.get(SettingsService.HEAT_PORT);
            _this.signalingURL = _this.settings.get(SettingsService.HEAT_MESSAGING).websocket;
        });
        var unreadChangedListener = function (rooms) {
            _this.$scope.$evalAsync(function () {
                _this.hasUnreadP2PMessage = rooms.length > 0;
            });
        };
        this.p2pMessaging.on(P2PMessaging.EVENT_HAS_UNREAD_CHANGED, unreadChangedListener);
        $scope.$on('$destroy', function () { return _this.p2pMessaging.removeListener(P2PMessaging.EVENT_HAS_UNREAD_CHANGED, unreadChangedListener); });
    }
    ToolbarComponent.prototype.copyAddress = function () {
        this.clipboard.copyWithUI(document.getElementById('toolbar-user-address'), 'Copied address to clipboard');
    };
    ToolbarComponent.prototype.goToHome = function () {
        this.$location.path(this.user.currency.homePath);
    };
    ToolbarComponent.prototype.checkLogin = function () {
        if (this.user.unlocked) {
            this.goToHome();
        }
        else {
            this.$location.path('login');
        }
    };
    ToolbarComponent.prototype.goToExchange = function () {
        if (this.user.currency && this.user.currency.symbol === 'ARDR') {
            this.$location.path('/ardor-trader/15307894944226771409/ardor');
        }
        else {
            this.isTestnet ? this.$location.path('/trader/2949625650944850605/0') : this.$location.path('/trader/5592059897546023466/0');
        }
    };
    ToolbarComponent.prototype.goToMessenger = function () {
        this.$location.path('/messenger/0');
    };
    ToolbarComponent.prototype.openTestPage = function () {
        var _this = this;
        var address = '0x98d84343b9b98bb15a2ba3d6867c42a89c37a067';
        var ethplorer = heat.$inject.get('ethplorer');
        ethplorer.getAddressInfo(address).then(function () {
            _this.$location.path('ethereum-account/' + address);
        });
    };
    ToolbarComponent.prototype.refreshLocalWallet = function () {
        var _this = this;
        this.localHeatMasterAccounts = [];
        this.localKeyStore.list().map(function (account) {
            var name = _this.localKeyStore.getName(account);
            _this.localHeatMasterAccounts.push({
                account: account,
                locked: true,
                identifier: name || account
            });
        });
        this.localHeatMasterAccounts.forEach(function (acc) {
            var password = _this.localKeyStore.getPasswordForAccount(acc.account);
            if (password) {
                acc.locked = false;
            }
        });
    };
    ToolbarComponent.prototype.unlock = function (secretPhrase) {
        var _this = this;
        this.user.unlock(secretPhrase, null).then(function () {
            var currentPath = _this.$location.path();
            if (currentPath.indexOf("/explorer-account/") > -1) {
                _this.$location.path("/explorer-account/".concat(_this.user.account, "/transactions"));
            }
            else {
                heat.fullApplicationScopeReload();
            }
        });
    };
    ToolbarComponent.prototype.selectWalletAccount = function ($event, item) {
        var _this = this;
        var password = this.localKeyStore.getPasswordForAccount(item.account);
        if (password) {
            var key = this.localKeyStore.load(item.account, password);
            if (key) {
                this.unlock(key.secretPhrase);
            }
        }
        else {
            dialogs.prompt($event, 'Enter Password (or Pin)', 'Please enter your Password (or Pin) to unlock', '').then(function (password) {
                try {
                    var key = _this.localKeyStore.load(item.account, password);
                    if (key) {
                        _this.unlock(key.secretPhrase);
                        return;
                    }
                }
                catch (e) {
                    console.log(e);
                }
                _this.$mdToast.show(_this.$mdToast.simple().textContent("Incorrect Password (or Pin)").hideDelay(5000));
            });
        }
    };
    ToolbarComponent.prototype.showSendmoneyDialog = function ($event) {
        this.user.currency.invokeSendDialog($event);
    };
    ToolbarComponent.prototype.showAssetTransferDialog = function ($event) {
        this.assetTransfer.dialog($event).show();
    };
    ToolbarComponent.prototype.showIssueAssetDialog = function ($event) {
        this.assetIssue.dialog($event).show();
    };
    ToolbarComponent.prototype.showWhitelistMarketDialog = function ($event) {
        var _this = this;
        var dialog = this.whitelistMarket.dialog($event);
        dialog.show().then(function () {
            var currency = dialog.fields['currency'].value;
            var asset = dialog.fields['asset'].value;
            var currencyAvailableAssets = dialog.fields['currency']['availableAssets'];
            var assetAvailableAssets = dialog.fields['asset']['availableAssets'];
            var currencySymbol, assetSymbol;
            for (var i = 0; i < currencyAvailableAssets.length; i++) {
                var available = currencyAvailableAssets[i];
                if (available.id == currency) {
                    currencySymbol = available.symbol;
                    break;
                }
            }
            for (var i = 0; i < assetAvailableAssets.length; i++) {
                var available = assetAvailableAssets[i];
                if (available.id == asset) {
                    assetSymbol = available.symbol;
                    break;
                }
            }
            var mymarkets = _this.storage.namespace('trader').get('my-markets');
            if (!mymarkets) {
                mymarkets = [];
            }
            mymarkets.push({
                currency: { id: currency, symbol: currencySymbol },
                asset: { id: asset, symbol: assetSymbol }
            });
            _this.storage.namespace('trader').put('my-markets', mymarkets);
        });
    };
    ToolbarComponent.prototype.showLeaseBalanceDialog = function ($event) {
        this.balanceLease.dialog(1440, null).show();
    };
    ToolbarComponent.prototype.registerInternetAddress = function ($event) {
        this.masternodeService.dialog(null).show();
    };
    ToolbarComponent.prototype.showWhitelistAssetAccountDialog = function ($event) {
        this.whitelistAssetAccountService.dialog($event).show();
    };
    ToolbarComponent.prototype.showAssetAssignAccountDialog = function ($event) {
        this.assetAssignFees.dialog($event).show();
    };
    ToolbarComponent.prototype.showAssetExpirationDialog = function ($event) {
        this.assetExpiration.dialog($event).show();
    };
    ToolbarComponent.prototype.showSupervisoryAccountDialog = function ($event) {
        this.supervisoryAccount.dialog($event).show();
    };
    ToolbarComponent.prototype.showAccountAssetLimitDialog = function ($event) {
        this.accountAssetLimit.dialog($event).show();
    };
    ToolbarComponent.prototype.signout = function () {
        this.user.lock();
    };
    ToolbarComponent.prototype.exit = function () {
        this.$window.close();
    };
    ToolbarComponent.prototype.about = function ($event) {
        dialogs.about($event);
    };
    ToolbarComponent.prototype.opendevTools = function () {
        this.electron.openDevTools(OpenDevToolsMode.detach);
    };
    ToolbarComponent.prototype.showQRCode = function (data) {
        var panel = heat.$inject.get('panel');
        panel.show("\n      <div layout=\"column\" flex>\n        <md-input-container flex>\n          <div class=\"qrcodeBox\" id=\"addressQRCode\"></div>\n          <p>\n          <md-button class=\"md-primary\" ng-click=\"vm.panel.close()\" aria-label=\"Cancel\" style=\"float: right\">Close</md-button>\n          </p>\n        </md-input-container>\n      </div>\n    ", { panel: panel });
        setTimeout(function () {
            new QRCode("addressQRCode", {
                text: data,
                width: 160,
                height: 160,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        }, 800);
    };
    ToolbarComponent.prototype.showSecretPhrase = function () {
        this.clipboard.showSecret(this.user.currency.secretPhrase, this.user.currency.symbol);
    };
    ToolbarComponent = __decorate([
        Component({
            selector: 'toolbar',
            styles: ["\n  toolbar .admin-menu .md-button:not(.active) {\n    background-color: #FFA726;\n  }\n  toolbar .admin-selected-user .md-button {\n    margin-right: 18px;\n    margin-left: 0px;\n  }\n  toolbar .test-net {\n    line-height: 0.6;\n  }\n  toolbar .test-net-color {\n    //background-color: #4CAF50 !important;\n    background-image: linear-gradient(180deg, #4CAF50 95%, transparent);\n  }\n  toolbar .beta-net-color {\n    background-color: #bf112f !important;\n  }\n  .unread-message-mark {\n    position: absolute;\n    top: 22px;\n    left: 32px;\n    color: green;\n    font-size: 35px;\n  }\n  .qrcodeBox {\n    padding: 20px;\n    margin-top: 15px;\n    background: white;\n    border-radius: 10px;\n    width: min-content;\n  }\n  .qrcode-link {\n    margin-left: 11px;\n  }\n  "],
            template: "\n    <md-toolbar class=\"main-toolbar\" ng-class=\"{'test-net-color':vm.isTestnet,'beta-net-color':vm.isBetanet}\">\n      <div class=\"md-toolbar-tools\">\n        <h3 ng-if=\"vm.isTestnet\" class=\"test-net\">\n          <md-tooltip md-direction=\"bottom\">See About dialog to switch to main net</md-tooltip>\n          TEST-NET&nbsp;&nbsp;&nbsp;&nbsp;\n          <br/><span style=\"font-size:9px; font-weight:normal; color:lightgrey\">\n          {{vm.heatServerLocation}}&nbsp;&nbsp;&nbsp;&nbsp;<br/>\n          {{vm.signalingURL}}&nbsp;&nbsp;&nbsp;&nbsp;\n          </span>\n        </h3>\n        <h2 ng-if=\"vm.isBetanet\" class=\"test-net\">\n          <md-tooltip md-direction=\"bottom\">See About dialog to switch to main net</md-tooltip>\n          B E T A N E T &nbsp;\n        </h2>\n\n        <div class=\"wrapper\">\n          <div>\n            <div class=\"user\">\n              <div class=\"small-logo\" ng-if=\"!vm.isBetanet\" ng-click=\"vm.checkLogin()\" ></div>\n              <h2 ng-if=\"vm.user.unlocked\">\n                <div class=\"account-name\">{{vm.user.accountName}}</div>\n                <div>\n                  <user-balance ng-if=\"vm.user.unlocked\"></user-balance>\n                </div>\n              </h2>\n            </div>\n\n            <div ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"home\" class=\"md-icon-button\" ng-click=\"vm.goToHome()\">\n                <md-tooltip md-direction=\"bottom\">Your {{vm.user.currency.symbol}} Home</md-tooltip>\n                <i><img src=\"assets/homeIcon.png\"></i>\n              </md-button>\n            </div>\n\n            <div>\n              <md-button aria-label=\"explorer\" class=\"md-icon-button\" href=\"#/explorer\">\n                <md-tooltip md-direction=\"bottom\">Blockchain explorer</md-tooltip>\n                <i><img src=\"assets/exploreIcon.png\"></i>\n              </md-button>\n              <md-button aria-label=\"trader\" class=\"md-icon-button\" ng-click=\"vm.goToExchange()\">\n                <md-tooltip md-direction=\"bottom\">Exchange</md-tooltip>\n                <i><img src=\"assets/exchangeIcon.png\"></i>\n              </md-button>\n              <md-button aria-label=\"server\" class=\"md-icon-button\" href=\"#/server\" ng-show=\"vm.isNodeEnv\">\n                <md-tooltip md-direction=\"bottom\">App Server</md-tooltip>\n                <i><img src=\"assets/serverIcon.png\"></i>\n              </md-button>\n              <md-button aria-label=\"peers\" class=\"md-icon-button\" href=\"#/peers\">\n                <md-tooltip md-direction=\"bottom\">Peers</md-tooltip>\n                <i><img style=\"filter: invert(1);height: 28px;\" src=\"assets/network_node.svg\"></i>\n              </md-button>\n              <md-button aria-label=\"home\" class=\"md-icon-button\" href=\"#/wallet\" ng-if=\"!vm.user.unlocked\">\n                <md-tooltip md-direction=\"bottom\">Wallet</md-tooltip>\n                <i><img src=\"assets/walletIcon.png\"></i>\n              </md-button>\n\n              <!--\n              <md-button aria-label=\"home\" class=\"md-icon-button\" ng-click=\"vm.$mdToast.show(vm.$mdToast.simple().textContent('Incorrect Password (or Pin)').hideDelay(15000))\">\n                <i><img src=\"assets/walletIcon.png\"></i>\n              </md-button>\n              -->\n\n\n            </div>\n\n            <div hide show-gt-sm ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"send heat\" class=\"md-icon-button\" ng-click=\"vm.showSendmoneyDialog($event);\">\n                <md-tooltip md-direction=\"bottom\">Send {{vm.user.currency.symbol}}</md-tooltip>\n                <i><img src=\"assets/sendHeatIcon.png\"></i>\n              </md-button>\n              <md-button aria-label=\"messages\" class=\"md-icon-button\" ng-click=\"vm.goToMessenger()\">\n                <md-tooltip md-direction=\"bottom\">Messages</md-tooltip>\n                <i>\n                  <img src=\"assets/messageIcon.png\">\n                </i>\n                <div class=\"unread-message-mark\" ng-if=\"vm.hasUnreadP2PMessage\">*</div>\n              </md-button>\n              <md-button aria-label=\"home\" class=\"md-icon-button\" href=\"#/wallet\">\n                <md-tooltip md-direction=\"bottom\">Wallet</md-tooltip>\n                <i><img src=\"assets/walletIcon.png\"></i>\n              </md-button>\n            </div>\n\n            <md-menu md-position-mode=\"target-right target\" md-offset=\"34px 34px\" hide-gt-sm ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"user menu\" class=\"md-icon-button\" ng-click=\"$mdMenu.open($event)\" md-menu-origin >\n                <md-icon md-font-library=\"material-icons\">more_vert</md-icon>\n              </md-button>\n              <md-menu-content width=\"4\">\n                <md-menu-item ng-if=\"vm.user.unlocked\">\n                  <md-button aria-label=\"home\" ng-click=\"vm.goToHome()\">\n                    <md-icon md-font-library=\"material-icons\">home</md-icon>\n                    Your {{vm.user.currency.symbol}} Home\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button aria-label=\"explorer\" href=\"#/explorer\">\n                    <md-icon md-font-library=\"material-icons\">explore</md-icon>\n                    Blockchain explorer\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button aria-label=\"trader\" ng-click=\"vm.goToExchange()\">\n                    <md-icon md-font-library=\"material-icons\">bar_chart</md-icon>\n                    Exchange\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item ng-show=\"vm.isNodeEnv\">\n                  <md-button aria-label=\"server\" href=\"#/server\">\n                    <md-icon md-font-library=\"material-icons\">settings</md-icon>\n                    App Server\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button aria-label=\"wallet\" href=\"#/wallet\">\n                    <md-icon md-font-library=\"material-icons\">account_balance_wallet</md-icon>\n                    Wallet\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item ng-if=\"vm.user.unlocked\">\n                  <md-button aria-label=\"send heat\" ng-click=\"vm.showSendmoneyDialog($event);\">\n                    <md-icon md-font-library=\"material-icons\">send</md-icon>\n                    Send {{vm.user.currency.symbol}}\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item ng-if=\"vm.user.unlocked\">\n                  <md-button aria-label=\"messages\" ng-click=\"vm.goToMessenger()\">\n                    <md-icon md-font-library=\"material-icons\">chat</md-icon>\n                    Messages\n                  </md-button>\n                </md-menu-item>\n                <!--\n                <md-menu-item>\n                  <md-button aria-label=\"home\" ng-click=\"vm.openTestPage()\">\n                    <md-icon md-font-library=\"material-icons\">check</md-icon>\n                  </md-button>\n                </md-menu-item>\n                -->\n              </md-menu-content>\n            </md-menu>\n\n            <span flex></span>\n\n            <div class=\"selected-address\" ng-if=\"vm.user.unlocked\">\n              <div>Currently using <b>{{vm.user.currency.symbol}}</b>\n                <a ng-click=\"vm.showQRCode(vm.user.currency.address)\" class=\"qrcode-link\">\n                  <md-tooltip>Show QR code</md-tooltip>\n                  <md-icon md-font-library=\"material-icons\">qr_code</md-icon>\n                </a>\n              </div>\n              <div layout=\"row\">\n                <div class=\"address wrapped\">\n                  <a ng-click=\"vm.copyAddress()\" id=\"toolbar-user-address\">{{vm.user.currency.address}}\n                    <md-tooltip>Copy to clipboard</md-tooltip>\n                  </a>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <md-menu ng-if=\"vm.user.unlocked\" style=\"margin-right: -12px;\">\n          <md-button aria-label=\"signout\" class=\"md-icon-button\" ng-click=\"$mdMenu.open($event)\" md-menu-origin >\n            <md-icon md-font-library=\"material-icons\">face</md-icon>\n          </md-button>\n          <md-menu-content width=\"4\">\n            <md-menu-item ng-repeat=\"item in vm.localHeatMasterAccounts\">\n              <md-button ng-click=\"vm.selectWalletAccount($event, item)\">\n                <span>{{item.identifier}}</span>\n              </md-button>\n            </md-menu-item>\n          </md-menu>\n        </md-menu>\n\n        <md-menu md-position-mode=\"target-right target\" md-offset=\"34px 0px\">\n          <md-button aria-label=\"signout\" class=\"md-icon-button\" ng-click=\"$mdMenu.open($event)\" md-menu-origin >\n            <i><img src=\"assets/sandwich.png\"></i>\n          </md-button>\n          <md-menu-content width=\"4\">\n\n              <md-menu-item ng-if=\"vm.user.unlocked\">\n                <md-button aria-label=\"transfer asset\" ng-click=\"vm.showAssetTransferDialog($event)\">\n                  <md-icon md-font-library=\"material-icons\">swap_horiz</md-icon>\n                  <span>Transfer Asset</span>\n                </md-button>\n              </md-menu-item>\n              <md-menu-item ng-if=\"vm.user.unlocked\">\n                <md-button aria-label=\"issue asset\" ng-click=\"vm.showIssueAssetDialog($event)\">\n                  <md-icon md-font-library=\"material-icons\">library_add</md-icon>\n                  <span>Issue Asset</span>\n                </md-button>\n              </md-menu-item>\n              <md-menu-item ng-if=\"vm.user.unlocked\">\n                <md-button aria-label=\"assign fees to private asset\" ng-click=\"vm.showAssetAssignAccountDialog($event)\">\n                  <md-icon md-font-library=\"material-icons\">sports_baseball</md-icon>\n                  <span>Fees for private asset</span>\n                </md-button>\n              </md-menu-item>\n              <md-menu-item ng-if=\"vm.user.unlocked\">\n                <md-button aria-label=\"assign expiration timestamp to asset\" ng-click=\"vm.showAssetExpirationDialog($event)\">\n                  <md-icon md-font-library=\"material-icons\">av_timer</md-icon>\n                  <span>Assign expiration to asset</span>\n                </md-button>\n              </md-menu-item>\n              <md-menu-item ng-if=\"vm.user.unlocked\">\n                <md-button aria-label=\"whitelist account for private asset\" ng-click=\"vm.showWhitelistAssetAccountDialog($event)\">\n                  <md-icon md-font-library=\"material-icons\">how_to_reg</md-icon>\n                  <span>Whitelist account for private asset</span>\n                </md-button>\n              </md-menu-item>\n              <md-menu-item ng-if=\"vm.user.unlocked\">\n                <md-button aria-label=\"set supervisory account\" ng-click=\"vm.showSupervisoryAccountDialog($event)\">\n                  <md-icon md-font-library=\"material-icons\">supervisor_account</md-icon>\n                  <span>Set supervisory account</span>\n                </md-button>\n              </md-menu-item>\n              <md-menu-item ng-if=\"vm.user.unlocked\">\n                <md-button aria-label=\"set max asset amount per interval that account can to send\" ng-click=\"vm.showAccountAssetLimitDialog($event)\">\n                  <md-icon md-font-library=\"material-icons\">vertical_align_center</md-icon>\n                  <!--<md-icon md-font-library=\"material-icons\">horizontal_distribute</md-icon>-->\n                  <span>Set asset amount limit</span>\n                </md-button>\n              </md-menu-item>\n\n            <md-menu-divider ng-if=\"vm.user.unlocked\"></md-menu-divider>\n\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"whitelits market\" ng-click=\"vm.showWhitelistMarketDialog($event)\">\n                <md-icon md-font-library=\"material-icons\">insert_chart</md-icon>\n                <span>Create/Update Market</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"lease balance\" ng-click=\"vm.showLeaseBalanceDialog($event)\">\n                <md-icon md-font-library=\"material-icons\">update</md-icon>\n                <span>Lease Balance</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"register internet address\" ng-click=\"vm.registerInternetAddress($event)\">\n                <md-icon md-font-library=\"material-icons\">spellcheck</md-icon>\n                <span>Register Masternode Address</span>\n              </md-button>\n            </md-menu-item>\n\n            <md-menu-divider ng-if=\"vm.user.unlocked\"></md-menu-divider>\n\n            <md-menu-item ng-show=\"vm.isNodeEnv\">\n              <md-button aria-label=\"dev-tools\" ng-click=\"vm.opendevTools($event)\">\n                <md-icon md-font-library=\"material-icons\">developer_board</md-icon>\n                Developer tools\n              </md-button>\n            </md-menu-item>\n            <md-menu-item>\n              <md-button aria-label=\"about\" ng-click=\"vm.about($event)\">\n                <md-icon md-font-library=\"material-icons\">info_outline</md-icon>\n                About HEAT\n              </md-button>\n            </md-menu-item>\n            <md-menu-item>\n              <md-button aria-label=\"about\" href=\"https://heatwallet.com/api\" target=\"_blank\" rel=\"noopener noreferrer\">\n                <md-icon md-font-library=\"material-icons\">find_in_page</md-icon>\n                <span>Heat API (external)</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"Show private key (or secret phrase)\" ng-click=\"vm.showSecretPhrase()\">\n                <md-icon md-font-library=\"material-icons\">content_copy</md-icon>\n                <span>Show private key</span>\n              </md-button>\n            </md-menu-item>\n            <!--<md-menu-item>\n              <md-button aria-label=\"backup\" ng-click=\"vm.backupWallet()\">\n                <md-icon md-font-library=\"material-icons\">save</md-icon>\n                <span>Backup Wallet</span>\n              </md-button>\n            </md-menu-item>-->\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"signout\" ng-click=\"vm.signout()\">\n                <md-icon md-font-library=\"material-icons\">close</md-icon>\n                Sign out\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"!vm.user.unlocked\">\n              <md-button aria-label=\"signin\" href=\"#/login\">\n                <md-icon md-font-library=\"material-icons\">lock_open</md-icon>\n                Sign in\n              </md-button>\n            </md-menu-item>\n            <md-menu-item ng-if=\"vm.isNodeEnv\">\n              <md-button aria-label=\"exit\" ng-click=\"vm.exit()\">\n                <md-icon md-font-library=\"material-icons\">exit_to_app</md-icon>\n                Exit\n              </md-button>\n            </md-menu-item>\n          </md-menu-content>\n        </md-menu>\n      </div>\n    </md-toolbar>\n  "
        }),
        Inject('$rootScope', '$scope', '$mdSidenav', 'user', 'sendmoney', 'electron', 'env', 'assetTransfer', 'assetIssue', 'whitelistAssetAccount', 'assetAssignFees', 'whitelistMarket', 'assetExpiration', 'supervisoryAccount', 'accountAssetLimit', 'balanceLease', 'masternode', 'storage', '$window', '$mdToast', 'walletFile', 'localKeyStore', 'panel', '$location', 'clipboard', 'P2PMessaging', 'settings'),
        __metadata("design:paramtypes", [Object, Object, Object, UserService,
            SendmoneyService,
            ElectronService,
            EnvService,
            AssetTransferService,
            AssetIssueService,
            WhitelistAssetAccountService,
            AssetAssignFeesService,
            WhitelistMarketService,
            AssetExpirationService,
            SupervisoryAccountService,
            AccountAssetLimitService,
            BalanceLeaseService,
            MasternodeService,
            StorageService, Object, Object, WalletFileService,
            LocalKeyStoreService,
            PanelService, Object, ClipboardService,
            P2PMessaging,
            SettingsService])
    ], ToolbarComponent);
    return ToolbarComponent;
}());
var TransactionsProviderFactory = (function () {
    function TransactionsProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    TransactionsProviderFactory.prototype.createProvider = function (account, block, transactionObject) {
        return new TransactionsProvider(this.heat, this.$q, account, block, transactionObject);
    };
    TransactionsProviderFactory = __decorate([
        Service('transactionsProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], TransactionsProviderFactory);
    return TransactionsProviderFactory;
}());
var TransactionsProvider = (function () {
    function TransactionsProvider(heat, $q, account, block, transactionObject) {
        this.heat = heat;
        this.$q = $q;
        this.account = account;
        this.block = block;
        this.transactionObject = transactionObject;
    }
    TransactionsProvider.prototype.destroy = function () { };
    TransactionsProvider.prototype.getPaginatedLength = function () {
        if (angular.isString(this.account)) {
            return this.heat.api.getTransactionsForAccountCount(this.account);
        }
        else if (angular.isString(this.block)) {
            return this.heat.api.getTransactionsForBlockCount(this.block);
        }
        else if (angular.isDefined(this.transactionObject)) {
            var deferred = this.$q.defer();
            deferred.resolve(1);
            return deferred.promise;
        }
        return this.heat.api.getTransactionsForAllCount();
    };
    TransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (angular.isString(this.account)) {
            return this.heat.api.getTransactionsForAccount(this.account, firstIndex, lastIndex);
        }
        else if (angular.isString(this.block)) {
            return this.heat.api.getTransactionsForBlock(this.block, firstIndex, lastIndex);
        }
        else if (angular.isDefined(this.transactionObject)) {
            var deferred = this.$q.defer();
            deferred.resolve([this.transactionObject]);
            return deferred.promise;
        }
        return this.heat.api.getTransactionsForAll(firstIndex, lastIndex);
    };
    return TransactionsProvider;
}());
var UserBalanceComponent = (function () {
    function UserBalanceComponent($scope, user, heat, $q, $interval) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.heat = heat;
        this.$q = $q;
        this.$interval = $interval;
        this.formattedBalance = "0";
        this.formattedFraction = ".00";
        this.loading = true;
        this.showError = false;
        var refresh = utils.debounce((angular.bind(this, this.refresh)), 1 * 1000, false);
        var unsubscribe = this.user.currency.subscribeBalanceChanged(function () { return refresh(); });
        $scope.$on('$destroy', unsubscribe);
        this.user.on(UserService.EVENT_UNLOCKED, refresh);
        var interval = $interval(function () { return _this.refresh(); }, 5 * 1000);
        $scope.$on('$destroy', function () {
            $interval.cancel(interval);
            _this.user.removeListener(UserService.EVENT_UNLOCKED, refresh);
        });
        this.refresh();
    }
    UserBalanceComponent.prototype.refresh = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.loading = true;
        });
        this.user.currency.getBalance().then(function (balance) {
            _this.$scope.$evalAsync(function () {
                var formatted = balance.split(".");
                _this.formattedBalance = formatted[0];
                _this.formattedFraction = "." + (formatted[1] || "00");
                _this.showError = false;
                _this.loading = false;
            });
        }, function (error) {
            _this.$scope.$evalAsync(function () {
                _this.formattedBalance = "0";
                _this.formattedFraction = ".00000000";
                _this.showError = true;
                _this.errorDescription = error ? error.description : "-";
                _this.loading = false;
            });
        });
    };
    UserBalanceComponent = __decorate([
        Component({
            selector: 'userBalance',
            template: "\n    <div layout=\"column\">\n      <span>\n        <md-tooltip ng-if=\"vm.showError\" md-direction=\"bottom\">{{vm.errorDescription}}</md-tooltip>\n        <span class=\"balance\">{{vm.formattedBalance}}</span>\n        <span class=\"fraction\">{{vm.formattedFraction}}</span>&nbsp;\n        <span class=\"currencyName\">{{vm.user.currency.symbol}}</span>\n        <md-icon ng-if=\"vm.showError\" md-font-library=\"material-icons\">error</md-icon>\n      </span>\n    </div>\n  "
        }),
        Inject('$scope', 'user', 'heat', '$q', '$interval'),
        __metadata("design:paramtypes", [Object, UserService,
            HeatService, Function, Function])
    ], UserBalanceComponent);
    return UserBalanceComponent;
}());
var UserContactsComponent = (function () {
    function UserContactsComponent($scope, user, heat, $q, $timeout, $interval, $location, $rootScope, storage, p2pMessaging, $mdToast, contactService) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.heat = heat;
        this.$q = $q;
        this.$timeout = $timeout;
        this.$interval = $interval;
        this.$location = $location;
        this.$rootScope = $rootScope;
        this.p2pMessaging = p2pMessaging;
        this.$mdToast = $mdToast;
        this.contactService = contactService;
        this.contacts = [];
        this.needRefreshed = false;
        this.refresh = utils.debounce(function () { return _this.refreshContacts(); }, 1000);
        heat.subscriber.unconfirmedTransaction({ recipient: this.user.account }, function () { _this.refresh(); });
        var interval = $interval(function () {
            if (_this.needRefreshed) {
                _this.needRefreshed = false;
                _this.refresh();
            }
        }, 2 * 1000);
        $scope.$on('$destroy', function () { return $interval.cancel(interval); });
        this.store = storage.namespace('contacts.latestTimestamp', $scope);
        this.store.on(Store.EVENT_PUT, this.refresh);
        this.p2pMessaging.seenP2PMessageTimestampStore.on(Store.EVENT_PUT, function (key) {
            if (key.indexOf("_last-message-time") > -1)
                return;
            _this.needRefreshed = true;
        });
        var contactListener = function (fullKey) {
            var contactKey = fullKey.substr(fullKey.lastIndexOf('.') + 1);
            var contact = _this.p2pMessaging.p2pContactStore.get(contactKey);
            if (contact && contact.activityTimestamp) {
                if (contact.activityTimestamp < 0) {
                    contact.activityTimestamp = -contact.activityTimestamp;
                    _this.$location.path("/messenger/".concat(contact.publicKey));
                }
                _this.refresh();
            }
        };
        this.p2pMessaging.p2pContactStore.on(Store.EVENT_PUT, contactListener);
        if (user.unlocked) {
            this.init();
        }
        else {
            var listener_1 = function () { _this.init(); };
            user.on(UserService.EVENT_UNLOCKED, listener_1);
            $scope.$on('$destroy', function () { return user.removeListener(UserService.EVENT_UNLOCKED, listener_1); });
        }
        $rootScope.$on('$locationChangeSuccess', function () { _this.updateActivePublicKey(); });
        this.updateActivePublicKey();
        var messageListener = function (msg, room) {
            for (var _i = 0, _a = _this.contacts; _i < _a.length; _i++) {
                var contact = _a[_i];
                if (_this.contactService.contactHasUnreadP2PMessage(contact)) {
                    _this.refreshContacts();
                    return;
                }
            }
        };
        this.p2pMessaging.on(P2PMessaging.EVENT_NEW_MESSAGE, messageListener);
        var channelListener = function (room, peerId) {
            _this.refresh();
        };
        this.p2pMessaging.on(P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL, channelListener);
        this.p2pMessaging.on(P2PMessaging.EVENT_ON_CLOSE_DATA_CHANNEL, channelListener);
        $scope.$on('$destroy', function () {
            _this.p2pMessaging.removeListener(P2PMessaging.EVENT_NEW_MESSAGE, messageListener);
            _this.p2pMessaging.seenP2PMessageTimestampStore.removeListener(Store.EVENT_PUT, _this.refresh);
            _this.p2pMessaging.p2pContactStore.removeListener(Store.EVENT_PUT, contactListener);
            _this.p2pMessaging.removeListener(P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL, channelListener);
            _this.p2pMessaging.removeListener(P2PMessaging.EVENT_ON_CLOSE_DATA_CHANNEL, channelListener);
        });
    }
    UserContactsComponent.prototype.acceptNewContact = function (contact) {
        delete contact.newIncomingContact;
        this.p2pMessaging.p2pContactStore.put(contact.account, contact);
    };
    UserContactsComponent.prototype.remove = function (contact) {
        var _this = this;
        dialogs.confirm("Remove contact ".concat(contact.publicName || contact.privateName || contact.account), "Do you want to remove the contact ".concat(contact.publicName || contact.privateName || contact.account)).then(function () {
            _this.$scope.$evalAsync(function () {
                var pr = _this.getPeerAndRoom(contact);
                if (pr.peer)
                    pr.peer.closeConnection();
                if (pr.room)
                    pr.room.getMessageHistory().clear();
                _this.p2pMessaging.p2pContactStore.remove(contact.account);
                _this.refreshContacts().then(function (v) { return _this.updateActivePublicKey(true); });
            });
        });
    };
    UserContactsComponent.prototype.purgeMessages = function (contact) {
        var _this = this;
        if (!contact) {
            this.$mdToast.show(this.$mdToast.simple().textContent("Select contact first please").hideDelay(5000));
            return;
        }
        dialogs.confirm("Contact ".concat(contact.publicName || contact.privateName || contact.account), "Do you want to purge the contact's messages in local storage?").then(function () {
            _this.$scope.$evalAsync(function () {
                _this.purgeMessagesInternal(contact);
                _this.refreshMessageHistory();
            });
        });
    };
    UserContactsComponent.prototype.purgeAllMessages = function () {
        var _this = this;
        dialogs.confirm("Purge all messages of all contacts", "Do you want to purge all messages in local storage?").then(function () {
            _this.$scope.$evalAsync(function () {
                _this.contacts.forEach(function (contact) {
                    _this.purgeMessagesInternal(contact);
                });
                _this.refreshMessageHistory();
            });
        });
    };
    UserContactsComponent.prototype.purgeMessagesInternal = function (contact) {
        var _this = this;
        var pr = this.getPeerAndRoom(contact);
        if (pr.room) {
            var mh_1 = pr.room.getMessageHistory();
            mh_1.getPageIndexes().forEach(function (page) {
                mh_1.getItems(page).forEach(function (v) {
                    _this.p2pMessaging.checkToRemoveServerMessage(v.type, v["outgoing"], v.transport, v.msgId, v.extraInfo);
                });
            });
            pr.room.getMessageHistory().clear();
        }
    };
    UserContactsComponent.prototype.getActivePublicKeyParam = function () {
        var path = this.$location.path().replace(/^\//, '').split('/'), route = path[0], params = path.slice(1);
        var result = (route == "messenger") ? params[0] : null;
        return result == "0" ? null : result;
    };
    UserContactsComponent.prototype.updateActivePublicKey = function (reset) {
        var _this = this;
        if (reset)
            this.$location.path("/messenger/0");
        this.activePublicKey = this.getActivePublicKeyParam();
        if (this.activePublicKey) {
            this.user["activeMessengerContact"] = this.activePublicKey;
        }
        else {
            this.activePublicKey = this.user["activeMessengerContact"];
            if (this.activePublicKey) {
                this.$location.path("/messenger/".concat(this.activePublicKey));
            }
        }
        if (!this.activePublicKey || this.activePublicKey == "0") {
            if (this.contacts[0] && this.contacts[0].publicKey != "0") {
                this.$location.path("/messenger/".concat(this.contacts[0].publicKey));
            }
        }
        if (this.activePublicKey && this.activePublicKey != "0") {
            var room = this.p2pMessaging.enterRoom(this.activePublicKey);
        }
        var activeContact = this.contacts.find(function (contact) { return contact.publicKey == _this.activePublicKey; });
        if (activeContact) {
            activeContact["hasUnreadP2PMessage"] = false;
        }
    };
    UserContactsComponent.prototype.getActiveContact = function () {
        var _this = this;
        return this.contacts.find(function (contact) { return contact.publicKey == _this.activePublicKey; });
    };
    UserContactsComponent.prototype.init = function () {
        var _this = this;
        setTimeout(function () { return _this.refreshContacts(); }, 300);
    };
    UserContactsComponent.prototype.refreshContacts = function () {
        var _this = this;
        return this.contactService.getContacts(this.activePublicKey).then(function (contacts) {
            _this.contacts = contacts;
            if (_this.getActivePublicKeyParam() == "0")
                _this.updateActivePublicKey();
        });
    };
    UserContactsComponent.prototype.refreshMessageHistory = function () {
        var _this = this;
        var contact = this.getActiveContact();
        if (contact == this.contacts[0]) {
            if (this.contacts.length > 1) {
                this.$location.path("/messenger/" + this.contacts[1].publicKey);
            }
            this.updateActivePublicKey(false);
        }
        else {
            this.updateActivePublicKey(true);
        }
        setTimeout(function () {
            _this.$location.path("/messenger/".concat(contact.publicKey));
        }, 100);
    };
    UserContactsComponent.prototype.p2pStatus = function (contact) {
        var pr = this.getPeerAndRoom(contact);
        if (pr.peer && pr.peer.isConnected()) {
            return "channelOpened";
        }
        else {
            if (pr.room && pr.room.state.entered != "not") {
                return "roomRegistered";
            }
        }
    };
    UserContactsComponent.prototype.getPeerAndRoom = function (contact) {
        if (!contact.publicKey)
            return {};
        var room = this.p2pMessaging.getOneToOneRoom(contact.publicKey);
        return room ? { room: room, peer: room.getPeer(contact.publicKey) } : {};
    };
    UserContactsComponent = __decorate([
        Component({
            selector: 'userContacts',
            styles: ["\n    .new-incoming-contact {\n      color: lightblue !important;\n      font-size: smaller;\n      margin-right: 5px;\n    }\n    .contact-control {\n      color: lightblue !important;\n      font-size: smaller;\n      cursor: pointer;\n      margin-left: 5px;\n      text-decoration: underline;\n    }\n    .unread-symbol {\n      font-size: 22px;\n      color: #ff3301;\n      margin: 0 6px -6px 0;\n    }\n    .p2p-unread-symbol {\n      font-size: 22px;\n      color: green;\n      margin: 0 6px -6px 0;\n    }\n    @keyframes blinker {\n      80% {opacity: 0.5;}\n    }\n    .channelopened-status-symbol {\n      font-size: 22px;\n      color: green;\n      margin: 0 6px 4px 0;\n    }\n    .roomregistered-status-symbol {\n      font-size: 22px;\n      color: skyblue;\n      margin: 0 6px 4px 0;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill>\n\n      <md-list flex layout=\"column\">\n        <md-list-item ng-repeat=\"contact in vm.contacts\" aria-label=\"Entry\">\n          <!--<div class=\"truncate-col unread-col left\">\n            <md-icon md-font-library=\"material-icons\" ng-class=\"{'has-unread-message': contact.hasUnreadMessage}\">fiber_manual_record</md-icon>\n          </div>-->\n          <span ng-if=\"contact.hasUnreadMessage\" class=\"unread-symbol\">*</span>\n          <span ng-if=\"contact.hasUnreadP2PMessage\" class=\"p2p-unread-symbol\">*</span>\n          <span ng-if=\"vm.p2pStatus(contact)=='channelOpened'\" class=\"channelopened-status-symbol\">\u25CF</span>\n          <span ng-if=\"vm.p2pStatus(contact)=='roomRegistered' && vm.p2pMessaging.onlineStatus == 'online'\"\n                class=\"roomregistered-status-symbol\">\u25CF</span>\n          <span ng-if=\"contact.newIncomingContact\" class=\"new-incoming-contact\">new</span>\n          <div class=\"account-col left\">\n            <a href=\"#/messenger/{{contact.publicKey}}\" ng-class=\"{'active':contact.publicKey==vm.activePublicKey}\">{{contact.publicName || contact.account}}</a>\n          </div>\n\n          <a class=\"contact-control\" ng-if=\"contact.newIncomingContact\" ng-click=\"vm.acceptNewContact(contact)\">Accept</a>\n<!--          <a class=\"contact-control\" ng-if=\"contact.newIncomingContact && contact.isP2POnlyContact\" ng-click=\"vm.remove(contact)\">Remove</a>-->\n          <a class=\"contact-control\" ng-if=\"contact.isP2POnlyContact\" ng-click=\"vm.remove(contact)\">Remove</a>\n        </md-list-item>\n      </md-list>\n\n      <md-menu class=\"right\" style=\"margin-left: -40px; margin-bottom: -10px\"\n            ng-if=\"vm.p2pMessaging.onlineStatus == 'online'\">\n        <md-button aria-label=\"Contact menu\" ng-click=\"$mdMenu.open($event)\">\n          <i><img style=\"width: 15px\" src=\"assets/sandwich.png\"></i>\n          <md-tooltip md-direction=\"top\">Contact Control</md-tooltip>\n        </md-button>\n        <md-menu-content width=\"1\">\n          <div style=\"height: 9px;color: black;margin: 3px 5px 14px 5px;font-weight: bold;\">\n              Contact \"{{vm.getActiveContact().publicName || vm.getActiveContact().account}}\"\n          </div>\n          <md-menu-item>\n            <md-button ng-click=\"vm.purgeMessages(vm.getActiveContact())\">\n              Purge messages\n            </md-button>\n          </md-menu-item>\n          <md-menu-item>\n            <md-button ng-click=\"vm.purgeAllMessages()\">\n              Purge messages of all contacts\n            </md-button>\n          </md-menu-item>\n        </md-menu-content>\n      </md-menu>\n\n    </div>\n  "
        }),
        Inject('$scope', 'user', 'heat', '$q', '$interval', '$timeout', '$location', '$rootScope', 'storage', 'P2PMessaging', '$mdToast', 'contactService'),
        __metadata("design:paramtypes", [Object, UserService,
            HeatService, Function, Function, Function, Object, Object, StorageService,
            P2PMessaging, Object, ContactService])
    ], UserContactsComponent);
    return UserContactsComponent;
}());
heat.Loader.directive("virtualRepeatFlexHelper", function () {
    return {
        restrict: 'A',
        require: '^mdVirtualRepeatContainer',
        link: function (scope, element, attributes, mdVirtualRepeatContainer) {
            var delay = 100;
            var maxDuration = 10 * 1000;
            var maxTries = maxDuration / delay;
            var tries = 0;
            var destroyed = false;
            scope.$on('$destroy', function () { destroyed = true; });
            utils.repeatWhile(100, function () {
                if (destroyed || (tries++) > maxTries)
                    return false;
                if (mdVirtualRepeatContainer.size > 0)
                    return true;
                mdVirtualRepeatContainer.updateSize();
                return false;
            });
        }
    };
});
var VirtualRepeatComponent = (function () {
    function VirtualRepeatComponent($scope, $q) {
        this.$scope = $scope;
        this.$q = $q;
        this.PAGE_SIZE = 20;
        this.loadedPages = {
            dirty: true,
            inProgress: false
        };
        this.numItems = -1;
        this.topIndex = 0;
        this.selected = null;
        this.loading = true;
        this.cachedItems = false;
    }
    VirtualRepeatComponent.prototype.initializeVirtualRepeat = function (provider, decorator, preprocessor) {
        this.provider = provider;
        this.decorator = decorator;
        this.preprocessor = preprocessor;
        this.fetchPageDebounced = utils.debounce(this.fetchPage, 300);
        return this.determineLength();
    };
    VirtualRepeatComponent.prototype.getItemAtIndex = function (index) {
        var _this = this;
        var pageNumber = Math.floor(index / this.PAGE_SIZE);
        var item;
        var page = this.loadedPages[pageNumber];
        if (page) {
            item = page[index % this.PAGE_SIZE];
            if (!this.selected) {
                this.selected = item;
            }
        }
        if (!page || this.loadedPages.dirty) {
            if (!this.loadedPages.inProgress) {
                setTimeout(function () { return _this.fetchPageDebounced(pageNumber, _this.loadedPages.dirty); }, 200);
                this.loadedPages.inProgress = true;
                this.loadedPages.dirty = false;
            }
        }
        return item;
    };
    VirtualRepeatComponent.prototype.getLength = function () {
        if (!this.cache || this.numItems != -1)
            return this.numItems;
        var n = this.cache.get("numItems");
        return n || this.numItems;
    };
    VirtualRepeatComponent.prototype.determineLength = function (retain) {
        var _this = this;
        var deferred = this.$q.defer();
        if (this.provider) {
            this.loadedPages.dirty = true;
            this.provider.getPaginatedLength().then(function (length) {
                var _a;
                _this.numItems = length;
                (_a = _this.cache) === null || _a === void 0 ? void 0 : _a.put("numItems", length);
                if (length == 0) {
                    _this.$scope.$evalAsync(function () { _this.loading = false; });
                }
                deferred.resolve(length);
            }, deferred.reject);
        }
        else {
            deferred.reject();
        }
        return deferred.promise;
    };
    VirtualRepeatComponent.prototype.fetchPage = function (pageNumber, reset) {
        var _this = this;
        this.loadedPages.inProgress = true;
        var firstIndex = pageNumber * this.PAGE_SIZE;
        var lastIndex = firstIndex + this.PAGE_SIZE;
        var processItems = function (items) {
            _this.$scope.$evalAsync(function () { _this.loading = false; });
            if (_this.preprocessor) {
                if (angular.isArray(items)) {
                    _this.preprocessor(firstIndex, lastIndex, items);
                }
            }
            if (_this.decorator) {
                if (angular.isArray(items)) {
                    items.forEach(function (item) { _this.decorator(item, _this.loadedPages); });
                }
            }
            if (reset) {
                _this.loadedPages = { dirty: false, inProgress: false };
            }
            _this.loadedPages[pageNumber] = items;
            _this.loadedPages.inProgress = false;
        };
        this.provider.getPaginatedResults(firstIndex, lastIndex).then(function (items) {
            var _a;
            _this.cachedItems = false;
            processItems(items);
            (_a = _this.cache) === null || _a === void 0 ? void 0 : _a.put(pageNumber, items);
        }, function (reason) {
            var _a;
            console.warn("fetching eth transactions error " + (reason ? JSON.stringify(reason) : ""));
            var items = (_a = _this.cache) === null || _a === void 0 ? void 0 : _a.get(pageNumber);
            _this.cachedItems = true;
            processItems(items);
        });
    };
    VirtualRepeatComponent.prototype.select = function (item) {
        this.selected = item;
        this.onSelect(item);
    };
    return VirtualRepeatComponent;
}());
var VirtualRepeatArdrTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatArdrTransactionsComponent, _super);
    function VirtualRepeatArdrTransactionsComponent($scope, $q, ardorTransactionsProviderFactory, settings, ardorPendingTransactions, user, ardorBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.ardorTransactionsProviderFactory = ardorTransactionsProviderFactory;
        _this.settings = settings;
        _this.ardorPendingTransactions = ardorPendingTransactions;
        _this.user = user;
        _this.ardorBlockExplorerService = ardorBlockExplorerService;
        return _this;
    }
    VirtualRepeatArdrTransactionsComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var secretPhrase = this.user.currency.secretPhrase;
        this.initializeVirtualRepeat(this.ardorTransactionsProviderFactory.createProvider(this.account), function (transaction) {
            transaction.amount = transaction.amountNQT / 100000000;
            var date = utils.ardorTimestampToDate(transaction.timestamp);
            transaction.dateTime = dateFormat(date, format);
            transaction.from = transaction.senderRS;
            transaction.to = transaction.recipientRS;
            transaction.txid = transaction.transaction;
            transaction.message = '';
            if (transaction.attachment.encryptedMessage) {
                if (transaction.senderPublicKey !== _this.user.publicKey)
                    transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, transaction.senderPublicKey, secretPhrase);
                else {
                    try {
                        var recipientPublicKey_1;
                        _this.ardorBlockExplorerService.getPublicKeyFromAddress(transaction.recipientRS).then(function (_publicKey) {
                            recipientPublicKey_1 = _publicKey;
                            transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, recipientPublicKey_1, secretPhrase);
                            transaction.json.message = transaction.message;
                        });
                    }
                    catch (e) {
                        transaction.message = '';
                    }
                }
            }
            transaction.json = {
                txid: transaction.transaction,
                time: transaction.dateTime,
                from: transaction.from,
                to: transaction.to,
                amount: transaction.amount,
                block: transaction.height,
                confirmations: transaction.confirmations,
                fee: transaction.feeNQT / 100000000
            };
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = this.determineLength.bind(this);
        this.PAGE_SIZE = 10;
        this.ardorPendingTransactions.addListener(listener);
        this.$scope.$on('$destroy', function () {
            _this.ardorPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
    };
    VirtualRepeatArdrTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatArdrTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatArdrTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatArdorTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col\">Amount</div>\n\n          <!-- MESSAGE -->\n          <div class=\"truncate-col message-col left\">Message</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\" >\n              <span>{{item.txid}}</span>\n            </div>\n\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n             <span>{{item.from}}</span>\n            </div>\n\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span>{{item.to}}</span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col\">\n              <span>{{item.amount}}</span>\n            </div>\n\n            <!-- MESSAGE -->\n            <div class=\"truncate-col message-col left\">\n              <span>{{item.message}}</span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'ardorTransactionsProviderFactory', 'settings', 'ardorPendingTransactions', 'user', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Function, ArdorTransactionsProviderFactory,
            SettingsService,
            ArdorPendingTransactionsService,
            UserService,
            ArdorBlockExplorerService])
    ], VirtualRepeatArdrTransactionsComponent);
    return VirtualRepeatArdrTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatBchTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatBchTransactionsComponent, _super);
    function VirtualRepeatBchTransactionsComponent($scope, $q, bchTransactionsProviderFactory, settings, bchPendingTransactions, user) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.bchTransactionsProviderFactory = bchTransactionsProviderFactory;
        _this.settings = settings;
        _this.bchPendingTransactions = bchPendingTransactions;
        _this.user = user;
        return _this;
    }
    VirtualRepeatBchTransactionsComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        this.initializeVirtualRepeat(this.bchTransactionsProviderFactory.createProvider(this.account), function (transaction) {
            transaction.txid = transaction.txid;
            transaction.dateTime = dateFormat(new Date(transaction.blockTime * 1000), format);
            transaction.from = transaction.vin[0].addresses[0];
            transaction.amount = transaction.vout[0].value / 100000000;
            var totalInputs = 0;
            var inputs = '';
            for (var i = 0; i < transaction.vin.length; i++) {
                totalInputs += parseFloat(transaction.vin[i].value);
                inputs += "\n          ".concat(transaction.vin[i].addresses[0], " (").concat((parseFloat(transaction.vin[i].value) / 100000000).toFixed(8), ")");
            }
            var totalOutputs = 0;
            var outputs = '';
            for (var i = 0; i < transaction.vout.length; i++) {
                totalOutputs += parseFloat(transaction.vout[i].value);
                outputs += "\n          ".concat(transaction.vout[i].addresses[0], " (").concat((parseFloat(transaction.vout[i].value) / 100000000).toFixed(8), ")");
            }
            for (var i = 0; i < transaction.vout.length && transaction.vout[i].addresses; i++) {
                if (transaction.vout[i].addresses) {
                    transaction.to = transaction.vout[0].addresses[0];
                    break;
                }
            }
            if (transaction.from === transaction.to) {
                for (var i = 1; i < transaction.vout.length && transaction.vout[i].addresses; i++) {
                    transaction.to = transaction.vout[i].addresses[0];
                    transaction.amount = transaction.vout[i].value / 100000000;
                    break;
                }
            }
            if (inputs.includes(_this.account)) {
                transaction.amount = "-".concat(transaction.amount);
            }
            else {
                for (var i = 0; i < transaction.vout.length; i++) {
                    if (transaction.vout[i].addresses && transaction.vout[i].addresses[0] === _this.account) {
                        transaction.to = _this.account;
                        transaction.amount = transaction.vout[i].value / 100000000;
                    }
                }
            }
            if (!outputs.includes(_this.account) && transaction.vout.length > 1) {
                transaction.to = 'Multiple Outputs';
            }
            transaction.json = {
                txid: transaction.txid,
                time: transaction.dateTime,
                block: transaction.blockHeight,
                totalInputs: totalInputs,
                totalOutputs: totalOutputs,
                confirmations: transaction.confirmations,
                fees: transaction.fees / 100000000,
                inputs: inputs.trim(),
                outputs: outputs.trim()
            };
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = this.determineLength.bind(this);
        this.PAGE_SIZE = 10;
        this.bchPendingTransactions.addListener(listener);
        this.$scope.$on('$destroy', function () {
            _this.bchPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
    };
    VirtualRepeatBchTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatBchTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatBchTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatBchTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col right\">Amount</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\" >\n              <span>\n                <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://bch1.heatwallet.com/tx/{{item.txid}}\">{{item.txid}}</a>\n              </span>\n            </div>\n\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n              <span ng-show = \"item.from !== 'Multiple Inputs'\">{{item.from}}</span>\n              <a ng-show = \"item.from === 'Multiple Inputs'\" ng-click=\"vm.jsonDetails($event, item.json)\">{{item.from}}</a>\n            </div>\n\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span ng-show = \"item.to !== 'Multiple Outputs'\">{{item.to}}</span>\n              <a ng-show = \"item.to === 'Multiple Outputs'\" ng-click=\"vm.jsonDetails($event, item.json)\">{{item.to}}</a>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col right\">\n              <span>{{item.amount}}</span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'bchTransactionsProviderFactory', 'settings', 'bchPendingTransactions', 'user', 'bitcoinMessagesService'),
        __metadata("design:paramtypes", [Object, Function, BchTransactionsProviderFactory,
            SettingsService,
            BchPendingTransactionsService,
            UserService])
    ], VirtualRepeatBchTransactionsComponent);
    return VirtualRepeatBchTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatBtcTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatBtcTransactionsComponent, _super);
    function VirtualRepeatBtcTransactionsComponent($scope, $q, btcTransactionsProviderFactory, settings, bitcoinPendingTransactions, user, storage) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.btcTransactionsProviderFactory = btcTransactionsProviderFactory;
        _this.settings = settings;
        _this.bitcoinPendingTransactions = bitcoinPendingTransactions;
        _this.user = user;
        _this.storage = storage;
        var store = storage.namespace('currency-cache-btc', _this.$scope, true);
        _this.cache = {
            get: function (key) { return store.get(_this.user.currency.address + "-" + key); },
            put: function (key, value) { return store.put(_this.user.currency.address + "-" + key, value); },
        };
        return _this;
    }
    VirtualRepeatBtcTransactionsComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        this.initializeVirtualRepeat(this.btcTransactionsProviderFactory.createProvider(this.account), function (transaction) {
            transaction.amount = transaction.vout[0].value;
            transaction.dateTime = dateFormat(new Date(transaction.time * 1000), format);
            transaction.from = transaction.vin[0].addr;
            var totalInputs = 0;
            var inputs = '';
            for (var i = 0; i < transaction.vin.length; i++) {
                totalInputs += parseFloat(transaction.vin[i].value);
                inputs += "\n          ".concat(transaction.vin[i].addr, " (").concat(transaction.vin[i].value, ")");
                if (transaction.vin[i].addr === _this.account) {
                    transaction.from = transaction.vin[i].addr;
                }
            }
            var totalOutputs = 0;
            var outputs = '';
            for (var i = 0; i < transaction.vout.length; i++) {
                totalOutputs += parseFloat(transaction.vout[i].value);
                if (transaction.vout[i].scriptPubKey.addresses) {
                    outputs += "\n            ".concat(transaction.vout[i].scriptPubKey.addresses[0], " (").concat(transaction.vout[i].value, ")");
                }
            }
            for (var i = 0; i < transaction.vout.length && transaction.vout[i].scriptPubKey.addresses; i++) {
                if (transaction.vout[i].scriptPubKey.addresses) {
                    transaction.to = transaction.vout[0].scriptPubKey.addresses[0];
                    break;
                }
            }
            if (transaction.from === transaction.to) {
                for (var i = 1; i < transaction.vout.length && transaction.vout[i].scriptPubKey.addresses; i++) {
                    transaction.to = transaction.vout[i].scriptPubKey.addresses[0];
                    transaction.amount = transaction.vout[i].value;
                    break;
                }
            }
            if (inputs.includes(_this.account)) {
                var totalOut = 0;
                for (var i = 0; i < transaction.vout.length; i++) {
                    var addresses = transaction.vout[i].scriptPubKey.addresses;
                    if (addresses && addresses[0] !== _this.account) {
                        totalOut = totalOut + parseFloat(transaction.vout[i].value);
                    }
                }
                transaction.amount = "-".concat(totalOut);
            }
            else {
                for (var i = 0; i < transaction.vout.length; i++) {
                    if (transaction.vout[i].scriptPubKey.addresses && transaction.vout[i].scriptPubKey.addresses[0] === _this.account) {
                        transaction.to = _this.account;
                        transaction.amount = transaction.vout[i].value;
                        break;
                    }
                }
            }
            if (!outputs.includes(_this.account) && transaction.vout.length > 1) {
                transaction.to = 'Multiple Outputs';
            }
            if (transaction.message === undefined) {
                wlt.loadPaymentMessage(transaction.txid)
                    .then(function (v) { return transaction.message = v; })
                    .catch(function (reason) { return console.warn("payment message is not loaded: " + JSON.stringify(reason)); });
            }
            transaction.json = {
                txid: transaction.txid,
                time: transaction.dateTime,
                block: transaction.blockheight,
                totalInputs: totalInputs,
                totalOutputs: totalOutputs,
                confirmations: transaction.confirmations,
                fees: transaction.fees,
                inputs: inputs.trim(),
                outputs: outputs.trim(),
                size: transaction.size,
                message: transaction.message || ''
            };
        }).catch(function (reason) {
            return console.warn("initialization btc list component error " + (reason ? JSON.stringify(reason) : ""));
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = this.determineLength.bind(this);
        this.PAGE_SIZE = 10;
        this.bitcoinPendingTransactions.addListener(listener);
        this.$scope.$on('$destroy', function () {
            _this.bitcoinPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
    };
    VirtualRepeatBtcTransactionsComponent.prototype.jsonDetails = function ($event, jsonObject, detailedObject) {
        var fields = [["txid", "id"], ["dateTime", "time"], ["blockheight", "block height"], ["from"], ["to"], ["amount"]];
        dialogs.jsonDetails($event, jsonObject, 'Transaction: ' + jsonObject.txid, fields, detailedObject);
    };
    VirtualRepeatBtcTransactionsComponent.prototype.paymentMemoDialog = function ($event, item) {
        var _this = this;
        var heatService = heat.$inject.get('heat');
        wlt.getHeatUnavailableReason(heatService, this.user.account)
            .then(function (heatUnavailableReason) { return wlt.paymentMemoDialog(item.txid, heatUnavailableReason); })
            .then(function (value) {
            var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
            setTimeout(refresh, 2 * 1000);
        })
            .catch(function (reason) {
            if (reason)
                console.error(reason);
        });
    };
    VirtualRepeatBtcTransactionsComponent.prototype.onSelect = function (selectedTransaction) {
    };
    VirtualRepeatBtcTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatBtcTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">\n        Latest Transactions\n        <span ng-if=\"vm.cachedItems\" style=\"opacity: 0.8; color: darkorange\">&nbsp;&nbsp; (cached)</span>\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n          <!-- FROM -->\n          <div class=\"truncate-col message-col left\">FROM</div>\n          <!-- TO -->\n          <div class=\"truncate-col message-col left\">TO</div>\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col right\">Amount</div>\n          <!-- MEMO -->\n          <div class=\"truncate-col message-col left\">Memo</div>\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\" >\n              <span ng-if=\"item.blockheight == -1\">[unconfirmed]</span>\n              <span>\n                <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://live.blockcypher.com/btc/tx/{{item.txid}}\">{{item.txid}}</a>\n              </span>\n            </div>\n            <!-- FROM -->\n            <div class=\"truncate-col message-col left\">\n             <span>{{item.from}}</span>\n            </div>\n            <!-- TO -->\n            <div class=\"truncate-col message-col left\">\n              <span>{{item.to}}</span>\n            </div>\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col right\">\n              <span>{{item.amount}}</span>\n            </div>\n            <!-- MEMO -->\n            <div ng-if=\"item.message\" class=\"truncate-col message-col left\" flex>\n                <span style=\"opacity: 0.5\">[{{item.message.method == 0 ? \"local\" : \"HEAT\"}}]</span> \n                {{item.message.text}}\n                <md-tooltip md-delay=\"800\">{{item.message.text}}</md-tooltip>\n            </div>\n            <span ng-if=\"!item.message\" class=\"truncate-col message-col left\">\n              <a href=\"javascript:void(0);\" ng-click=\"vm.paymentMemoDialog($event, item)\">create</a>\n            </span>\n            \n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'btcTransactionsProviderFactory', 'settings', 'bitcoinPendingTransactions', 'user', 'storage'),
        __metadata("design:paramtypes", [Object, Function, BtcTransactionsProviderFactory,
            SettingsService,
            BitcoinPendingTransactionsService,
            UserService,
            StorageService])
    ], VirtualRepeatBtcTransactionsComponent);
    return VirtualRepeatBtcTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatEthTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatEthTransactionsComponent, _super);
    function VirtualRepeatEthTransactionsComponent($scope, $q, ethTransactionsProviderFactory, settings, user, render, $mdPanel, controlCharRender, web3, ethereumPendingTransactions, storage, http) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.ethTransactionsProviderFactory = ethTransactionsProviderFactory;
        _this.settings = settings;
        _this.user = user;
        _this.render = render;
        _this.$mdPanel = $mdPanel;
        _this.controlCharRender = controlCharRender;
        _this.web3 = web3;
        _this.ethereumPendingTransactions = ethereumPendingTransactions;
        _this.storage = storage;
        _this.http = http;
        _this.renderer = new EthTransactionRenderer(_this);
        var store = storage.namespace('currency-cache-eth', _this.$scope, true);
        _this.cache = {
            get: function (key) { return store.get(_this.user.currency.address + "-" + key); },
            put: function (key, value) { return store.put(_this.user.currency.address + "-" + key, value); },
        };
        return _this;
    }
    VirtualRepeatEthTransactionsComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        this.initializeVirtualRepeat(this.ethTransactionsProviderFactory.createProvider(this.account), function (transaction) {
            var date = new Date(0);
            date.setUTCSeconds(transaction.timestamp);
            transaction['time'] = dateFormat(date, format);
            transaction['heightDisplay'] = 'no height';
            if (_this.personalize) {
                transaction['outgoing'] = _this.user.currency.address.toUpperCase() == transaction.from.toUpperCase();
                var amountVal = _this.renderer.renderAmount(transaction);
                transaction['renderedAmount'] = amountVal;
                transaction['renderedToFrom'] = _this.renderer.renderedToFrom(transaction);
            }
            var renderedInfo = _this.renderer.renderInfo(transaction);
            if (angular.isString(renderedInfo)) {
                transaction['renderedInfo'] = renderedInfo;
            }
            else if (angular.isObject(renderedInfo)) {
                renderedInfo.then(function (text) {
                    transaction['renderedInfo'] = text;
                });
            }
            if (transaction['message'] === undefined) {
                wlt.loadPaymentMessage(transaction.hash)
                    .then(function (v) { return transaction['message'] = v; })
                    .catch(function (reason) { return console.warn("payment message is not loaded: " + JSON.stringify(reason)); });
            }
        }).catch(function (reason) { return console.warn("initialization eth list component error " + (reason ? JSON.stringify(reason) : "")); });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = this.determineLength.bind(this);
        this.ethereumPendingTransactions.addListener(listener);
        this.$scope.$on('$destroy', function () {
            _this.ethereumPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
    };
    VirtualRepeatEthTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        var fields = [["txid", "id"], ["time"], ["blockHeight", "block height"], ["from"], ["to"], ["renderedAmount", "amount"]];
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid, fields);
    };
    VirtualRepeatEthTransactionsComponent.prototype.txnDetails = function ($event, item) {
        this.http.get("https://eth1.heatwallet.com/api/v2/tx/" + item.hash).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed) {
                var fields = [["txid", "id"], ["blockTime", "block time"], ["blockHeight", "block height"], ["value"], ["fees"]];
                dialogs.jsonDetails($event, parsed, 'Transaction: ' + parsed.txid + "...", fields, null, true);
            }
        }).catch(function (reason) {
            if (reason)
                console.error(reason);
        });
    };
    VirtualRepeatEthTransactionsComponent.prototype.addressDetails = function ($event, address) {
        this.http.get("https://eth1.heatwallet.com/api/v2/address/" + address).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed) {
                parsed.renderedAmount = (parsed.balance || 0) / 1000000000000000000 + " ETH";
                var fields = [["address"], ["renderedAmount", "balance"], ["txs", "number of transactions"], ["nonce"]];
                dialogs.jsonDetails(null, parsed, 'Address: ' + parsed.address, fields, null, true);
            }
        }).catch(function (reason) {
            if (reason)
                console.error(reason);
        });
    };
    VirtualRepeatEthTransactionsComponent.prototype.paymentMemoDialog = function ($event, item) {
        var _this = this;
        var heatService = heat.$inject.get('heat');
        wlt.getHeatUnavailableReason(heatService, this.user.account)
            .then(function (heatUnavailableReason) { return wlt.paymentMemoDialog(item.txid, heatUnavailableReason); })
            .then(function (value) {
            var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
            setTimeout(refresh, 2 * 1000);
        })
            .catch(function (reason) {
            if (reason)
                console.error(reason);
        });
    };
    VirtualRepeatEthTransactionsComponent.prototype.imageUrl = function (contractAddress) {
        return "https://raw.githubusercontent.com/dmdeklerk/tokens/master/images/".concat(contractAddress, ".png");
    };
    VirtualRepeatEthTransactionsComponent.prototype.renderSync = function (transaction) {
        try {
            if (transaction['erc20']) {
                return JSON.stringify(transaction['erc20']);
            }
            return this.web3.parseInput(transaction.input);
        }
        catch (e) {
            console.log(e);
        }
    };
    VirtualRepeatEthTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatEthTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatEthTransactions',
            inputs: ['account', 'personalize'],
            styles: ["\n    .failed {\n      color: red;\n    }\n    .pending {\n      color: coral;\n    }\n    .pointer {\n      cursor: pointer;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">\n        Latest Transactions <span ng-if=\"vm.cachedItems\" style=\"opacity: 0.8; color: darkorange\">&nbsp;&nbsp; (cached)</span>\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <!-- HEIGHT\n          <div class=\"he truncate-col height-col left\" ng-if=\"!vm.personalize\">Height</div>\n          -->\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- ID -->\n          <div class=\"truncate-col id-col left\" ng-if=\"vm.personalize || vm.account\">Id</div>\n\n          <!-- INOUT -->\n          <div class=\"truncate-col inoutgoing-col left\" ng-if=\"vm.personalize\">In/Out</div>\n\n          <!-- TRANSACTION -->\n          <!-- <div class=\"truncate-col transaction-col left\" ng-if=\"vm.personalize\">Transaction</div> -->\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col\" ng-if=\"vm.personalize\">Amount</div>\n\n          <!-- TOFROM -->\n          <div class=\"truncate-col tofrom-col left\" ng-if=\"vm.personalize\">To/From</div>\n\n          <!-- INFO -->\n          <div class=\"truncate-col info-col left\" flex>Info</div>\n\n          <!-- Memo -->\n          <div class=\"truncate-col left\" flex>Memo</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- HEIGHT\n            <div class=\"he truncate-col height-col left\" ng-if=\"!vm.personalize\">\n              <span ng-show=\"item.height!=2147483647\">{{item.heightDisplay}}</span>\n              <span>\n                <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://etherscan.io/block/{{item.heightDisplay}}\">{{item.heightDisplay}}</a>\n              </span>\n            </div>\n            -->\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.time}}</div>\n\n            <!-- ID -->\n            <div class=\"truncate-col id-col left\" ng-if=\"vm.personalize || vm.account\">\n              <a class=\"pointer\" ng-click=\"vm.txnDetails($event, item)\">{{item.hash}}</a>\n            </div>\n\n            <!-- INOUT -->\n            <div class=\"truncate-col inoutgoing-col left\" ng-if=\"vm.personalize\">\n              <md-icon md-font-library=\"material-icons\" ng-class=\"{outgoing: item.outgoing, incoming: !item.outgoing}\">\n                {{item.outgoing ? 'keyboard_arrow_up': 'keyboard_arrow_down'}}\n              </md-icon>\n            </div>\n\n            <!-- TRANSACTION -->\n            <!-- <div class=\"truncate-col transaction-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedTransactionType\"></span>\n            </div> -->\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedAmount\"></span>\n            </div>\n\n            <!-- TOFROM -->\n            <div class=\"truncate-col tofrom-col left\" ng-if=\"vm.personalize\">\n              <a class=\"pointer\" ng-click=\"vm.addressDetails($event, item.renderedToFrom)\">{{item.renderedToFrom}}</a>\n<!--              <span ng-bind-html=\"item.renderedToFrom\"></span>-->\n            </div>\n\n            <!-- INFO -->\n            <div class=\"truncate-col info-col left\" flex>\n              <span ng-bind-html=\"item.renderedInfo\"></span>\n            </div>\n\n            <!-- MEMO -->\n            <div ng-if=\"item.message\" class=\"truncate-col left\" flex>\n                <span style=\"opacity: 0.5\">[{{item.message.method == 0 ? \"local\" : \"HEAT\"}}]</span> \n                {{item.message.text}}\n                <md-tooltip md-delay=\"800\">{{item.message.text}}</md-tooltip>\n            </div>\n            <span ng-if=\"!item.message\" class=\"truncate-col left\">\n              <a class=\"pointer\" ng-click=\"vm.paymentMemoDialog($event, item)\">create</a>\n            </span>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'ethTransactionsProviderFactory', 'settings', 'user', 'render', '$mdPanel', 'controlCharRender', 'web3', 'ethereumPendingTransactions', 'storage', 'http'),
        __metadata("design:paramtypes", [Object, Function, EthTransactionsProviderFactory,
            SettingsService,
            UserService,
            RenderService, Object, ControlCharRenderService,
            Web3Service,
            EthereumPendingTransactionsService,
            StorageService,
            HttpService])
    ], VirtualRepeatEthTransactionsComponent);
    return VirtualRepeatEthTransactionsComponent;
}(VirtualRepeatComponent));
var EthTransactionRenderHelper = (function () {
    function EthTransactionRenderHelper(template, extractor) {
        this.template = template;
        this.extractor = extractor;
        this.$q = heat.$inject.get('$q');
    }
    EthTransactionRenderHelper.prototype.isPromise = function (val) {
        return angular.isObject(val) && angular.isFunction(val['then']);
    };
    EthTransactionRenderHelper.prototype.render = function (transaction) {
        var _this = this;
        var parts = this.extractor(transaction);
        var args = {};
        var promises = [];
        angular.forEach(parts, function (val, key) {
            if (_this.isPromise(val)) {
                promises.push(val);
                val.then(function (promiseVal) {
                    args[key] = promiseVal;
                });
            }
            else {
                args[key] = val;
            }
        });
        var template = angular.isFunction(this.template) ? this.template.call(null, transaction) : this.template;
        var text = (' ' + template).slice(1);
        if (promises.length > 0) {
            var deferred = this.$q.defer();
            this.$q.all(promises).then(function () {
                angular.forEach(args, function (val, key) {
                    text = text.replace(new RegExp("\\$" + key, 'g'), val);
                });
                deferred.resolve(text);
            });
            return deferred.promise;
        }
        angular.forEach(args, function (val, key) {
            text = text.replace(new RegExp("\\$" + key, 'g'), val);
        });
        return text;
    };
    return EthTransactionRenderHelper;
}());
var EthTransactionRenderer = (function () {
    function EthTransactionRenderer(provider) {
        var _this = this;
        this.provider = provider;
        this.TYPE_ETHEREUM_TRANSFER = 'eth:transfer';
        this.TYPE_ERC20_APPROVE = 'approve';
        this.TYPE_ERC20_ALLOWANCE = 'allowance';
        this.TYPE_ERC20_TRANSFER = 'transfer';
        this.TYPE_ERC20_TRANSFER_FROM = 'transferFrom';
        this.TYPE_ETHERDELTA_DEPOSIT_TOKEN = 'depositToken';
        this.TYPE_ETHERDELTA_WITHDRAWAL = 'withdraw';
        this.TYPE_ETHERDELTA_WITHDRAWAL_TOKEN = 'withdrawToken';
        this.TYPE_ETHERDELTA_ORDER = 'order';
        this.TYPE_ETHERDELTA_TRADE = 'trade';
        this.TYPE_ETHERDELTA_TRADE_BALANCES = 'tradeBalances';
        this.TYPE_ETHERDELTA_CANCEL_ORDER = 'cancelOrder';
        this.renderers = {};
        this.transactionTypes = {};
        var key;
        this.$q = heat.$inject.get('$q');
        this.ethTransactionParser = heat.$inject.get('ethTransactionParser');
        this.ethBlockExplorerService = heat.$inject.get('ethBlockExplorerService');
        key = this.TYPE_ETHEREUM_TRANSFER;
        this.transactionTypes[key] = 'TRANSFER';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>TRANSFER</b> $amount from $from to $to", function (t) {
            return {
                status: _this.status(t),
                from: _this.account(t.from),
                to: _this.account(t.to),
                amount: _this.amount(t.value)
            };
        });
        key = this.TYPE_ERC20_APPROVE;
        this.transactionTypes[key] = 'ERC20 APPROVE';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>ERC20 APPROVE</b> $from $to $spender $value", function (t) {
            return {
                status: _this.status(t),
                from: _this.account(t.from),
                to: _this.account(t.to),
                spender: _this.account(t.abi.decodedData.params[0].value),
                value: _this.amount(t.abi.decodedData.params[1].value)
            };
        });
        key = this.TYPE_ERC20_ALLOWANCE;
        this.transactionTypes[key] = 'ERC20 ALLOWANCE';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return '<b>ERC20 ALLOWANCE</b> ';
        }, function (t) {
            return {};
        });
        key = this.TYPE_ERC20_TRANSFER;
        this.transactionTypes[key] = 'ERC20 TRANSFER';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>ERC20 TRANSFER</b> Send $value $token from $from to $to", function (t) {
            return {
                status: _this.status(t),
                token: _this.token(t.to),
                from: _this.account(t.from),
                to: _this.account(t.abi.decodedData.params[0].value),
                value: _this.amount(t.abi.decodedData.params[1].value, _this.ethBlockExplorerService.tokenInfoCache[t.to])
            };
        });
        key = this.TYPE_ERC20_TRANSFER_FROM;
        this.transactionTypes[key] = 'ERC20 TRANSFER FROM';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>ERC20 TRANSFER FROM</b> $asset from $sender to $recipient amount $amount", function (t) {
            return {
                status: _this.status(t),
                asset: _this.token(t.to),
                sender: _this.account(t.abi.decodedData.params[0].value),
                recipient: _this.account(t.abi.decodedData.params[1].value),
                amount: _this.amount(t.abi.decodedData.params[2].value, _this.ethBlockExplorerService.tokenInfoCache[t.to])
            };
        });
        key = this.TYPE_ETHERDELTA_DEPOSIT_TOKEN;
        this.transactionTypes[key] = 'DELTA DEPOSIT';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>DELTA DEPOSIT</b> Deposit $amount $token", function (t) {
            return {
                status: _this.status(t),
                token: _this.token(t.abi.decodedData.params[0].value),
                amount: _this.amount(t.abi.decodedData.params[1].value)
            };
        });
        key = this.TYPE_ETHERDELTA_WITHDRAWAL;
        this.transactionTypes[key] = 'DELTA WITHDRAW';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>DELTA WITHDRAW</b> Withdraw $amount", function (t) {
            return {
                status: _this.status(t),
                amount: _this.amount(t.abi.decodedData.params[0].value)
            };
        });
        key = this.TYPE_ETHERDELTA_WITHDRAWAL_TOKEN;
        this.transactionTypes[key] = 'DELTA WITHDRAW TOKEN';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>DELTA WITHDRAW TOKEN</b> Withdraw $amount $token", function (t) {
            return {
                status: _this.status(t),
                token: _this.token(t.abi.decodedData.params[0].value),
                amount: _this.amount(t.abi.decodedData.params[1].value)
            };
        });
        key = this.TYPE_ETHERDELTA_ORDER;
        this.transactionTypes[key] = 'DELTA ORDER';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>DELTA ORDER</b> Order get $amountGet $tokenGet pay $amountGive $tokenGive", function (t) {
            return {
                status: _this.status(t),
                tokenGet: _this.token(t.abi.decodedData.params[0].value),
                amountGet: _this.amount(t.abi.decodedData.params[1].value),
                tokenGive: _this.token(t.abi.decodedData.params[2].value),
                amountGive: _this.amount(t.abi.decodedData.params[3].value),
                expires: t.abi.decodedData.params[4].value
            };
        });
        key = this.TYPE_ETHERDELTA_TRADE;
        this.transactionTypes[key] = 'DELTA TRADE';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>DELTA TRADE</b> Trade get $amountGet $tokenGet pay $amountGive $tokenGive from $user amount $amount", function (t) {
            return {
                status: _this.status(t),
                tokenGet: _this.token(t.abi.decodedData.params[0].value),
                amountGet: _this.amount(t.abi.decodedData.params[1].value),
                tokenGive: _this.token(t.abi.decodedData.params[2].value),
                amountGive: _this.amount(t.abi.decodedData.params[3].value),
                expires: t.abi.decodedData.params[4].value,
                user: _this.account(t.abi.decodedData.params[6].value),
                amount: _this.amount(t.abi.decodedData.params[10].value)
            };
        });
        key = this.TYPE_ETHERDELTA_TRADE_BALANCES;
        this.transactionTypes[key] = 'DELTA TRADE BALANCES';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>DELTA TRADE BALANCES</b> Trade balances get $amountGet $tokenGet pay $amountGive $tokenGive from $user amount $amount", function (t) {
            return {
                status: _this.status(t),
                tokenGet: _this.token(t.abi.decodedData.params[0].value),
                amountGet: _this.amount(t.abi.decodedData.params[1].value),
                tokenGive: _this.token(t.abi.decodedData.params[2].value),
                amountGive: _this.amount(t.abi.decodedData.params[3].value),
                user: _this.account(t.abi.decodedData.params[4].value),
                amount: _this.amount(t.abi.decodedData.params[5].value)
            };
        });
        key = this.TYPE_ETHERDELTA_CANCEL_ORDER;
        this.transactionTypes[key] = 'DELTA CANCEL ORDER';
        this.renderers[key] = new EthTransactionRenderHelper("$status<b>DELTA CANCEL ORDER</b> Trade get $amountGet $tokenGet pay $amountGive $tokenGive from $user amount $amount", function (t) {
            return {
                status: _this.status(t),
                tokenGet: _this.token(t.abi.decodedData.params[0].value),
                amountGet: _this.amount(t.abi.decodedData.params[1].value),
                tokenGive: _this.token(t.abi.decodedData.params[2].value),
                amountGive: _this.amount(t.abi.decodedData.params[3].value),
                expires: t.abi.decodedData.params[4].value
            };
        });
    }
    EthTransactionRenderer.prototype.renderTransactionType = function (transaction) {
        return 'txn type';
    };
    EthTransactionRenderer.prototype.renderAmount = function (transaction) {
        return this.amount(transaction.value);
    };
    EthTransactionRenderer.prototype.renderedToFrom = function (transaction) {
        return transaction.from.toUpperCase() == this.provider.account.toUpperCase()
            ? transaction.to
            : transaction.from;
    };
    EthTransactionRenderer.prototype.isOutgoing = function (transaction) {
        return transaction.from.toUpperCase() == this.provider.account.toUpperCase();
    };
    EthTransactionRenderer.prototype.renderInfo = function (transaction) {
        var key = this.TYPE_ETHEREUM_TRANSFER;
        if (transaction.abi && transaction.abi.decodedData) {
            key = transaction.abi.decodedData.name;
        }
        var renderer = this.renderers[key];
        if (renderer)
            return renderer.render(transaction);
        return "not supported ".concat(key);
    };
    EthTransactionRenderer.prototype.account = function (account) {
        if (account.toUpperCase() == this.provider.account.toUpperCase()) {
            return "<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://eth1.heatwallet.com/api/v2/address/".concat(account, "\">Myself</a>");
        }
        return "<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://eth1.heatwallet.com/api/v2/address/".concat(account, "\">").concat(account, "</a>");
    };
    EthTransactionRenderer.prototype.token = function (address) {
        var tokenInfo = this.ethBlockExplorerService.tokenInfoCache[address];
        if (tokenInfo) {
            return "<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://eth1.heatwallet.com/api/v2/address/".concat(address, "\">").concat(tokenInfo.symbol, "</a>");
        }
        return "<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://eth1.heatwallet.com/api/v2/address/".concat(address, "\">").concat(address, "</a>");
    };
    EthTransactionRenderer.prototype.amount = function (amount, tokenInfo) {
        var str;
        amount = (amount + "") || "0";
        if (tokenInfo) {
            str = utils.formatQNT(amount, tokenInfo.decimals) + ' ' + tokenInfo.symbol;
        }
        else {
            str = utils.commaFormat(amount).replace(/(\.\d*?[1-9])0+$/g, "$1") + ' ETH';
        }
        return "<span>".concat(str, "</span>");
    };
    EthTransactionRenderer.prototype.status = function (t) {
        if (t.ethereumSpecific) {
            if (t.ethereumSpecific.status == 0)
                return "<span class='failed'>[FAILED] </span>";
            if (t.ethereumSpecific.status == -1)
                return "<span class='pending'>[PENDING] </span>";
        }
        return "";
    };
    return EthTransactionRenderer;
}());
var VirtualRepeatFIMKTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatFIMKTransactionsComponent, _super);
    function VirtualRepeatFIMKTransactionsComponent($scope, $q, fimkTransactionsProviderFactory, settings, fimkPendingTransactions, user) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.fimkTransactionsProviderFactory = fimkTransactionsProviderFactory;
        _this.settings = settings;
        _this.fimkPendingTransactions = fimkPendingTransactions;
        _this.user = user;
        return _this;
    }
    VirtualRepeatFIMKTransactionsComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var secretPhrase = this.user.currency.secretPhrase;
        this.initializeVirtualRepeat(this.fimkTransactionsProviderFactory.createProvider(this.account), function (transaction) {
            transaction.amount = transaction.amountNQT / 100000000;
            var date = utils.timestampToDate(transaction.timestamp);
            transaction.dateTime = dateFormat(date, format);
            transaction.from = transaction.senderRS;
            transaction.to = transaction.recipientRS;
            transaction.txid = transaction.transaction;
            transaction.message = '';
            if (transaction.attachment.senderPublicKey) {
                if (transaction.attachment.senderPublicKey !== _this.user.publicKey)
                    transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, transaction.attachment.senderPublicKey, secretPhrase);
                else {
                    try {
                        transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, transaction.attachment.recipientPublicKey, secretPhrase);
                    }
                    catch (e) {
                        transaction.message = '';
                    }
                }
            }
            transaction.json = {
                txid: transaction.transaction,
                time: transaction.dateTime,
                from: transaction.from,
                to: transaction.to,
                amount: transaction.amount,
                block: transaction.height,
                confirmations: transaction.confirmations,
                fee: transaction.feeNQT / 100000000,
                message: transaction.message
            };
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = this.determineLength.bind(this);
        this.PAGE_SIZE = 15;
        this.fimkPendingTransactions.addListener(listener);
        this.$scope.$on('$destroy', function () {
            _this.fimkPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
    };
    VirtualRepeatFIMKTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatFIMKTransactionsComponent.prototype.onSelect = function (selectedTransaction) {
    };
    VirtualRepeatFIMKTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatFimkTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col\">Amount</div>\n\n          <!-- MESSAGE -->\n          <div class=\"truncate-col message-col left\">Message</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\" >\n              <span>{{item.txid}}</span>\n            </div>\n\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n             <span>{{item.from}}</span>\n            </div>\n\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span>{{item.to}}</span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col\">\n              <span>{{item.amount}}</span>\n            </div>\n\n            <!-- MESSAGE -->\n            <div class=\"truncate-col message-col left\">\n              <span>{{item.message}}</span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'fimkTransactionsProviderFactory', 'settings', 'fimkPendingTransactions', 'user'),
        __metadata("design:paramtypes", [Object, Function, FimkTransactionsProviderFactory,
            SettingsService,
            FimkPendingTransactionsService,
            UserService])
    ], VirtualRepeatFIMKTransactionsComponent);
    return VirtualRepeatFIMKTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatIotaTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatIotaTransactionsComponent, _super);
    function VirtualRepeatIotaTransactionsComponent($scope, $q, iotaTransactionsProviderFactory, settings, iotaPendingTransactions, user, iotaBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.iotaTransactionsProviderFactory = iotaTransactionsProviderFactory;
        _this.settings = settings;
        _this.iotaPendingTransactions = iotaPendingTransactions;
        _this.user = user;
        _this.iotaBlockExplorerService = iotaBlockExplorerService;
        return _this;
    }
    VirtualRepeatIotaTransactionsComponent.prototype.$onInit = function () {
        var _this = this;
        var myAddresses = this.iotaBlockExplorerService.getAccountInfo(this.user.currency.secretPhrase).then(function (accountInfo) {
            return accountInfo.accountData.addresses;
        }).catch(function (reason) { return console.error(reason); });
        this.initializeVirtualRepeat(this.iotaTransactionsProviderFactory.createProvider(this.user.currency.secretPhrase), function (bundle) {
            bundle.dateTime = dateFormat(new Date(bundle.timestamp * 1000), _this.settings.get(SettingsService.DATEFORMAT_DEFAULT));
            bundle.bundleId = bundle.hash;
            bundle.displayFromAddress = bundle.from ? bundle.from.substring(0, 42).concat('...') : "-";
            bundle.displayToAddress = bundle.to ? bundle.to.substring(0, 42).concat('...') : "-";
            bundle.displayBundleAddress = bundle.hash.substring(0, 42).concat('...');
            bundle.json = {
                bundle: bundle.hash,
                time: bundle.dateTime,
                from: bundle.from,
                to: bundle.to,
                amount: bundle.amount,
            };
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = this.determineLength.bind(this);
        this.iotaPendingTransactions.addListener(listener);
        this.$scope.$on('$destroy', function () {
            _this.iotaPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
    };
    VirtualRepeatIotaTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatIotaTransactionsComponent.prototype.onSelect = function (selectedTransaction) {
    };
    VirtualRepeatIotaTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatIotaTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- BUNDLE ID  -->\n          <div class=\"truncate-col bundle-col left\">Bundle ID</div>\n\n          <!-- FROM -->\n          <div class=\"truncate-col bundle-col left\">FROM</div>\n\n          <!-- TO -->\n          <div class=\"truncate-col bundle-col left\">TO</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col\">Amount</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n\n            <!-- Bundle ID -->\n            <div class=\"truncate-col bundle-col left\" >\n              <span>\n                <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://thetangle.org/transaction/{{item.bundleId}}\">{{item.displayBundleAddress}}</a>\n              </span>\n            </div>\n\n            <!-- FROM -->\n            <div class=\"truncate-col bundle-col left\">\n             <span>{{item.displayFromAddress}}</span>\n            </div>\n\n            <!-- TO -->\n            <div class=\"truncate-col bundle-col left\">\n              <span>{{item.displayToAddress}}</span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col\">\n              <span>{{item.amount}}</span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'iotaTransactionsProviderFactory', 'settings', 'iotaPendingTransactions', 'user', 'iotaBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Function, IotaTransactionsProviderFactory,
            SettingsService,
            IotaPendingTransactionsService,
            UserService,
            IotaBlockExplorerService])
    ], VirtualRepeatIotaTransactionsComponent);
    return VirtualRepeatIotaTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatLtcTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatLtcTransactionsComponent, _super);
    function VirtualRepeatLtcTransactionsComponent($scope, $q, ltcTransactionsProviderFactory, settings, ltcPendingTransactions, user) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.ltcTransactionsProviderFactory = ltcTransactionsProviderFactory;
        _this.settings = settings;
        _this.ltcPendingTransactions = ltcPendingTransactions;
        _this.user = user;
        return _this;
    }
    VirtualRepeatLtcTransactionsComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        this.initializeVirtualRepeat(this.ltcTransactionsProviderFactory.createProvider(this.account), function (transaction) {
            transaction.dateTime = dateFormat(new Date(transaction.blockTime * 1000), format);
            transaction.from = transaction.vin[0].addresses[0];
            transaction.amount = transaction.vout[0].value / 100000000;
            var totalInputs = 0;
            var inputs = '';
            for (var i = 0; i < transaction.vin.length; i++) {
                totalInputs += parseFloat(transaction.vin[i].value);
                inputs += "\n          ".concat(transaction.vin[i].addresses[0], " (").concat((parseFloat(transaction.vin[i].value) / 100000000).toFixed(8), ")");
            }
            var totalOutputs = 0;
            var outputs = '';
            for (var i = 0; i < transaction.vout.length; i++) {
                totalOutputs += parseFloat(transaction.vout[i].value);
                outputs += "\n          ".concat(transaction.vout[i].addresses[0], " (").concat((parseFloat(transaction.vout[i].value) / 100000000).toFixed(8), ")");
            }
            for (var i = 0; i < transaction.vout.length && transaction.vout[i].addresses; i++) {
                if (transaction.vout[i].addresses) {
                    transaction.to = transaction.vout[0].addresses[0];
                    break;
                }
            }
            if (transaction.from === transaction.to) {
                for (var i = 1; i < transaction.vout.length && transaction.vout[i].addresses; i++) {
                    transaction.to = transaction.vout[i].addresses[0];
                    transaction.amount = transaction.vout[i].value / 100000000;
                    break;
                }
            }
            if (inputs.includes(_this.account)) {
                transaction.amount = "-".concat(transaction.amount);
            }
            else {
                for (var i = 0; i < transaction.vout.length; i++) {
                    if (transaction.vout[i].addresses && transaction.vout[i].addresses[0] === _this.account) {
                        transaction.to = _this.account;
                        transaction.amount = transaction.vout[i].value / 100000000;
                    }
                }
            }
            if (!outputs.includes(_this.account) && transaction.vout.length > 1) {
                transaction.to = 'Multiple Outputs';
            }
            transaction.json = {
                txid: transaction.txid,
                time: transaction.dateTime,
                block: transaction.blockHeight,
                totalInputs: totalInputs,
                totalOutputs: totalOutputs,
                confirmations: transaction.confirmations,
                fees: transaction.fees / 100000000,
                inputs: inputs.trim(),
                outputs: outputs.trim()
            };
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = this.determineLength.bind(this);
        this.PAGE_SIZE = 10;
        this.ltcPendingTransactions.addListener(listener);
        this.$scope.$on('$destroy', function () {
            _this.ltcPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
    };
    VirtualRepeatLtcTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatLtcTransactionsComponent.prototype.txUrl = function (txId) {
        return HttpService.prepareUrl("https://ltc1.heatwallet.com/api/v2/tx/".concat(txId));
    };
    VirtualRepeatLtcTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatLtcTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatLtcTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col right\">Amount</div>\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\">\n              <span>\n                <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"{{vm.txUrl(item.txid)}}\">{{item.txid}}</a>\n              </span>\n            </div>\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n              <span ng-show = \"item.from !== 'Multiple Inputs'\">{{item.from}}</span>\n              <a ng-show = \"item.from === 'Multiple Inputs'\" ng-click=\"vm.jsonDetails($event, item.json)\">{{item.from}}</a>\n            </div>\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span ng-show = \"item.to !== 'Multiple Outputs'\">{{item.to}}</span>\n              <a ng-show = \"item.to === 'Multiple Outputs'\" ng-click=\"vm.jsonDetails($event, item.json)\">{{item.to}}</a>\n            </div>\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col right\">\n              <span>{{item.amount}}</span>\n            </div>\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'ltcTransactionsProviderFactory', 'settings', 'ltcPendingTransactions', 'user'),
        __metadata("design:paramtypes", [Object, Function, LtcTransactionsProviderFactory,
            SettingsService,
            LtcPendingTransactionsService,
            UserService])
    ], VirtualRepeatLtcTransactionsComponent);
    return VirtualRepeatLtcTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatNxtTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatNxtTransactionsComponent, _super);
    function VirtualRepeatNxtTransactionsComponent($scope, $q, nxtTransactionsProviderFactory, settings, nxtPendingTransactions, user, nxtBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.nxtTransactionsProviderFactory = nxtTransactionsProviderFactory;
        _this.settings = settings;
        _this.nxtPendingTransactions = nxtPendingTransactions;
        _this.user = user;
        _this.nxtBlockExplorerService = nxtBlockExplorerService;
        return _this;
    }
    VirtualRepeatNxtTransactionsComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var secretPhrase = this.user.currency.secretPhrase;
        this.initializeVirtualRepeat(this.nxtTransactionsProviderFactory.createProvider(this.account), function (transaction) {
            transaction.amount = transaction.amountNQT / 100000000;
            var date = utils.timestampToDate(transaction.timestamp);
            transaction.dateTime = dateFormat(date, format);
            transaction.from = transaction.senderRS;
            transaction.to = transaction.recipientRS;
            transaction.txid = transaction.transaction;
            transaction.message = '';
            if (transaction.attachment.encryptedMessage) {
                if (transaction.senderPublicKey !== _this.user.publicKey) {
                    transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, transaction.senderPublicKey, secretPhrase);
                }
                else {
                    try {
                        var recipientPublicKey_2;
                        _this.nxtBlockExplorerService.getPublicKeyFromAddress(transaction.recipientRS).then(function (_publicKey) {
                            recipientPublicKey_2 = _publicKey;
                            transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, recipientPublicKey_2, secretPhrase);
                            transaction.json.message = transaction.message;
                        });
                    }
                    catch (e) {
                        transaction.message = '';
                    }
                }
            }
            transaction.json = {
                txid: transaction.transaction,
                time: transaction.dateTime,
                from: transaction.from,
                to: transaction.to,
                amount: transaction.amount,
                block: transaction.height,
                confirmations: transaction.confirmations,
                fee: transaction.feeNQT / 100000000
            };
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = this.determineLength.bind(this);
        this.PAGE_SIZE = 10;
        this.nxtPendingTransactions.addListener(listener);
        this.$scope.$on('$destroy', function () {
            _this.nxtPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
    };
    VirtualRepeatNxtTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatNxtTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatNxtTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatNxtTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col\">Amount</div>\n\n          <!-- MESSAGE -->\n          <div class=\"truncate-col message-col left\">Message</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\" >\n              <span>{{item.txid}}</span>\n            </div>\n\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n             <span>{{item.from}}</span>\n            </div>\n\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span>{{item.to}}</span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col\">\n              <span>{{item.amount}}</span>\n            </div>\n\n            <!-- MESSAGE -->\n            <div class=\"truncate-col message-col left\">\n              <span>{{item.message}}</span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'nxtTransactionsProviderFactory', 'settings', 'nxtPendingTransactions', 'user', 'nxtBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Function, NxtTransactionsProviderFactory,
            SettingsService,
            NxtPendingTransactionsService,
            UserService,
            NxtBlockExplorerService])
    ], VirtualRepeatNxtTransactionsComponent);
    return VirtualRepeatNxtTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatPaymentsComponent = (function (_super) {
    __extends(VirtualRepeatPaymentsComponent, _super);
    function VirtualRepeatPaymentsComponent($scope, $q, heat, explorerPaymentsProviderFactory, settings, assetInfo) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.heat = heat;
        _this.explorerPaymentsProviderFactory = explorerPaymentsProviderFactory;
        _this.settings = settings;
        _this.assetInfo = assetInfo;
        return _this;
    }
    VirtualRepeatPaymentsComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        this.initializeVirtualRepeat(this.explorerPaymentsProviderFactory.createProvider(this.account), function (payment) {
            var date = utils.timestampToDate(payment.timestamp);
            payment.time = dateFormat(date, format);
            payment.assetInfo = _this.asset(payment.currency);
            var decimals = payment.assetInfo.decimals;
            payment.amount = (payment.quantity / (Math.pow(10, decimals))).toFixed(decimals);
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        if (angular.isUndefined(this.account)) {
            this.heat.subscriber.blockPopped({}, refresh, this.$scope);
            this.heat.subscriber.blockPushed({}, refresh, this.$scope);
        }
    };
    VirtualRepeatPaymentsComponent.prototype.asset = function (asset) {
        if (this.assetInfo.cache[asset] && this.assetInfo.cache[asset].symbol)
            return this.assetInfo.cache[asset];
        else
            this.assetInfo.getInfo(asset);
    };
    VirtualRepeatPaymentsComponent.prototype.jsonDetails = function ($event, item) {
        var title = item.isAtomicTransfer ? "Payment (multi transfer): " : "Payment: ";
        var fields = [["transaction"], ["senderPublicName", "sender"], ["recipientPublicName", "recipient"], ["height"], ["time"], ["amount"]];
        dialogs.jsonDetails($event, item, title + "transaction " + item.transaction, fields);
    };
    VirtualRepeatPaymentsComponent.prototype.onSelect = function (selectedTrade) { };
    VirtualRepeatPaymentsComponent = __decorate([
        Component({
            selector: 'virtualRepeatPayments',
            inputs: ['account', 'block', 'personalize', 'hideLabel'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col height-col left\">Height</div>\n          <div class=\"truncate-col date-col left\">Time</div>\n          <div class=\"truncate-col name-col left\">Sender</div>\n          <div class=\"truncate-col name-col left\">Recipient</div>\n          <div class=\"truncate-col asset-col left\">Currency/Asset</div>\n          <div class=\"truncate-col amount-col\">Amount</div>\n          <div class=\"truncate-col json-col\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <div class=\"truncate-col height-col left\">{{item.height}}</div>\n\n            <div class=\"truncate-col date-col left\">{{item.time}}</div>\n\n            <div class=\"truncate-col name-col left\">{{item.senderPublicName||item.sender}}</div>\n\n            <div class=\"truncate-col name-col left\">{{item.recipientPublicName||item.recipient}}</div>\n\n            <div class=\"truncate-col asset-col left\">{{item.assetInfo.symbol}}</div>\n\n            <div class=\"truncate-col amount-col\">{{item.amount}}</div>\n\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'explorerPaymentsProviderFactory', 'settings', 'assetInfo'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            ExplorerPaymentsProviderFactory,
            SettingsService,
            AssetInfoService])
    ], VirtualRepeatPaymentsComponent);
    return VirtualRepeatPaymentsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatTradesComponent = (function (_super) {
    __extends(VirtualRepeatTradesComponent, _super);
    function VirtualRepeatTradesComponent($scope, $q, heat, explorerTradesProviderFactory, settings, assetInfo) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.heat = heat;
        _this.explorerTradesProviderFactory = explorerTradesProviderFactory;
        _this.settings = settings;
        _this.assetInfo = assetInfo;
        return _this;
    }
    VirtualRepeatTradesComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        this.initializeVirtualRepeat(this.explorerTradesProviderFactory.createProvider(this.account), function (trade) {
            var date = utils.timestampToDate(trade.timestamp);
            trade.time = dateFormat(date, format);
            var currecy = _this.asset(trade.currency);
            var asset = _this.asset(trade.asset);
            var decimals = currecy.decimals;
            trade.market = "".concat(currecy.symbol, "/").concat(asset.symbol);
            trade.type = trade.buyer === _this.account ? 'Buy' : 'Sell';
            trade.price = (trade.price / (Math.pow(10, decimals))).toFixed(decimals);
            trade.amount = (trade.quantity / (Math.pow(10, decimals))).toFixed(decimals);
            trade.buyersellerName = trade.type === 'Buy' ? trade.sellerName : trade.buyerName;
            trade.buyerseller = trade.type === 'Buy' ? trade.seller : trade.buyer;
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        if (angular.isUndefined(this.account)) {
            this.heat.subscriber.blockPopped({}, refresh, this.$scope);
            this.heat.subscriber.blockPushed({}, refresh, this.$scope);
        }
    };
    VirtualRepeatTradesComponent.prototype.asset = function (asset) {
        if (this.assetInfo.cache[asset] && this.assetInfo.cache[asset].symbol)
            return this.assetInfo.cache[asset];
        else
            this.assetInfo.getInfo(asset);
    };
    VirtualRepeatTradesComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Trade: ' + item.askOrder);
    };
    VirtualRepeatTradesComponent.prototype.onSelect = function (selectedTrade) { };
    VirtualRepeatTradesComponent = __decorate([
        Component({
            selector: 'virtualRepeatTrades',
            inputs: ['account', 'block', 'personalize', 'hideLabel'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- MARKET -->\n          <div class=\"truncate-col market-col left\">Market</div>\n\n          <!-- TYPE -->\n          <div class=\"truncate-col type-col left\" flex>Type</div>\n\n          <!-- PRICE -->\n          <div class=\"truncate-col price-col left\">Price</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col left\">Amount</div>\n\n          <!-- BUYER/ SELLER -->\n          <div class=\"truncate-col buyerseller-col left\">Buyer/ Seller</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.time}}</div>\n\n            <!-- MARKET -->\n            <div class=\"truncate-col market-col left\">{{item.market}}</div>\n\n            <!-- TYPE -->\n            <div class=\"truncate-col type-col left\" flex>{{item.type}}</div>\n\n            <!-- PRICE -->\n            <div class=\"truncate-col price-col left\">{{item.price}}</div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col left\">{{item.amount}}</div>\n\n            <!-- BUYER/ SELLER -->\n            <div class=\"truncate-col buyerseller-col left\">\n              <a href=\"#/explorer-account/{{item.buyerseller}}/trades\">{{item.buyersellerName}} </a>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'explorerTradesProviderFactory', 'settings', 'assetInfo'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            ExplorerTradesProviderFactory,
            SettingsService,
            AssetInfoService])
    ], VirtualRepeatTradesComponent);
    return VirtualRepeatTradesComponent;
}(VirtualRepeatComponent));
var VirtualRepeatTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatTransactionsComponent, _super);
    function VirtualRepeatTransactionsComponent($scope, $q, heat, transactionsProviderFactory, settings, user, render, $mdPanel, controlCharRender) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.heat = heat;
        _this.transactionsProviderFactory = transactionsProviderFactory;
        _this.settings = settings;
        _this.user = user;
        _this.render = render;
        _this.$mdPanel = $mdPanel;
        _this.controlCharRender = controlCharRender;
        _this.renderer = new TransactionRenderer(_this);
        return _this;
    }
    VirtualRepeatTransactionsComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        this.initializeVirtualRepeat(this.transactionsProviderFactory.createProvider(this.account, this.block, this.transactionObject), function (transaction) {
            var date = utils.timestampToDate(transaction.timestamp);
            transaction.time = dateFormat(date, format);
            transaction.heightDisplay = transaction.height == 2147483647 ? '*' : transaction.height;
            if (_this.personalize) {
                if (transaction.type == 2 && (transaction.subtype == 5 || transaction.subtype == 6)) {
                    transaction['outgoing'] = false;
                }
                else {
                    transaction['outgoing'] = _this.user.account == transaction.sender;
                }
                transaction['renderedTransactionType'] = _this.renderer.renderTransactionType(transaction);
                var amountVal = _this.renderer.renderAmount(transaction);
                if (angular.isString(amountVal)) {
                    transaction['renderedAmount'] = amountVal;
                }
                else if (angular.isObject(amountVal)) {
                    amountVal.then(function (val) {
                        transaction['renderedAmount'] = val;
                    });
                }
                transaction['renderedToFrom'] = _this.renderer.renderedToFrom(transaction);
            }
            var renderedInfo = _this.renderer.renderInfo(transaction);
            if (angular.isString(renderedInfo)) {
                transaction['renderedInfo'] = renderedInfo;
            }
            else if (angular.isObject(renderedInfo)) {
                renderedInfo.then(function (text) {
                    transaction['renderedInfo'] = text;
                });
            }
            transaction['messageText'] = _this.heat.getHeatMessageContents(transaction);
            if (angular.isString(transaction['messageText'])) {
                var messagePreview = transaction['messageText'].substr(0, 50);
                if (transaction['messageText'].length > 50) {
                    messagePreview += " ...";
                }
                transaction['messagePreview'] = messagePreview;
            }
        });
        var refreshOneMore = false;
        var onBlockRefresh = function (block) {
            if ((block && block.numberOfTransactions > 0) || refreshOneMore) {
                setTimeout(function () { return _this.determineLength(); }, 2400);
                refreshOneMore = (block && block.numberOfTransactions > 0);
            }
        };
        var onBlockRefreshDebounced = utils.debounce(angular.bind(this, onBlockRefresh), 500, false);
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        if (angular.isString(this.account)) {
            this.heat.subscriber.unconfirmedTransaction({ recipient: this.account }, refresh, this.$scope);
            this.heat.subscriber.unconfirmedTransaction({ sender: this.account }, refresh, this.$scope);
            this.heat.subscriber.blockPushed({}, onBlockRefreshDebounced, this.$scope);
        }
        if (angular.isUndefined(this.block) && angular.isUndefined(this.account)) {
            this.heat.subscriber.unconfirmedTransaction({}, refresh, this.$scope);
            this.heat.subscriber.blockPopped({}, refresh, this.$scope);
            this.heat.subscriber.blockPushed({}, onBlockRefreshDebounced, this.$scope);
        }
    };
    VirtualRepeatTransactionsComponent.prototype.showPopup = function (messageText) {
        var renderedHTML = this.render.render(messageText, [this.controlCharRender]);
        var position = this.$mdPanel.newPanelPosition().absolute().center();
        var config = {
            attachTo: angular.element(document.body),
            controller: function () { },
            controllerAs: 'vm',
            disableParentScroll: true,
            template: "\n        <div class=\"virtual-repeat-transactions-message-contents\" ng-bind-html=\"vm.renderedHTML\"></div>\n      ",
            hasBackdrop: true,
            panelClass: 'demo-dialog-example',
            position: position,
            trapFocus: true,
            zIndex: 150,
            clickOutsideToClose: true,
            escapeToClose: true,
            focusOnOpen: true,
            locals: {
                renderedHTML: renderedHTML
            }
        };
        this.$mdPanel.open(config);
    };
    VirtualRepeatTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        var fields = [["transaction"], ["senderPublicName", "sender"], ["recipientPublicName", "recipient"], ["height"], ["time"], ["amount"], ["fee"], ["messageText", "message text"], ["type"], ["subtype"]];
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.transaction, fields);
    };
    VirtualRepeatTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatTransactions',
            inputs: ['account', 'block', 'personalize', 'transactionObject', 'hideLabel'],
            styles: ["\n  .loadingIcon {\n    color: grey;\n    flex: auto;\n    margin-left: 10px;\n  }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">\n      <div>Latest Transactions</div>\n      <div><md-icon md-font-library=\"material-icons\" class=\"loadingIcon rotate\" ng-show=\"vm.loadedPages.inProgress\">sync</md-icon></div>\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <!-- HEIGHT -->\n          <div class=\"he truncate-col height-col left\" ng-if=\"!vm.personalize\">Height</div>\n\n          <!-- ID -->\n          <div class=\"truncate-col id-col left\" ng-if=\"vm.personalize || vm.account\">Id</div>\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- INOUT -->\n          <div class=\"truncate-col inoutgoing-col left\" ng-if=\"vm.personalize\">In/Out</div>\n\n          <!-- TRANSACTION -->\n          <div class=\"truncate-col transaction-col left\" ng-if=\"vm.personalize\">Transaction</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col left\" ng-if=\"vm.personalize\">Amount</div>\n\n          <!-- TOFROM -->\n          <div class=\"truncate-col tofrom-col left\" ng-if=\"vm.personalize\">To/From</div>\n\n          <!-- INFO -->\n          <div class=\"truncate-col info-col left\" flex>Info</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- HEIGHT -->\n            <div class=\"he truncate-col height-col left\" ng-if=\"!vm.personalize\">\n              <elipses-loading ng-show=\"item.height==2147483647\"></elipses-loading>\n              <span ng-show=\"item.height!=2147483647\">{{item.height}}</span>\n            </div>\n\n            <!-- ID -->\n            <div class=\"truncate-col id-col left\" ng-if=\"vm.personalize || vm.account\">\n              {{item.transaction}}\n            </div>\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.time}}</div>\n\n            <!-- INOUT -->\n            <div class=\"truncate-col inoutgoing-col left\" ng-if=\"vm.personalize\">\n              <md-icon md-font-library=\"material-icons\" ng-class=\"{outgoing: item.outgoing, incoming: !item.outgoing}\">\n                {{item.outgoing ? 'keyboard_arrow_up': 'keyboard_arrow_down'}}\n              </md-icon>\n            </div>\n\n            <!-- TRANSACTION -->\n            <div class=\"truncate-col transaction-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedTransactionType\"></span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedAmount\"></span>\n            </div>\n\n            <!-- TOFROM -->\n            <div class=\"truncate-col tofrom-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedToFrom\"></span>\n            </div>\n\n            <!-- INFO -->\n            <div class=\"truncate-col info-col left\" flex>\n              <span ng-bind-html=\"item.renderedInfo\"></span>\n              <span class=\"virtual-repeat-transactions-message\" ng-if=\"item.messageText\">\n                <md-button ng-click=\"vm.showPopup(item.messageText)\" class=\"md-icon-button\" md-no-ink>\n                  <md-icon md-font-library=\"material-icons\">message</md-icon>\n                </md-button>\n                <code>{{item.messagePreview}}</code>\n              </span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'transactionsProviderFactory', 'settings', 'user', 'render', '$mdPanel', 'controlCharRender'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            TransactionsProviderFactory,
            SettingsService,
            UserService,
            RenderService, Object, ControlCharRenderService])
    ], VirtualRepeatTransactionsComponent);
    return VirtualRepeatTransactionsComponent;
}(VirtualRepeatComponent));
var TransactionRenderHelper = (function () {
    function TransactionRenderHelper(template, extractor) {
        this.template = template;
        this.extractor = extractor;
        this.$q = heat.$inject.get('$q');
    }
    TransactionRenderHelper.prototype.isPromise = function (val) {
        return angular.isObject(val) && angular.isFunction(val['then']);
    };
    TransactionRenderHelper.prototype.render = function (transaction) {
        var _this = this;
        var parts = this.extractor(transaction);
        var args = {};
        var promises = [];
        angular.forEach(parts, function (val, key) {
            if (_this.isPromise(val)) {
                promises.push(val);
                val.then(function (promiseVal) {
                    args[key] = promiseVal;
                });
            }
            else {
                args[key] = val;
            }
        });
        var template = angular.isFunction(this.template) ? this.template.call(null, transaction) : this.template;
        var text = (' ' + template).slice(1);
        if (promises.length > 0) {
            var deferred = this.$q.defer();
            this.$q.all(promises).then(function () {
                angular.forEach(args, function (val, key) {
                    text = text.replace(new RegExp("\\$" + key, 'g'), val);
                });
                deferred.resolve(text);
            });
            return deferred.promise;
        }
        angular.forEach(args, function (val, key) {
            text = text.replace(new RegExp("\\$" + key, 'g'), val);
        });
        return text;
    };
    return TransactionRenderHelper;
}());
var TransactionRenderer = (function () {
    function TransactionRenderer(provider) {
        var _this = this;
        this.provider = provider;
        this.TYPE_PAYMENT = 0;
        this.TYPE_MESSAGING = 1;
        this.TYPE_COLORED_COINS = 2;
        this.TYPE_ACCOUNT_CONTROL = 4;
        this.SUBTYPE_PAYMENT_ORDINARY_PAYMENT = 0;
        this.SUBTYPE_MESSAGING_ARBITRARY_MESSAGE = 0;
        this.SUBTYPE_COLORED_COINS_ASSET_ISSUANCE = 0;
        this.SUBTYPE_COLORED_COINS_ASSET_ISSUE_MORE = 1;
        this.SUBTYPE_COLORED_COINS_ASSET_TRANSFER = 2;
        this.SUBTYPE_COLORED_COINS_ASK_ORDER_PLACEMENT = 3;
        this.SUBTYPE_COLORED_COINS_BID_ORDER_PLACEMENT = 4;
        this.SUBTYPE_COLORED_COINS_ASK_ORDER_CANCELLATION = 5;
        this.SUBTYPE_COLORED_COINS_BID_ORDER_CANCELLATION = 6;
        this.SUBTYPE_COLORED_COINS_WHITELIST_ASSET_ACCOUNT = 7;
        this.SUBTYPE_COLORED_COINS_WHITELIST_MARKET = 9;
        this.SUBTYPE_COLORED_COINS_ATOMIC_MULTI_TRANSFER = 10;
        this.SUBTYPE_COLORED_COINS_ASSET_ASSIGN_FEES = 11;
        this.SUBTYPE_COLORED_COINS_ASSET_EXPIRATION = 12;
        this.SUBTYPE_ACCOUNT_CONTROL_EFFECTIVE_BALANCE_LEASING = 0;
        this.SUBTYPE_ACCOUNT_CONTROL_INTERNET_ADDRESS = 1;
        this.renderers = {};
        this.transactionTypes = {};
        var key;
        this.heat = heat.$inject.get('heat');
        this.assetInfo = heat.$inject.get('assetInfo');
        this.$q = heat.$inject.get('$q');
        key = this.TYPE_PAYMENT + ":" + this.SUBTYPE_PAYMENT_ORDINARY_PAYMENT;
        this.transactionTypes[key] = 'TRANSFER HEAT';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>TRANSFER HEAT</b> From $sender to $recipient amount $amount';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                amount: _this.amount(t.amount, 8, "HEAT"),
                recipient: _this.account(t.recipient, t.recipientPublicName)
            };
        });
        key = this.TYPE_MESSAGING + ":" + this.SUBTYPE_MESSAGING_ARBITRARY_MESSAGE;
        this.transactionTypes[key] = 'SEND MESSAGE';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>SEND MESSAGE</b> From $sender to $recipient';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                recipient: _this.account(t.recipient, t.recipientPublicName)
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASSET_ISSUANCE;
        this.transactionTypes[key] = 'ISSUE ASSET';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '$private Asset $asset' : "<b>ISSUE $private ASSET</b> Issuer $sender asset $asset";
        }, function (t) {
            _this.asset(t.transaction);
            var info = _this.assetInfo.cache[t.transaction];
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                asset: t.transaction,
                private: info && info.type == 1 ? 'PRIVATE' : ''
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASSET_TRANSFER;
        this.transactionTypes[key] = 'TRANSFER ASSET';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : "<b>TRANSFER ASSET</b> $asset from $sender to $recipient amount $amount";
        }, function (t) {
            var assetId = t.attachment['asset'];
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                recipient: _this.account(t.recipient, t.recipientPublicName),
                asset: _this.asset(assetId),
                amount: _this.amount(t.attachment['quantity'], _this.assetInfo.cache[assetId])
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASK_ORDER_PLACEMENT;
        this.transactionTypes[key] = 'SELL ORDER';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ?
                '$currency/$asset amount $amount price $price' :
                "<b>SELL ORDER</b> $sender placed sell order $currency/$asset amount $amount price $price";
        }, function (t) {
            var assetId = t.attachment['asset'];
            var currencyId = t.attachment['currency'];
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                currency: _this.asset(t.attachment['currency']),
                asset: _this.asset(t.attachment['asset']),
                amount: _this.amount(t.attachment['quantity'], _this.assetInfo.cache[assetId]),
                price: _this.amount(t.attachment['price'], _this.assetInfo.cache[currencyId]),
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_BID_ORDER_PLACEMENT;
        this.transactionTypes[key] = 'BUY ORDER';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ?
                '$currency/$asset amount $amount price $price' :
                "<b>BUY ORDER</b> $sender placed buy order $currency/$asset amount $amount price $price";
        }, function (t) {
            var assetId = t.attachment['asset'];
            var currencyId = t.attachment['currency'];
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                currency: _this.asset(currencyId),
                asset: _this.asset(assetId),
                amount: _this.amount(t.attachment['quantity'], _this.assetInfo.cache[assetId]),
                price: _this.amount(t.attachment['price'], _this.assetInfo.cache[currencyId]),
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASK_ORDER_CANCELLATION;
        this.transactionTypes[key] = 'CANCEL SELL';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ?
                '$currency/$asset amount $amount price $price' :
                '<b>CANCEL SELL</b> $sender cancelled order $currency/$asset amount $amount price $price';
        }, function (t) {
            var assetId = t.attachment['cancelledAskAsset'];
            var currencyId = t.attachment['cancelledAskCurrency'];
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                order: t.attachment['order'],
                currency: _this.asset(t['cancelledAskCurrency']),
                asset: _this.asset(t['cancelledAskAsset']),
                amount: _this.amount(t['cancelledAskQuantity'], _this.assetInfo.cache[assetId]),
                price: _this.amount(t['cancelledAskPrice'], _this.assetInfo.cache[currencyId])
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_BID_ORDER_CANCELLATION;
        this.transactionTypes[key] = 'CANCEL BUY';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ?
                '$currency/$asset amount $amount price $price' :
                '<b>CANCEL BUY</b> $sender cancelled order $currency/$asset amount $amount price $price';
        }, function (t) {
            var assetId = t.attachment['cancelledAskAsset'];
            var currencyId = t.attachment['cancelledAskCurrency'];
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                order: t.attachment['order'],
                currency: _this.asset(t['cancelledBidCurrency']),
                asset: _this.asset(t['cancelledBidAsset']),
                amount: _this.amount(t['cancelledBidQuantity'], _this.assetInfo.cache[assetId]),
                price: _this.amount(t['cancelledBidPrice'], _this.assetInfo.cache[currencyId])
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ATOMIC_MULTI_TRANSFER;
        this.transactionTypes[key] = 'MULTI TRANSFER';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>MULTI TRANSFER</b> From $sender';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName)
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASSET_ASSIGN_FEES;
        this.transactionTypes[key] = 'ASSET ASSIGN FEES';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>ASSIGN PRIVATE ASSET FEES</b> Asset $asset';
        }, function (t) {
            return {
                asset: _this.asset(t.attachment['asset'])
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASSET_EXPIRATION;
        this.transactionTypes[key] = 'ASSET EXPIRATION';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>ASSIGN ASSET EXPIRATION</b> Asset $asset expiration $dateTime';
        }, function (t) {
            return {
                asset: _this.asset(t.attachment['asset']),
                dateTime: utils.timestampToDate(parseInt(_this.asset(t.attachment['asset']))).toLocaleString()
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_WHITELIST_MARKET;
        this.transactionTypes[key] = 'WHITELIST MARKET';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>WHITELIST MARKET</b> Currency $currency Asset $asset';
        }, function (t) {
            return {
                currency: _this.asset(t.attachment['currency']),
                asset: _this.asset(t.attachment['asset'])
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_WHITELIST_ASSET_ACCOUNT;
        this.transactionTypes[key] = 'WHITELIST ASSET ACCOUNT';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>WHITELIST ACCOUNT FOR PRIVATE ASSET</b> Asset $asset Account $account';
        }, function (t) {
            return {
                asset: _this.asset(t.attachment['asset']),
                account: _this.account(t.attachment['account'])
            };
        });
        key = this.TYPE_ACCOUNT_CONTROL + ":" + this.SUBTYPE_ACCOUNT_CONTROL_EFFECTIVE_BALANCE_LEASING;
        this.transactionTypes[key] = 'BALANCE LEASE';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? 'Lease balance for $period blocks' : "<b>BALANCE LEASE</b> From $sender to $recipient for $period blocks";
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                recipient: _this.account(t.recipient, t.recipientPublicName),
                period: utils.commaFormat(t.attachment['period'].toString())
            };
        });
        key = this.TYPE_ACCOUNT_CONTROL + ":" + this.SUBTYPE_ACCOUNT_CONTROL_INTERNET_ADDRESS;
        this.transactionTypes[key] = 'INTERNET ADDRESS';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize
                ? 'internet address $a'
                : '<b>REGISTER INTERNET ADDRESS</b> $sender registered internet address "$a"';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                a: t.attachment['internetAddress']
            };
        });
    }
    TransactionRenderer.prototype.renderTransactionType = function (transaction) {
        var key = "".concat(transaction.type, ":").concat(transaction.subtype);
        return this.transactionTypes[key] || key;
    };
    TransactionRenderer.prototype.renderAmount = function (transaction) {
        var _this = this;
        if (transaction.type == this.TYPE_PAYMENT && transaction.subtype == this.SUBTYPE_PAYMENT_ORDINARY_PAYMENT) {
            var amount = transaction.amount;
            var symbol = 'HEAT';
            var neg = transaction.sender == this.provider.account;
            return this.formatAmount(amount, symbol, neg);
        }
        if (transaction.type == this.TYPE_COLORED_COINS) {
            var amount_1 = null;
            var neg_1 = null;
            var currency = null;
            switch (transaction.subtype) {
                case this.SUBTYPE_COLORED_COINS_ASSET_ISSUANCE:
                case this.SUBTYPE_COLORED_COINS_ASSET_ISSUE_MORE: {
                    amount_1 = transaction.attachment['quantity'];
                    currency = transaction.transaction;
                    break;
                }
                case this.SUBTYPE_COLORED_COINS_ASSET_TRANSFER: {
                    amount_1 = transaction.attachment['quantity'];
                    neg_1 = transaction.sender == this.provider.account;
                    currency = transaction.attachment['asset'];
                    break;
                }
                case this.SUBTYPE_COLORED_COINS_ASK_ORDER_PLACEMENT: {
                    amount_1 = transaction.attachment['quantity'];
                    currency = transaction.attachment['asset'];
                    neg_1 = true;
                    break;
                }
                case this.SUBTYPE_COLORED_COINS_BID_ORDER_PLACEMENT: {
                    amount_1 = utils.calculateTotalOrderPriceQNT(transaction.attachment['quantity'], transaction.attachment['price']);
                    currency = transaction.attachment['currency'];
                    neg_1 = true;
                    break;
                }
            }
            if (angular.isString(amount_1)) {
                var assetInfo_1 = this.assetInfo.cache[currency];
                if (angular.isDefined(assetInfo_1)) {
                    var symbol = assetInfo_1.symbol;
                    if (angular.isString(symbol)) {
                        return this.formatAmount(amount_1, symbol, neg_1, assetInfo_1);
                    }
                }
                var deferred_1 = this.$q.defer();
                this.assetInfo.getInfo(currency).then(function (info) {
                    deferred_1.resolve(_this.formatAmount(amount_1, info.symbol, neg_1, info));
                }, deferred_1.reject);
                return deferred_1.promise;
            }
        }
    };
    TransactionRenderer.prototype.renderedToFrom = function (transaction) {
        if (transaction.sender == this.provider.account) {
            return this.account(transaction.recipient, transaction.recipientPublicName);
        }
        return this.account(transaction.sender, transaction.senderPublicName);
    };
    TransactionRenderer.prototype.formatAmount = function (amount, symbol, neg, assetInfo) {
        var returns = this.amount(amount, assetInfo ? assetInfo.decimals : 8, symbol);
        return (neg ? '-' : '+') + returns;
    };
    TransactionRenderer.prototype.isOutgoing = function (transaction) {
        return transaction.sender == this.provider.account;
    };
    TransactionRenderer.prototype.renderInfo = function (transaction) {
        var renderer = this.renderers[transaction.type + ":" + transaction.subtype];
        if (renderer)
            return renderer.render(transaction);
        return "not supported type=".concat(transaction.type, " subtype=").concat(transaction.subtype);
    };
    TransactionRenderer.prototype.account = function (account, publicName) {
        return account == '0' ? '' : "<a href=\"#/explorer-account/".concat(account, "/transactions\">").concat(publicName || account, "</a>");
    };
    TransactionRenderer.prototype.amount = function (amountHQT, decimalsInfo, symbol) {
        var decimals = decimalsInfo
            ? (typeof decimalsInfo === "number" ? decimalsInfo : decimalsInfo.decimals)
            : 8;
        return "<span>".concat(utils.formatQNT(amountHQT || "0", decimals), " ").concat(symbol || "", "</span>");
    };
    TransactionRenderer.prototype.asset = function (asset) {
        if (!asset)
            return "?";
        if (asset == "5592059897546023466")
            return "<b>BTC</b>";
        if (asset == "0")
            return "<b>HEAT</b>";
        if (this.assetInfo.cache[asset] && this.assetInfo.cache[asset].symbol)
            return this.assetInfo.cache[asset].symbol;
        this.assetInfo.getInfo(asset);
        return asset;
    };
    return TransactionRenderer;
}());
var converters;
(function (converters) {
    var charToNibble = {};
    var nibbleToChar = [];
    var i;
    for (i = 0; i <= 9; ++i) {
        var character = i.toString();
        charToNibble[character] = i;
        nibbleToChar.push(character);
    }
    for (i = 10; i <= 15; ++i) {
        var lowerChar = String.fromCharCode('a'.charCodeAt(0) + i - 10);
        var upperChar = String.fromCharCode('A'.charCodeAt(0) + i - 10);
        charToNibble[lowerChar] = i;
        charToNibble[upperChar] = i;
        nibbleToChar.push(lowerChar);
    }
    function byteArrayToHexString(bytes) {
        var str = '';
        for (var i = 0; i < bytes.length; ++i) {
            if (bytes[i] < 0) {
                bytes[i] += 256;
            }
            str += nibbleToChar[bytes[i] >> 4] + nibbleToChar[bytes[i] & 0x0F];
        }
        return str;
    }
    converters.byteArrayToHexString = byteArrayToHexString;
    function stringToByteArray(stringValue) {
        var str = unescape(encodeURIComponent(stringValue));
        var bytes = new Array(str.length);
        for (var i = 0; i < str.length; ++i) {
            bytes[i] = str.charCodeAt(i);
        }
        return bytes;
    }
    converters.stringToByteArray = stringToByteArray;
    function hexStringToByteArray(str) {
        var bytes = [];
        var i = 0;
        if (0 !== str.length % 2) {
            bytes.push(charToNibble[str.charAt(0)]);
            ++i;
        }
        for (; i < str.length - 1; i += 2) {
            bytes.push((charToNibble[str.charAt(i)] << 4) + charToNibble[str.charAt(i + 1)]);
        }
        return bytes;
    }
    converters.hexStringToByteArray = hexStringToByteArray;
    function stringToHexString(str) {
        return byteArrayToHexString(stringToByteArray(str));
    }
    converters.stringToHexString = stringToHexString;
    function hexStringToString(hex) {
        return byteArrayToString(hexStringToByteArray(hex));
    }
    converters.hexStringToString = hexStringToString;
    function checkBytesToIntInput(bytes, numBytes, opt_startIndex) {
        var startIndex = opt_startIndex || 0;
        if (startIndex < 0) {
            throw new Error('Start index should not be negative');
        }
        if (bytes.length < startIndex + numBytes) {
            throw new Error('Need at least ' + (numBytes) + ' bytes to convert to an integer');
        }
        return startIndex;
    }
    function byteArrayToSignedShort(bytes, opt_startIndex) {
        var index = checkBytesToIntInput(bytes, 2, opt_startIndex);
        var value = bytes[index];
        value += bytes[index + 1] << 8;
        return value;
    }
    converters.byteArrayToSignedShort = byteArrayToSignedShort;
    function byteArrayToSignedInt32(bytes, opt_startIndex) {
        var index = checkBytesToIntInput(bytes, 4, opt_startIndex);
        var value = bytes[index];
        value += bytes[index + 1] << 8;
        value += bytes[index + 2] << 16;
        value += bytes[index + 3] << 24;
        return value;
    }
    converters.byteArrayToSignedInt32 = byteArrayToSignedInt32;
    function byteArrayToBigInteger(bytes, opt_startIndex) {
        var index = checkBytesToIntInput(bytes, 8, opt_startIndex);
        var value = new BigInteger("0", 10);
        var temp1, temp2;
        for (var i = 7; i >= 0; i--) {
            temp1 = value.multiply(new BigInteger("256", 10));
            temp2 = temp1.add(new BigInteger(bytes[opt_startIndex + i].toString(10), 10));
            value = temp2;
        }
        return value;
    }
    converters.byteArrayToBigInteger = byteArrayToBigInteger;
    function byteArrayToWordArray(byteArray) {
        var i = 0, offset = 0, word = 0, len = byteArray.length;
        var words = new Uint32Array(((len / 4) | 0) + (len % 4 == 0 ? 0 : 1));
        while (i < (len - (len % 4))) {
            words[offset++] = (byteArray[i++] << 24) | (byteArray[i++] << 16) | (byteArray[i++] << 8) | (byteArray[i++]);
        }
        if (len % 4 != 0) {
            word = byteArray[i++] << 24;
            if (len % 4 > 1) {
                word = word | byteArray[i++] << 16;
            }
            if (len % 4 > 2) {
                word = word | byteArray[i++] << 8;
            }
            words[offset] = word;
        }
        return { sigBytes: len, words: words };
    }
    converters.byteArrayToWordArray = byteArrayToWordArray;
    function wordArrayToByteArray(wordArray) {
        var len = wordArray.words.length;
        if (len == 0) {
            return new Array(0);
        }
        var byteArray = new Array(wordArray.sigBytes);
        var offset = 0, word, i;
        for (i = 0; i < len - 1; i++) {
            word = wordArray.words[i];
            byteArray[offset++] = word >> 24;
            byteArray[offset++] = (word >> 16) & 0xff;
            byteArray[offset++] = (word >> 8) & 0xff;
            byteArray[offset++] = word & 0xff;
        }
        word = wordArray.words[len - 1];
        byteArray[offset++] = word >> 24;
        if (wordArray.sigBytes % 4 == 0) {
            byteArray[offset++] = (word >> 16) & 0xff;
            byteArray[offset++] = (word >> 8) & 0xff;
            byteArray[offset++] = word & 0xff;
        }
        if (wordArray.sigBytes % 4 > 1) {
            byteArray[offset++] = (word >> 16) & 0xff;
        }
        if (wordArray.sigBytes % 4 > 2) {
            byteArray[offset++] = (word >> 8) & 0xff;
        }
        return byteArray;
    }
    converters.wordArrayToByteArray = wordArrayToByteArray;
    function byteArrayToString(bytes, opt_startIndex, length) {
        if (length == 0) {
            return "";
        }
        if (opt_startIndex && length) {
            var index = checkBytesToIntInput(bytes, parseInt(length, 10), parseInt(opt_startIndex, 10));
            bytes = bytes.slice(opt_startIndex, opt_startIndex + length);
        }
        return byteArrayToStringInternal(bytes);
    }
    converters.byteArrayToString = byteArrayToString;
    function byteArrayToStringInternal(bytes) {
        var result = "";
        var chunkSize = 20000;
        if (bytes.length > chunkSize) {
            var pos = 0;
            while (pos < bytes.length) {
                var shift = 0;
                while (shift < 3) {
                    try {
                        var escaped = escape(String.fromCharCode.apply(null, bytes.slice(pos, pos + chunkSize + shift)));
                        result = result + decodeURIComponent(escaped);
                        pos = pos + chunkSize + shift;
                        break;
                    }
                    catch (e) {
                        console.debug("trying decode escaped string " + e);
                    }
                    shift++;
                }
            }
        }
        else {
            result = decodeURIComponent(escape(String.fromCharCode.apply(null, bytes)));
        }
        return result;
    }
    function byteArrayToShortArray(byteArray) {
        var shortArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var i;
        for (i = 0; i < 16; i++) {
            shortArray[i] = byteArray[i * 2] | byteArray[i * 2 + 1] << 8;
        }
        return shortArray;
    }
    converters.byteArrayToShortArray = byteArrayToShortArray;
    function shortArrayToByteArray(shortArray) {
        var byteArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var i;
        for (i = 0; i < 16; i++) {
            byteArray[2 * i] = shortArray[i] & 0xff;
            byteArray[2 * i + 1] = shortArray[i] >> 8;
        }
        return byteArray;
    }
    converters.shortArrayToByteArray = shortArrayToByteArray;
    function shortArrayToHexString(ary) {
        var res = [];
        for (var i = 0; i < ary.length; i++) {
            res.push(nibbleToChar[(ary[i] >> 4) & 0x0f], nibbleToChar[ary[i] & 0x0f], nibbleToChar[(ary[i] >> 12) & 0x0f], nibbleToChar[(ary[i] >> 8) & 0x0f]);
        }
        return res.join("");
    }
    converters.shortArrayToHexString = shortArrayToHexString;
    function int32ToBytes(x, opt_bigEndian) {
        return intToBytes_(x, 4, 4294967295, opt_bigEndian);
    }
    converters.int32ToBytes = int32ToBytes;
    function intToBytes_(x, numBytes, unsignedMax, opt_bigEndian) {
        var signedMax = Math.floor(unsignedMax / 2);
        var negativeMax = (signedMax + 1) * -1;
        if (x != Math.floor(x) || x < negativeMax || x > unsignedMax) {
            throw new Error(x + ' is not a ' + (numBytes * 8) + ' bit integer');
        }
        var bytes = [];
        var current;
        var numberType = x >= 0 && x <= signedMax ? 0 :
            x > signedMax && x <= unsignedMax ? 1 : 2;
        if (numberType == 2) {
            x = (x * -1) - 1;
        }
        for (var i = 0; i < numBytes; i++) {
            if (numberType == 2) {
                current = 255 - (x % 256);
            }
            else {
                current = x % 256;
            }
            if (opt_bigEndian) {
                bytes.unshift(current);
            }
            else {
                bytes.push(current);
            }
            if (numberType == 1) {
                x = Math.floor(x / 256);
            }
            else {
                x = x >> 8;
            }
        }
        return bytes;
    }
    function arrayBufferToString(buf) {
        return new TextDecoder().decode(buf);
    }
    converters.arrayBufferToString = arrayBufferToString;
    function stringToArrayBuffer(str) {
        return new TextEncoder().encode(str);
    }
    converters.stringToArrayBuffer = stringToArrayBuffer;
    function concatenate(buffer1, buffer2) {
        var temp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
        temp.set(new Uint8Array(buffer1), 0);
        temp.set(new Uint8Array(buffer2), buffer1.byteLength);
        return temp.buffer;
    }
    converters.concatenate = concatenate;
})(converters || (converters = {}));
var heat;
(function (heat) {
    var crypto;
    (function (crypto_1) {
        var _hash = {
            init: SHA256_init,
            update: SHA256_write,
            getBytes: SHA256_finalize
        };
        crypto_1.SHA256 = _hash;
        function simpleHash(message) {
            _hash.init();
            _hash.update(message);
            return _hash.getBytes();
        }
        function curve25519_clamp(curve) {
            curve[0] &= 0xFFF8;
            curve[15] &= 0x7FFF;
            curve[15] |= 0x4000;
            return curve;
        }
        function calculateStringHash(inputString) {
            var hexString = converters.stringToHexString(inputString);
            var bytes = converters.hexStringToByteArray(hexString);
            var hashBytes = simpleHash(bytes);
            return converters.byteArrayToHexString(hashBytes);
        }
        crypto_1.calculateStringHash = calculateStringHash;
        function byteArrayToBigInteger(byteArray, startIndex) {
            var value = new BigInteger("0", 10);
            var temp1, temp2;
            for (var i = byteArray.length - 1; i >= 0; i--) {
                temp1 = value.multiply(new BigInteger("256", 10));
                temp2 = temp1.add(new BigInteger(byteArray[i].toString(10), 10));
                value = temp2;
            }
            return value;
        }
        function calculateFullHash(unsignedTransaction, signature) {
            var unsignedTransactionBytes = converters.hexStringToByteArray(unsignedTransaction);
            var signatureBytes = converters.hexStringToByteArray(signature);
            var signatureHash = simpleHash(signatureBytes);
            _hash.init();
            _hash.update(unsignedTransactionBytes);
            _hash.update(signatureHash);
            var fullHash = _hash.getBytes();
            return converters.byteArrayToHexString(fullHash);
        }
        crypto_1.calculateFullHash = calculateFullHash;
        function fullNameToHash(fullNameUTF8) {
            _hash.init();
            _hash.update(converters.stringToByteArray(fullNameUTF8));
            var slice = (converters.hexStringToByteArray(converters.byteArrayToHexString(_hash.getBytes()))).slice(0, 8);
            return byteArrayToBigInteger(slice).toString();
        }
        crypto_1.fullNameToHash = fullNameToHash;
        function calculateTransactionId(fullHashHex) {
            var slice = (converters.hexStringToByteArray(fullHashHex)).slice(0, 8);
            var transactionId = byteArrayToBigInteger(slice).toString();
            return transactionId;
        }
        crypto_1.calculateTransactionId = calculateTransactionId;
        function secretPhraseToPublicKey(secretPhrase) {
            var secretHex = converters.stringToHexString(secretPhrase);
            var secretPhraseBytes = converters.hexStringToByteArray(secretHex);
            var digest = simpleHash(secretPhraseBytes);
            return converters.byteArrayToHexString(curve25519.keygen(digest).p);
        }
        crypto_1.secretPhraseToPublicKey = secretPhraseToPublicKey;
        function hash(text) {
            var textBytes = converters.hexStringToByteArray(converters.stringToHexString(text));
            var digest = simpleHash(textBytes);
            return converters.byteArrayToHexString(digest);
        }
        crypto_1.hash = hash;
        function getPrivateKey(secretPhrase) {
            SHA256_init();
            SHA256_write(converters.stringToByteArray(secretPhrase));
            return converters.shortArrayToHexString(curve25519_clamp(converters.byteArrayToShortArray(SHA256_finalize())));
        }
        crypto_1.getPrivateKey = getPrivateKey;
        function getAccountId(secretPhrase) {
            var publicKey = this.secretPhraseToPublicKey(secretPhrase);
            return this.getAccountIdFromPublicKey(publicKey);
        }
        crypto_1.getAccountId = getAccountId;
        function getAccountIdFromPublicKey(publicKey) {
            _hash.init();
            _hash.update(converters.hexStringToByteArray(publicKey));
            var account = _hash.getBytes();
            var slice = (converters.hexStringToByteArray(converters.byteArrayToHexString(account))).slice(0, 8);
            return byteArrayToBigInteger(slice).toString();
        }
        crypto_1.getAccountIdFromPublicKey = getAccountIdFromPublicKey;
        function signBytes(message, secretPhrase) {
            var messageBytes = converters.hexStringToByteArray(message);
            var secretPhraseBytes = converters.hexStringToByteArray(secretPhrase);
            var digest = simpleHash(secretPhraseBytes);
            var s = curve25519.keygen(digest).s;
            var m = simpleHash(messageBytes);
            _hash.init();
            _hash.update(m);
            _hash.update(s);
            var x = _hash.getBytes();
            var y = curve25519.keygen(x).p;
            _hash.init();
            _hash.update(m);
            _hash.update(y);
            var h = _hash.getBytes();
            var v = curve25519.sign(h, x, s);
            return converters.byteArrayToHexString(v.concat(h));
        }
        crypto_1.signBytes = signBytes;
        function verifyBytes(signature, message, publicKey) {
            var signatureBytes = converters.hexStringToByteArray(signature);
            var messageBytes = converters.hexStringToByteArray(message);
            var publicKeyBytes = converters.hexStringToByteArray(publicKey);
            var v = signatureBytes.slice(0, 32);
            var h = signatureBytes.slice(32);
            var y = curve25519.verify(v, h, publicKeyBytes);
            var m = simpleHash(messageBytes);
            _hash.init();
            _hash.update(m);
            _hash.update(y);
            var h2 = _hash.getBytes();
            return areByteArraysEqual(h, h2);
        }
        crypto_1.verifyBytes = verifyBytes;
        function areByteArraysEqual(bytes1, bytes2) {
            if (bytes1.length !== bytes2.length) {
                return false;
            }
            for (var i = 0; i < bytes1.length; ++i) {
                if (bytes1[i] !== bytes2[i])
                    return false;
            }
            return true;
        }
        function encryptNote(message, options, secretPhrase, uncompressed) {
            if (!options.sharedKey) {
                if (!options.privateKey) {
                    options.privateKey = converters.hexStringToByteArray(this.getPrivateKey(secretPhrase));
                }
                if (!options.publicKey) {
                    throw new Error('Missing publicKey argument');
                }
            }
            var encrypted = encryptData(converters.stringToByteArray(message), options, uncompressed);
            return {
                "message": converters.byteArrayToHexString(encrypted.data),
                "nonce": converters.byteArrayToHexString(encrypted.nonce)
            };
        }
        crypto_1.encryptNote = encryptNote;
        function encryptBinaryNote(message, options, secretPhrase, uncompressed) {
            if (!options.sharedKey) {
                if (!options.privateKey) {
                    options.privateKey = converters.hexStringToByteArray(this.getPrivateKey(secretPhrase));
                }
                if (!options.publicKey) {
                    throw new Error('Missing publicKey argument');
                }
            }
            var encrypted = encryptData(message, options, uncompressed);
            return {
                "message": converters.byteArrayToHexString(encrypted.data),
                "nonce": converters.byteArrayToHexString(encrypted.nonce)
            };
        }
        crypto_1.encryptBinaryNote = encryptBinaryNote;
        function encryptBinary(buffer, options, uncompressed) {
            var crypto = window.crypto || window['msCrypto'];
            if (!crypto)
                throw new Error("Browser not supported");
            if (!options.sharedKey)
                options.sharedKey = getSharedKey(options.privateKey, options.publicKey);
            options.nonce = new Uint8Array(32);
            crypto.getRandomValues(options.nonce);
            var compressedData = uncompressed ? new Uint8Array(buffer) : pako.gzip(new Uint8Array(buffer));
            var data = aesEncrypt(compressedData, options);
            return {
                isText: false,
                data: converters.byteArrayToHexString(data),
                nonce: converters.byteArrayToHexString(options.nonce)
            };
        }
        crypto_1.encryptBinary = encryptBinary;
        function getSharedKey(key1, key2) {
            return converters.shortArrayToByteArray(curve25519_(converters.byteArrayToShortArray(key1), converters.byteArrayToShortArray(key2), null));
        }
        crypto_1.getSharedKey = getSharedKey;
        function encryptData(plaintext, options, uncompressed) {
            var crypto = window.crypto || window['msCrypto'];
            if (!crypto) {
                throw new Error("Browser not supported");
            }
            if (!options.sharedKey) {
                options.sharedKey = getSharedKey(options.privateKey, options.publicKey);
            }
            options.nonce = new Uint8Array(32);
            crypto.getRandomValues(options.nonce);
            var compressedPlaintext = uncompressed ? new Uint8Array(plaintext) : pako.gzip(new Uint8Array(plaintext));
            var data = aesEncrypt(compressedPlaintext, options);
            return {
                "nonce": options.nonce,
                "data": data
            };
        }
        function aesEncrypt(plaintext, options) {
            var crypto = window.crypto || window['msCrypto'];
            var text = converters.byteArrayToWordArray(plaintext);
            var sharedKey = options.sharedKey ? options.sharedKey.slice(0) :
                getSharedKey(options.privateKey, options.publicKey);
            for (var i = 0; i < 32; i++) {
                sharedKey[i] ^= options.nonce[i];
            }
            var tmp = new Uint8Array(16);
            crypto.getRandomValues(tmp);
            var key = CryptoJS.SHA256(converters.byteArrayToWordArray(sharedKey));
            var iv = converters.byteArrayToWordArray(tmp);
            var encrypted = CryptoJS.AES.encrypt(text, key, {
                iv: iv
            });
            var ivOut = converters.wordArrayToByteArray(encrypted.iv);
            var ciphertextOut = converters.wordArrayToByteArray(encrypted.ciphertext);
            return ivOut.concat(ciphertextOut);
        }
        function encryptMessage(message, publicKey, secretPhrase, uncompressed) {
            var options = {
                "account": crypto.getAccountIdFromPublicKey(publicKey),
                "publicKey": converters.hexStringToByteArray(publicKey)
            };
            var encrypted = heat.crypto.encryptNote(message, options, secretPhrase, uncompressed);
            return {
                isText: true,
                data: encrypted.message,
                nonce: encrypted.nonce
            };
        }
        crypto_1.encryptMessage = encryptMessage;
        function decryptMessage(data, nonce, publicKey, secretPhrase, uncompressed) {
            return decrypt(decryptData, data, nonce, publicKey, secretPhrase, uncompressed);
        }
        crypto_1.decryptMessage = decryptMessage;
        function decryptBinary(data, nonce, publicKey, secretPhrase, uncompressed) {
            return decrypt(decryptBinaryData, data, nonce, publicKey, secretPhrase, uncompressed);
        }
        crypto_1.decryptBinary = decryptBinary;
        function decrypt(decryptFunction, data, nonce, publicKey, secretPhrase, uncompressed) {
            var privateKey = converters.hexStringToByteArray(getPrivateKey(secretPhrase));
            var publicKeyBytes = converters.hexStringToByteArray(publicKey);
            var sharedKey = getSharedKey(privateKey, publicKeyBytes);
            var dataBytes = converters.hexStringToByteArray(data);
            var options = {
                privateKey: privateKey,
                publicKey: publicKeyBytes,
                nonce: converters.hexStringToByteArray(nonce),
                sharedKey: sharedKey
            };
            try {
                return decryptFunction(dataBytes, options, uncompressed);
            }
            catch (e) {
                if (e instanceof RangeError || e == 'incorrect header check') {
                    console.error('Managed Exception: ' + e);
                    return decryptFunction(dataBytes, options, !uncompressed);
                }
                throw e;
            }
        }
        function decryptData(data, options, uncompressed) {
            var decrypted = aesDecrypt(data, options);
            var binData = new Uint8Array(decrypted);
            return converters.byteArrayToString(uncompressed ? binData : pako.inflate(binData));
        }
        function decryptBinaryData(data, options, uncompressed) {
            var decrypted = aesDecrypt(data, options);
            var binData = new Uint8Array(decrypted);
            return uncompressed ? binData : pako.inflate(binData);
        }
        function aesDecrypt(ivCiphertext, options) {
            if (ivCiphertext.length < 16 || ivCiphertext.length % 16 != 0) {
                throw { name: "invalid ciphertext" };
            }
            var iv = converters.byteArrayToWordArray(ivCiphertext.slice(0, 16));
            var ciphertext = converters.byteArrayToWordArray(ivCiphertext.slice(16));
            var sharedKey = options.sharedKey.slice(0);
            for (var i = 0; i < 32; i++) {
                sharedKey[i] ^= options.nonce[i];
            }
            var key = CryptoJS.SHA256(converters.byteArrayToWordArray(sharedKey));
            var encrypted = CryptoJS.lib.CipherParams.create({
                ciphertext: ciphertext,
                iv: iv,
                key: key
            });
            var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
                iv: iv
            });
            var plaintext = converters.wordArrayToByteArray(decrypted);
            return plaintext;
        }
        var PassphraseEncryptedMessage = (function () {
            function PassphraseEncryptedMessage(ciphertext, salt, iv, HMAC) {
                this.ciphertext = ciphertext;
                this.salt = salt;
                this.iv = iv;
                this.HMAC = HMAC;
            }
            PassphraseEncryptedMessage.decode = function (encoded) {
                var json = JSON.parse(encoded);
                return new PassphraseEncryptedMessage(json[0], json[1], json[2], json[3]);
            };
            PassphraseEncryptedMessage.prototype.encode = function () {
                return JSON.stringify([
                    this.ciphertext,
                    this.salt,
                    this.iv,
                    this.HMAC
                ]);
            };
            return PassphraseEncryptedMessage;
        }());
        crypto_1.PassphraseEncryptedMessage = PassphraseEncryptedMessage;
        function passphraseEncrypt(message, passphrase) {
            var salt = CryptoJS.lib.WordArray.random(256 / 8);
            var key = CryptoJS.PBKDF2(passphrase, salt, { iterations: 10, hasher: CryptoJS.algo.SHA256 });
            var iv = CryptoJS.lib.WordArray.random(128 / 8);
            var encrypted = CryptoJS.AES.encrypt(message, key, { iv: iv });
            var ciphertext = CryptoJS.enc.Base64.stringify(encrypted.ciphertext);
            var salt_str = CryptoJS.enc.Hex.stringify(salt);
            var iv_str = CryptoJS.enc.Hex.stringify(iv);
            var key_str = CryptoJS.enc.Hex.stringify(key);
            var HMAC = CryptoJS.HmacSHA256(ciphertext + iv_str, key_str);
            var HMAC_str = CryptoJS.enc.Hex.stringify(HMAC);
            return new PassphraseEncryptedMessage(ciphertext, salt_str, iv_str, HMAC_str);
        }
        crypto_1.passphraseEncrypt = passphraseEncrypt;
        function passphraseDecrypt(cp, passphrase) {
            var iv = CryptoJS.enc.Hex.parse(cp.iv);
            var salt = CryptoJS.enc.Hex.parse(cp.salt);
            var key = CryptoJS.PBKDF2(passphrase, salt, { iterations: 10, hasher: CryptoJS.algo.SHA256 });
            var ciphertext = CryptoJS.enc.Base64.parse(cp.ciphertext);
            var key_str = CryptoJS.enc.Hex.stringify(key);
            var HMAC = CryptoJS.HmacSHA256(cp.ciphertext + cp.iv, key_str);
            var HMAC_str = CryptoJS.enc.Hex.stringify(HMAC);
            if (HMAC_str != cp.HMAC) {
                return null;
            }
            var _cp = CryptoJS.lib.CipherParams.create({
                ciphertext: ciphertext
            });
            var decrypted = CryptoJS.AES.decrypt(_cp, key, { iv: iv });
            return decrypted.toString(CryptoJS.enc.Utf8);
        }
        crypto_1.passphraseDecrypt = passphraseDecrypt;
    })(crypto = heat.crypto || (heat.crypto = {}));
})(heat || (heat = {}));
var heat;
(function (heat) {
    var easing;
    (function (easing) {
        function linear(t) { return t; }
        easing.linear = linear;
        function easeInQuad(t) { return t * t; }
        easing.easeInQuad = easeInQuad;
        function easeOutQuad(t) { return t * (2 - t); }
        easing.easeOutQuad = easeOutQuad;
        function easeInOutQuad(t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }
        easing.easeInOutQuad = easeInOutQuad;
        function easeInCubic(t) { return t * t * t; }
        easing.easeInCubic = easeInCubic;
        function easeOutCubic(t) { return (--t) * t * t + 1; }
        easing.easeOutCubic = easeOutCubic;
        function easeInOutCubic(t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; }
        easing.easeInOutCubic = easeInOutCubic;
        function easeInQuart(t) { return t * t * t * t; }
        easing.easeInQuart = easeInQuart;
        function easeOutQuart(t) { return 1 - (--t) * t * t * t; }
        easing.easeOutQuart = easeOutQuart;
        function easeInOutQuart(t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t; }
        easing.easeInOutQuart = easeInOutQuart;
        function easeInQuint(t) { return t * t * t * t * t; }
        easing.easeInQuint = easeInQuint;
        function easeOutQuint(t) { return 1 + (--t) * t * t * t * t; }
        easing.easeOutQuint = easeOutQuint;
        function easeInOutQuint(t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; }
        easing.easeInOutQuint = easeInOutQuint;
    })(easing = heat.easing || (heat.easing = {}));
})(heat || (heat = {}));
var EventEmitter = (function () {
    function EventEmitter() {
        this.cache = new EventEmitterCache();
    }
    EventEmitter.prototype.addListener = function (event, listener) {
        this.cache.add(event, listener);
    };
    EventEmitter.prototype.removeListener = function (event, listener) {
        this.cache.remove(event, listener);
    };
    EventEmitter.prototype.on = function (event, listener) {
        this.addListener(event, listener);
    };
    EventEmitter.prototype.removeAllListeners = function (event) {
        var _this = this;
        if (angular.isDefined(event)) {
            this.cache.get(event).forEach(function (listener) {
                _this.cache.remove(event, listener);
            });
        }
        else {
            this.cache.clear();
        }
    };
    EventEmitter.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.cache.get(event).forEach(function (listener) {
            listener.apply(null, args);
        });
    };
    return EventEmitter;
}());
var EventEmitterCache = (function () {
    function EventEmitterCache() {
        this.cache = {};
    }
    EventEmitterCache.prototype.clear = function () {
        this.cache = {};
    };
    EventEmitterCache.prototype.add = function (event, listener) {
        if (!angular.isDefined(this.cache[event])) {
            this.cache[event] = [];
        }
        this.cache[event].push(listener);
    };
    EventEmitterCache.prototype.remove = function (event, listener) {
        if (angular.isDefined(this.cache[event])) {
            this.cache[event] = this.cache[event].filter(function (l) { return l != listener; });
            if (this.cache[event].length === 0) {
                delete this.cache[event];
            }
        }
    };
    EventEmitterCache.prototype.get = function (event) {
        return this.cache[event] || [];
    };
    return EventEmitterCache;
}());
heat.Loader.directive('inputClear', function () {
    return {
        restrict: 'A',
        compile: function (element, attrs) {
            var color = attrs.inputClear;
            var action = attrs.ngModel + " = ''";
            element.after('<md-button aria-label="Close" class="animate-show md-icon-button md-accent"' +
                'ng-show="' + attrs.ngModel + '" ng-click="' + action + '"' +
                'style="position: absolute; top: 0px; right: -2px; margin-right:0px;">' +
                '<md-icon style="color:black;font-size: 18px;" md-font-library="material-icons">close</md-icon>' +
                '</md-button>');
        }
    };
});
var heat;
(function (heat) {
    var Iterator = (function () {
        function Iterator(array) {
            this.array = array;
            this.cursor = 0;
        }
        Iterator.prototype.hasMore = function () {
            return this.cursor < this.array.length;
        };
        Iterator.prototype.next = function () {
            return this.array[this.cursor++];
        };
        Iterator.prototype.peek = function () {
            return this.array[this.cursor];
        };
        return Iterator;
    }());
    heat.Iterator = Iterator;
})(heat || (heat = {}));
if (!Array.prototype['find']) {
    Array.prototype['find'] = function (predicate) {
        if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;
        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}
if (!String.prototype['repeat']) {
    String.prototype['repeat'] = function (count) {
        'use strict';
        if (this == null) {
            throw new TypeError('can\'t convert ' + this + ' to object');
        }
        var str = '' + this;
        count = +count;
        if (count != count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length == 0 || count == 0) {
            return '';
        }
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) == 1) {
                rpt += str;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            str += str;
        }
        return rpt;
    };
}
var utils;
(function (utils) {
    function unformat(commaFormatted) {
        return commaFormatted ? commaFormatted.replace(/,/g, "") : "0";
    }
    utils.unformat = unformat;
    function commaFormat(amount) {
        if (typeof amount == 'undefined') {
            return '0';
        }
        amount = amount.replace(/,/g, '');
        var neg = amount.indexOf('-') == 0;
        if (neg) {
            amount = amount.substr(1);
        }
        amount = amount.split('.');
        var parts = amount[0].split("").reverse().join("").split(/(\d{3})/).reverse();
        var format = [];
        for (var i = 0; i < parts.length; i++) {
            if (parts[i]) {
                format.push(parts[i].split('').reverse().join(''));
            }
        }
        return (neg ? '-' : '') + format.join(',') + (amount.length == 2 ? ('.' + amount[1]) : '');
    }
    utils.commaFormat = commaFormat;
    function isNumber(value) {
        var num = String(value).replace(/,/g, '');
        if (num.match(/^\d+$/)) {
            return true;
        }
        else if (num.match(/^\d+\.\d+$/)) {
            return true;
        }
        return false;
    }
    utils.isNumber = isNumber;
    function isHex(value) {
        if (!angular.isString(value))
            return false;
        var s = value.startsWith("0x") ? value.substr(2) : value;
        return (/^[0-9a-fA-F]+$/.test(s));
    }
    utils.isHex = isHex;
    function isTimeWithinThreasholdLimit(inputTime) {
        return ((inputTime * 1000) + 6 * 60 * 60 * 1000) > new Date().getTime();
    }
    utils.isTimeWithinThreasholdLimit = isTimeWithinThreasholdLimit;
    function hasToManyDecimals(value, decimals) {
        var num = String(value).replace(/,/g, '');
        var parts = num.split(".");
        if (parts[1]) {
            var fractional = parts[1].replace(/[\s0]*$/g, "");
            if (fractional.length > decimals)
                return true;
        }
        return false;
    }
    utils.hasToManyDecimals = hasToManyDecimals;
    function parseResponse(response) {
        var parsed = {};
        if (angular.isString(response)) {
            try {
                parsed = JSON.parse(response);
            }
            catch (e) {
                parsed = { heatUtilParsingError: response || e.toString() };
            }
        }
        else {
            parsed = response;
        }
        return parsed;
    }
    utils.parseResponse = parseResponse;
    function ardorTimestampToDate(timestamp) {
        return new Date(Date.UTC(2018, 0, 1, 0, 0, 0, 0) + timestamp * 1000);
    }
    utils.ardorTimestampToDate = ardorTimestampToDate;
    function nemTimestampToDate(timestamp) {
        return new Date(Date.UTC(2015, 2, 29, 0, 5, 36, 25) + timestamp * 1000);
    }
    utils.nemTimestampToDate = nemTimestampToDate;
    var BASE_DATE;
    function isBaseDate() {
        return !!BASE_DATE;
    }
    utils.isBaseDate = isBaseDate;
    function setBaseTimestamp(timestamp) {
        BASE_DATE = timestamp;
    }
    utils.setBaseTimestamp = setBaseTimestamp;
    function timestampToDate(timestamp) {
        return new Date(BASE_DATE + timestamp * 1000);
    }
    utils.timestampToDate = timestampToDate;
    function epochTime(timestamp) {
        var t = timestamp ? timestamp : Date.now();
        return (t - BASE_DATE + 500) / 1000;
    }
    utils.epochTime = epochTime;
    function isAssetExpired(assetExpiration) {
        return assetExpiration ? assetExpiration <= epochTime() : false;
    }
    utils.isAssetExpired = isAssetExpired;
    function roundTo(value, decimals) {
        return String(parseFloat(value).toFixed(decimals));
    }
    utils.roundTo = roundTo;
    function delayPromise(promise, delay) {
        var $q = heat.$inject.get('$q');
        var deferred = $q.defer();
        var result, resolved = false, rejected = false;
        var timeout = setTimeout(function () {
            timeout = null;
            if (resolved) {
                deferred.resolve(result);
            }
            else if (rejected) {
                deferred.reject(result);
            }
        }, delay);
        promise.then(function (r) {
            result = r;
            resolved = true;
            if (timeout === null) {
                deferred.resolve(r);
            }
        }, function (r) {
            result = r;
            rejected = true;
            if (timeout === null) {
                deferred.reject(r);
            }
        });
        return deferred.promise;
    }
    utils.delayPromise = delayPromise;
    var timeoutError = new Error("promise time is up");
    function timeoutPromise(promise, time) {
        var timer;
        return Promise.race([
            promise,
            new Promise(function (resolve, reject) { return timer = setTimeout(reject, time, timeoutError); })
        ]).finally(function () { return clearTimeout(timer); });
    }
    utils.timeoutPromise = timeoutPromise;
    function convertToNQT(amountNXT) {
        if (typeof amountNXT == 'undefined') {
            return '0';
        }
        amountNXT = String(amountNXT).replace(/,/g, '');
        var parts = amountNXT.split(".");
        var amount = parts[0];
        if (parts.length == 1) {
            var fraction;
            fraction = "00000000";
        }
        else if (parts.length == 2) {
            if (parts[1].length <= 8) {
                var fraction = parts[1];
            }
            else {
                var fraction = parts[1].substring(0, 8);
            }
        }
        else {
            throw "Invalid input";
        }
        for (var i = fraction.length; i < 8; i++) {
            fraction += "0";
        }
        var result = amount + "" + fraction;
        if (!/^\d+$/.test(result)) {
            throw "Invalid input.";
        }
        result = result.replace(/^0+/, "");
        if (result === "") {
            result = "0";
        }
        return result;
    }
    utils.convertToNQT = convertToNQT;
    function formatQNT(quantity, decimals, returnNullZero) {
        var asfloat = utils.convertToQNTf(quantity);
        var cf = utils.commaFormat(asfloat);
        var parts = cf.split('.');
        var result;
        if (!parts[1]) {
            result = parts[0] + (decimals > 0 ? "." + "0".repeat(decimals) : "");
        }
        else if (parts[1].length > decimals) {
            var i = parts[1].length - 1;
            while (parts[1].length > decimals) {
                if (parts[1][i] == "0") {
                    parts[1] = parts[i].slice(0, -1);
                    i--;
                    continue;
                }
                break;
            }
            result = parts[0] + "." + parts[1];
        }
        else {
            result = parts[0] + "." + parts[1] + "0".repeat(decimals - parts[1].length);
        }
        return returnNullZero && !result.match(/[^0\.]/) ? null : result;
    }
    utils.formatQNT = formatQNT;
    function formatBytes(bytes, decimals) {
        if (decimals === void 0) { decimals = 2; }
        if (!+bytes)
            return '0 Bytes';
        var k = 1024;
        var dm = decimals < 0 ? 0 : decimals;
        var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        var i = Math.floor(Math.log(bytes) / Math.log(k));
        return "".concat(parseFloat((bytes / Math.pow(k, i)).toFixed(dm)), " ").concat(sizes[i]);
    }
    utils.formatBytes = formatBytes;
    function formatERC20TokenAmount(amount, decimals, fixed) {
        if (decimals == 0)
            return amount;
        var s = amount.padStart(amount.length > decimals ? decimals : decimals + 1, "0");
        var decimalPos = s.length - decimals;
        var decimalPart = s.substr(decimalPos, s.length);
        if (!fixed) {
            var tailZeroCount = 0;
            for (var i = decimalPart.length - 1; i >= 0; i--) {
                if (decimalPart[i] == "0") {
                    tailZeroCount++;
                }
                else {
                    break;
                }
            }
            decimalPart = decimalPart.substr(0, decimalPart.length - tailZeroCount);
        }
        var integerPart = utils.commaFormat(s.substr(0, decimalPos) || "0");
        return integerPart + (decimalPart ? numberSeparator.decimal + decimalPart : "");
    }
    utils.formatERC20TokenAmount = formatERC20TokenAmount;
    var numberSeparator = { decimal: getSeparator("decimal", "EN-en"), group: getSeparator("group", "EN-en") };
    function getSeparator(separatorType, locale) {
        var numberWithGroupAndDecimalSeparator = 1000.1;
        return Intl.NumberFormat(locale)
            .formatToParts(numberWithGroupAndDecimalSeparator)
            .find(function (part) { return part.type === separatorType; })
            .value;
    }
    function trimDecimals(formatted, decimals) {
        var parts = formatted.split(".");
        if (!parts[1])
            parts[1] = "0".repeat(decimals);
        else
            parts[1] = parts[1].substr(0, decimals);
        if (parts[1].length < decimals)
            parts[1] += "0".repeat(decimals - parts[1].length);
        return parts[0] + "." + parts[1];
    }
    utils.trimDecimals = trimDecimals;
    function convertToQNTf(quantity, decimals) {
        if (decimals === void 0) { decimals = 8; }
        if (typeof quantity == 'undefined')
            return '0';
        if (typeof quantity == 'number')
            quantity = "" + quantity;
        if (quantity.length < decimals) {
            for (var i = quantity.length; i < decimals; i++) {
                quantity = "0" + quantity;
            }
        }
        var afterComma = "";
        if (decimals) {
            afterComma = "." + quantity.substring(quantity.length - decimals);
            quantity = quantity.substring(0, quantity.length - decimals);
            if (!quantity) {
                quantity = "0";
            }
            afterComma = afterComma.replace(/0+$/, "");
            if (afterComma == ".") {
                afterComma = "";
            }
        }
        return quantity + afterComma;
    }
    utils.convertToQNTf = convertToQNTf;
    var DIVIDER_100_MILIONS = new Big(100000000);
    function calculateTotalOrderPriceQNT(quantityQNT, priceQNT) {
        return new Big(quantityQNT).times(new Big(priceQNT).div(DIVIDER_100_MILIONS)).round().toString();
    }
    utils.calculateTotalOrderPriceQNT = calculateTotalOrderPriceQNT;
    var ConvertToQNTError = (function () {
        function ConvertToQNTError(message, code) {
            this.message = message;
            this.code = code;
            this.name = "ConvertToQNTError";
        }
        return ConvertToQNTError;
    }());
    utils.ConvertToQNTError = ConvertToQNTError;
    var ALL_ASSETS_DECIMALS = 8;
    function convertToQNT(quantity, decimals) {
        if (decimals === void 0) { decimals = 8; }
        var parts = quantity.split(".");
        var qnt = parts[0];
        if (parts.length == 1) {
            for (var i = 0; i < ALL_ASSETS_DECIMALS; i++) {
                qnt += "0";
            }
        }
        else if (parts.length == 2) {
            var fraction = parts[1];
            if (fraction.length > ALL_ASSETS_DECIMALS) {
                throw new ConvertToQNTError("Fraction can only have " + ALL_ASSETS_DECIMALS + " decimals max.", 1);
            }
            else if (fraction.length < ALL_ASSETS_DECIMALS) {
                for (var i = fraction.length; i < ALL_ASSETS_DECIMALS; i++) {
                    fraction += "0";
                }
            }
            qnt += fraction;
        }
        else {
            throw new ConvertToQNTError("Incorrect input", 2);
        }
        if (!/^\d+$/.test(qnt)) {
            throw new ConvertToQNTError("Invalid input. Only numbers and a dot are accepted.", 3);
        }
        var result = qnt.replace(/^0+/, "");
        var lastZeros = ALL_ASSETS_DECIMALS - decimals;
        return result.length > lastZeros
            ? result.substr(0, result.length - lastZeros) + '0'.repeat(lastZeros)
            : result;
    }
    utils.convertToQNT = convertToQNT;
    function getByteLen(value) {
        var byteLen = 0;
        for (var i = 0; i < value.length; i++) {
            var c = value.charCodeAt(i);
            byteLen += c < (1 << 7) ? 1 :
                c < (1 << 11) ? 2 :
                    c < (1 << 16) ? 3 :
                        c < (1 << 21) ? 4 :
                            c < (1 << 26) ? 5 :
                                c < (1 << 31) ? 6 : Number.NaN;
        }
        return byteLen;
    }
    utils.getByteLen = getByteLen;
    function debounce(func, wait, immediate) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate)
                    func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait || 100);
            if (callNow)
                func.apply(context, args);
        };
    }
    utils.debounce = debounce;
    ;
    function repeatWhile(delay, cb) {
        var fn = function () {
            if (cb()) {
                clearInterval(interval);
            }
        };
        var interval = setInterval(fn, delay);
    }
    utils.repeatWhile = repeatWhile;
    function emptyToNull(input) {
        return (angular.isString(input) && input.trim().length == 0) ? null : input;
    }
    utils.emptyToNull = emptyToNull;
    function uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function (c) {
            return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16);
        });
    }
    utils.uuidv4 = uuidv4;
    utils.helper = {
        useLocalServer: function () {
            heat.$inject.get('heat').switchToServer({ way: "local", failoverEnabled: false, sameMessagingHost: false });
        },
        useRemoteServer: function (serverDescriptor) {
            heat.$inject.get('heat').switchToServer({ way: "remote", failoverEnabled: true, sameMessagingHost: false }, serverDescriptor);
        },
    };
})(utils || (utils = {}));
var AbiDecoderService = (function () {
    function AbiDecoderService(web3, $window) {
        this.web3 = web3;
        this.$window = $window;
        this.state = {
            savedABIs: [],
            methodIDs: {}
        };
        this.Web3 = $window.heatlibs.Web3;
        this.SolidityCoder = $window.heatlibs.__SolidityCoder;
    }
    AbiDecoderService.prototype.getABIs = function () {
        return this.state.savedABIs;
    };
    AbiDecoderService.prototype.addABI = function (abiArray) {
        var _this = this;
        if (Array.isArray(abiArray)) {
            abiArray.map(function (abi) {
                if (abi.name) {
                    var signature = new (_this.Web3)().sha3(abi.name + "(" + abi.inputs.map(function (input) { return input.type; }).join(",") + ")");
                    if (abi.type == "event") {
                        _this.state.methodIDs[signature.slice(2)] = abi;
                    }
                    else {
                        _this.state.methodIDs[signature.slice(2, 10)] = abi;
                    }
                }
            });
            this.state.savedABIs = this.state.savedABIs.concat(abiArray);
        }
        else {
            throw new Error("Expected ABI array, got " + typeof abiArray);
        }
    };
    AbiDecoderService.prototype.removeABI = function (abiArray) {
        var _this = this;
        if (Array.isArray(abiArray)) {
            abiArray.map(function (abi) {
                if (abi.name) {
                    var signature = new (_this.Web3)().sha3(abi.name + "(" + abi.inputs.map(function (input) { return input.type; }).join(",") + ")");
                    if (abi.type == "event") {
                        if (_this.state.methodIDs[signature.slice(2)]) {
                            delete _this.state.methodIDs[signature.slice(2)];
                        }
                    }
                    else {
                        if (_this.state.methodIDs[signature.slice(2, 10)]) {
                            delete _this.state.methodIDs[signature.slice(2, 10)];
                        }
                    }
                }
            });
        }
        else {
            throw new Error("Expected ABI array, got " + typeof abiArray);
        }
    };
    AbiDecoderService.prototype.getMethodIDs = function () {
        return this.state.methodIDs;
    };
    AbiDecoderService.prototype.decodeMethod = function (data) {
        var methodID = data.slice(2, 10);
        var abiItem = this.state.methodIDs[methodID];
        if (abiItem) {
            var params = abiItem.inputs.map(function (item) { return item.type; });
            var decoded = this.SolidityCoder.decodeParams(params, data.slice(10));
            return {
                name: abiItem.name,
                params: decoded.map(function (param, index) {
                    var _this = this;
                    var parsedParam = param;
                    var isUint = abiItem.inputs[index].type.indexOf("uint") == 0;
                    var isInt = abiItem.inputs[index].type.indexOf("int") == 0;
                    if (isUint || isInt) {
                        var isArray = Array.isArray(param);
                        if (isArray) {
                            parsedParam = param.map(function (val) { return new (_this.Web3)().toBigNumber(val).toString(); });
                        }
                        else {
                            parsedParam = new (this.Web3)().toBigNumber(param).toString();
                        }
                    }
                    return {
                        name: abiItem.inputs[index].name,
                        value: parsedParam,
                        type: abiItem.inputs[index].type
                    };
                })
            };
        }
    };
    AbiDecoderService.prototype.padZeros = function (address) {
        var formatted = address;
        if (address.indexOf('0x') != -1) {
            formatted = address.slice(2);
        }
        if (formatted.length < 40) {
            while (formatted.length < 40)
                formatted = "0" + formatted;
        }
        return "0x" + formatted;
    };
    AbiDecoderService = __decorate([
        Service('abiDecoder'),
        Inject('web3', '$window'),
        __metadata("design:paramtypes", [Web3Service, Object])
    ], AbiDecoderService);
    return AbiDecoderService;
}());
var AbstractDataProvider = (function () {
    function AbstractDataProvider() {
        this.providers = [];
        this.isLoading = false;
    }
    AbstractDataProvider.prototype.createProvider = function ($scope) {
        var _this = this;
        var provider = new DataProvider($scope);
        provider.data = this.getInitialData();
        this.providers.push(provider);
        $scope.$on('$destroy', function () { _this.destroyProvider(provider); });
        if (!this.isLoading) {
            provider.update(this.data);
        }
        return provider;
    };
    AbstractDataProvider.prototype.destroyProvider = function (provider) {
        this.providers = this.providers.filter(function (p) { return p != provider; });
    };
    AbstractDataProvider.prototype.refresh = function () {
        var _this = this;
        this.providers.forEach(function (provider) { provider.refreshBegin(); });
        this.isLoading = true;
        this.getData().then(function (data) {
            _this.isLoading = false;
            _this.data = data;
            _this.providers.forEach(function (provider) { provider.update(data); });
        });
    };
    return AbstractDataProvider;
}());
var DataProvider = (function () {
    function DataProvider($scope) {
        this.$scope = $scope;
        this.loading = true;
    }
    DataProvider.prototype.update = function (data) {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.loading = false;
            _this.data = data;
        });
    };
    DataProvider.prototype.refreshBegin = function () {
        this.loading = true;
        this.$scope.$evalAsync(angular.noop);
    };
    return DataProvider;
}());
var ArdorAssetInfoService = (function () {
    function ArdorAssetInfoService(heat, $q, ardorBlockExplorerService) {
        this.heat = heat;
        this.$q = $q;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.cache = {};
        this.cache["ardor"] = {
            id: "ardor",
            description: "IGNIS Cryptocurrency based on ARDOR platform",
            descriptionUrl: "",
            decimals: 8,
            symbol: "IGNIS",
            name: "IGNIS",
            certified: true,
            timestamp: 100149557,
            issuer: "ARDOR",
            issuerPublicName: "ARDOR"
        };
    }
    ArdorAssetInfoService.prototype.getInfo = function (asset) {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.cache[asset])) {
            deferred.resolve(this.cache[asset]);
        }
        else {
            this.ardorBlockExplorerService.getAssetInfo(asset).then(function (data) {
                var info = {
                    id: asset,
                    description: null,
                    descriptionUrl: data.descriptionUrl,
                    decimals: data.decimals,
                    symbol: data.name,
                    name: data.name,
                    certified: false,
                    timestamp: data.timestamp,
                    issuer: data.account,
                    issuerPublicName: data.accountPublicName
                };
                _this.cache[asset] = info;
                deferred.resolve(info);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    ArdorAssetInfoService = __decorate([
        Service('ardorAssetInfo'),
        Inject('heat', '$q', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [HeatService, Function, ArdorBlockExplorerService])
    ], ArdorAssetInfoService);
    return ArdorAssetInfoService;
}());
var ArdorBlockExplorerService = (function () {
    function ArdorBlockExplorerService($q, http, settingsService) {
        var _this = this;
        this.$q = $q;
        this.http = http;
        this.settingsService = settingsService;
        this.cachedGetCachedAccountBalance = new Map();
        this.getHostUrl = function () {
            return _this.url;
        };
        this.getBlockchainStatus = function () {
            var deferred = _this.$q.defer();
            _this.settingsService.initialized.then(function () {
                _this.setUrl(SettingsService.getCryptoServerEndpoint('ARDR'));
                _this.http.get("".concat(_this.url, "/nxt?requestType=getBlockchainStatus")).then(function (ret) {
                    var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                    if (data) {
                        deferred.resolve(data);
                    }
                    else
                        deferred.reject();
                }).catch(function () { return deferred.reject(); });
            });
            return deferred.promise;
        };
        this.getTransactions = function (account, firstIndex, lastIndex) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getBlockchainTransactions&account=").concat(account, "&firstIndex=").concat(firstIndex, "&lastIndex=").concat(lastIndex, "&chain=1")).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.transactions) {
                    deferred.resolve(data.transactions);
                }
                else
                    deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactionsCount = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getBlockchainTransactions&account=").concat(account, "&lastIndex=-1&chain=1")).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.transactions)
                    deferred.resolve(data.transactions.length);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.sendArdr = function (txObject) {
            var deferred = _this.$q.defer();
            _this.http.post(_this.url + txObject, {}).then(function (ret) {
                var userService = heat.$inject.get('user');
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.errorDescription) {
                    deferred.reject(data.errorDescription);
                }
                var attachment = JSON.stringify(data.transactionJSON.attachment);
                var signature = heat.crypto.signBytes(data.unsignedTransactionBytes, converters.stringToHexString(userService.secretPhrase));
                var payload = data.unsignedTransactionBytes.substr(0, 192) + signature + data.unsignedTransactionBytes.substr(320);
                _this.http.post("".concat(_this.url, "/nxt?requestType=broadcastTransaction&transactionBytes=").concat(payload, "&prunableAttachmentJSON=").concat(attachment), {}).then(function (ret) {
                    var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                    if (data.errorDescription) {
                        deferred.reject(data.errorDescription);
                    }
                    deferred.resolve({ txId: data.transaction });
                });
            }, function (err) {
                deferred.reject(err.errorDescription);
            });
            return deferred.promise;
        };
        this.getTransactionStatus = function (fullHash) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getTransaction&fullHash=").concat(fullHash, "&chain=1")).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (!data.errorDescription)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAccountAssets = function (tx) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getAccountAssets&account=").concat(tx)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.accountAssets)
                    deferred.resolve(data.accountAssets);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getCachedAccountBalance = function (address, chain) {
            if (chain === void 0) { chain = 1; }
            if (_this.cachedGetCachedAccountBalance.get(address))
                return _this.cachedGetCachedAccountBalance.get(address);
            var deferred = _this.$q.defer();
            _this.cachedGetCachedAccountBalance.set(address, deferred.promise);
            _this.getBalanceFromChain(address, chain).then(deferred.resolve, deferred.reject);
            _this.cachedGetCachedAccountBalance.get(address).finally(function () {
                setTimeout(function () {
                    _this.cachedGetCachedAccountBalance.set(address, null);
                }, 30 * 1000);
            });
            return _this.cachedGetCachedAccountBalance.get(address);
        };
        this.getBalance = function (account, chain) {
            if (chain === void 0) { chain = 1; }
            var deferred = _this.$q.defer();
            _this.getCachedAccountBalance(account).then(function (info) {
                deferred.resolve(info);
            }, deferred.reject);
            return deferred.promise;
        };
        this.getBalanceFromChain = function (account, chain) {
            if (chain === void 0) { chain = 1; }
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getBalance&account=").concat(account, "&chain=").concat(chain)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.unconfirmedBalanceNQT)
                    deferred.resolve(data.unconfirmedBalanceNQT);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getPublicKeyFromAddress = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getAccountPublicKey&account=").concat(account)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.publicKey)
                    deferred.resolve(data.publicKey);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAssetInfo = function (asset) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getAsset&asset=").concat(asset)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.name)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.sendTransactionWithSecret = function (endpoint) {
            var deferred = _this.$q.defer();
            _this.http.post("".concat(_this.url, "/nxt?").concat(endpoint), {}).then(function (data) {
                if (data.errorDescription) {
                    deferred.reject(data.errorDescription);
                }
                else {
                    deferred.resolve({ txId: data.transactionJSON.transaction, fullHash: data.fullHash });
                }
            });
            return deferred.promise;
        };
        this.settingsService.initialized.then(function () { return _this.setUrl(SettingsService.getCryptoServerEndpoint('ARDR')); });
    }
    ArdorBlockExplorerService.prototype.setUrl = function (url) {
        this.url = url;
    };
    ArdorBlockExplorerService.prototype.getTradesCount = function (ardorAsset, account) {
        var deferred = this.$q.defer();
        var url = account ? "".concat(this.url, "/nxt?requestType=getTrades&chain=2&ardorAsset=").concat(ardorAsset, "&firstIndex=0&lastIndex=-1&account=").concat(account) : "".concat(this.url, "/nxt?requestType=getTrades&chain=2&asset=").concat(ardorAsset, "&firstIndex=0&lastIndex=-1");
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.trades)
                deferred.resolve(data.trades.length);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getTrades = function (ardorAsset, firstIndex, lastIndex, account) {
        var deferred = this.$q.defer();
        var url = account ? "".concat(this.url, "/nxt?requestType=getTrades&chain=2&asset=").concat(ardorAsset, "&firstIndex=").concat(firstIndex, "&lastIndex=").concat(lastIndex, "&account=").concat(account) : "".concat(this.url, "/nxt?requestType=getTrades&chain=2&asset=").concat(ardorAsset, "&firstIndex=").concat(firstIndex, "&lastIndex=").concat(lastIndex);
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.trades)
                deferred.resolve(data.trades);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAskOrdersCount = function (ardorAsset) {
        var deferred = this.$q.defer();
        var url = "".concat(this.url, "/nxt?requestType=getAskOrders&chain=2&asset=").concat(ardorAsset, "&firstIndex=0&lastIndex=-1");
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.askOrders)
                deferred.resolve(data.askOrders.length);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAskOrders = function (ardorAsset, firstIndex, lastIndex) {
        var deferred = this.$q.defer();
        var url = "".concat(this.url, "/nxt?requestType=getAskOrders&chain=2&asset=").concat(ardorAsset, "&firstIndex=").concat(firstIndex, "&lastIndex=").concat(lastIndex);
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.askOrders) {
                deferred.resolve(data.askOrders);
            }
            else {
                deferred.reject(data.errorDescription);
            }
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getBidOrdersCount = function (ardorAsset) {
        var deferred = this.$q.defer();
        var url = "".concat(this.url, "/nxt?requestType=getBidOrders&chain=2&asset=").concat(ardorAsset, "&firstIndex=0&lastIndex=-1");
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.bidOrders) {
                deferred.resolve(data.bidOrders.length);
            }
            else {
                deferred.reject(data.errorDescription);
            }
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getBidOrders = function (ardorAsset, firstIndex, lastIndex) {
        var deferred = this.$q.defer();
        var url = "".concat(this.url, "/nxt?requestType=getBidOrders&chain=2&asset=").concat(ardorAsset, "&firstIndex=").concat(firstIndex, "&lastIndex=").concat(lastIndex);
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.bidOrders) {
                deferred.resolve(data.bidOrders);
            }
            else {
                deferred.reject(data.errorDescription);
            }
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getMyPendingOrders = function (account, ardorAsset, firstIndex, lastIndex) {
        var promises = [];
        var deferred = this.$q.defer();
        promises.push(this.getAccountCurrentAskOrders(account, ardorAsset, firstIndex, lastIndex));
        promises.push(this.getAccountCurrentBidOrders(account, ardorAsset, firstIndex, lastIndex));
        var myPendingOrders = [];
        Promise.all(promises).then(function (values) {
            values.forEach(function (value) {
                myPendingOrders = myPendingOrders.concat(value);
            });
            deferred.resolve(myPendingOrders);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getMyPendingOrdersCount = function (account, ardorAsset) {
        var promises = [];
        var deferred = this.$q.defer();
        promises.push(this.getAccountCurrentAskOrdersCount(account, ardorAsset));
        promises.push(this.getAccountCurrentBidOrdersCount(account, ardorAsset));
        var myPendingOrdersCount = 0;
        Promise.all(promises).then(function (values) {
            values.forEach(function (value) {
                myPendingOrdersCount += value;
            });
            deferred.resolve(myPendingOrdersCount);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAccountCurrentBidOrders = function (account, ardorAsset, firstIndex, lastIndex) {
        var deferred = this.$q.defer();
        var url = "".concat(this.url, "/nxt?requestType=getAccountCurrentBidOrders&chain=2&asset=").concat(ardorAsset, "&firstIndex=").concat(firstIndex, "&lastIndex=").concat(lastIndex, "&account=").concat(account);
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.bidOrders)
                deferred.resolve(data.bidOrders);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAccountCurrentBidOrdersCount = function (account, ardorAsset) {
        var deferred = this.$q.defer();
        var url = "".concat(this.url, "/nxt?requestType=getAccountCurrentBidOrders&chain=2&asset=").concat(ardorAsset, "&firstIndex=0&lastIndex=-1&account=").concat(account);
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.bidOrders) {
                deferred.resolve(data.bidOrders.length);
            }
            else {
                deferred.reject(data.errorDescription);
            }
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAccountCurrentAskOrders = function (account, ardorAsset, firstIndex, lastIndex) {
        var deferred = this.$q.defer();
        var url = "".concat(this.url, "/nxt?requestType=getAccountCurrentAskOrders&chain=2&asset=").concat(ardorAsset, "&firstIndex=").concat(firstIndex, "&lastIndex=").concat(lastIndex, "&account=").concat(account);
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.askOrders) {
                deferred.resolve(data.askOrders);
            }
            else {
                deferred.reject(data.errorDescription);
            }
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAccountCurrentAskOrdersCount = function (account, ardorAsset) {
        var deferred = this.$q.defer();
        var url = "".concat(this.url, "/nxt?requestType=getAccountCurrentAskOrders&chain=2&asset=").concat(ardorAsset, "&firstIndex=0&lastIndex=-1&account=").concat(account);
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.askOrders) {
                deferred.resolve(data.askOrders.length);
            }
            else {
                deferred.reject(data.errorDescription);
            }
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAllAssets = function () {
        var deferred = this.$q.defer();
        var url = "".concat(this.url, "/nxt?requestType=getAllAssets&firstIndex=0&lastIndex=-1");
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.assets) {
                deferred.resolve(data.assets);
            }
            else {
                deferred.reject(data.errorDescription);
            }
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService = __decorate([
        Service('ardorBlockExplorerService'),
        Inject('$q', 'http', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService])
    ], ArdorBlockExplorerService);
    return ArdorBlockExplorerService;
}());
var ARDORCryptoService = (function () {
    function ARDORCryptoService($window, user, storage, $rootScope) {
        this.$window = $window;
        this.user = user;
        this.$rootScope = $rootScope;
        this.nxtCrypto = $window.heatlibs.nxtCrypto;
        this.store = storage.namespace('wallet-address', $rootScope, true);
    }
    ARDORCryptoService.prototype.unlock = function (seedOrPrivateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var heatAddress = heat.crypto.getAccountId(seedOrPrivateKey);
            var encryptedWallet = _this.store.get("ARDR-".concat(heatAddress));
            if (encryptedWallet) {
                if (!encryptedWallet.data) {
                    _this.store.remove("ARDR-".concat(heatAddress));
                    _this.unlock(seedOrPrivateKey);
                }
                var decryptedWallet = heat.crypto.decryptMessage(encryptedWallet.data, encryptedWallet.nonce, heatAddress, seedOrPrivateKey);
                resolve(JSON.parse(decryptedWallet));
            }
            else {
                var walletType = { addresses: [] };
                var publicKey = _this.nxtCrypto.getPublicKey(seedOrPrivateKey);
                var address = _this.nxtCrypto.getAccountRSFromSecretPhrase(seedOrPrivateKey, 'ARDOR');
                var accountId = _this.nxtCrypto.getAccountId(publicKey);
                walletType.addresses[0] = { address: address, privateKey: seedOrPrivateKey, accountId: accountId };
                var encryptedWallet_1 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seedOrPrivateKey);
                _this.store.put("ARDR-".concat(heatAddress), encryptedWallet_1);
                resolve(walletType);
            }
        });
    };
    ARDORCryptoService.prototype.refreshBalances = function (wallet) {
        var userAccount = wallet.addresses[0].accountId;
        return new Promise(function (resolve, reject) {
            var ardorBlockExplorerService = heat.$inject.get('ardorBlockExplorerService');
            ardorBlockExplorerService.getBlockchainStatus().then(function () {
                ardorBlockExplorerService.getTransactions(userAccount, 0, 10).then(function (transactions) {
                    if (transactions.length != 0) {
                        ardorBlockExplorerService.getBalance(userAccount).then(function (balance) {
                            wallet.addresses[0].balance = new Big(utils.convertToQNTf(balance)).toFixed(8);
                            wallet.addresses[0].inUse = true;
                            ardorBlockExplorerService.getAccountAssets(userAccount).then(function (accountAssets) {
                                wallet.addresses[0].tokensBalances = [];
                                var promises = [];
                                accountAssets.forEach(function (asset) {
                                    var promise = ardorBlockExplorerService.getAssetInfo(asset.asset).then(function (assetInfo) {
                                        wallet.addresses[0].tokensBalances.push({
                                            symbol: assetInfo ? assetInfo.name : '',
                                            name: assetInfo ? assetInfo.name : '',
                                            decimals: assetInfo.decimals,
                                            balance: utils.formatQNT(asset.unconfirmedQuantityQNT, assetInfo.decimals),
                                            address: asset.asset
                                        });
                                    });
                                    promises.push(promise);
                                });
                                Promise.all(promises).then(function () { return resolve(true); });
                                if (accountAssets.length === 0)
                                    resolve(true);
                            });
                        });
                    }
                    else {
                        resolve(false);
                    }
                });
            }).catch(reject);
        });
    };
    ARDORCryptoService = __decorate([
        Service('ardorCryptoService'),
        Inject('$window', 'user', 'storage', '$rootScope'),
        __metadata("design:paramtypes", [Object, UserService,
            StorageService, Object])
    ], ARDORCryptoService);
    return ARDORCryptoService;
}());
var ArdorPendingTransactionsService = (function () {
    function ArdorPendingTransactionsService($q, http, settings) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    ArdorPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('ardrPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]), fullHash = parts[4];
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time, fullHash: fullHash });
            }
        }
    };
    ArdorPendingTransactionsService.prototype.add = function (address, txId, timestamp, fullHash) {
        window.localStorage.setItem("ardrPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp, ":").concat(fullHash), "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    ArdorPendingTransactionsService.prototype.remove = function (address, txId, timestamp, fullHash) {
        window.localStorage.removeItem("ardrPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp, ":").concat(fullHash));
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    ArdorPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    ArdorPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    ArdorPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    ArdorPendingTransactionsService = __decorate([
        Service('ardorPendingTransactions'),
        Inject('$q', 'http', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService])
    ], ArdorPendingTransactionsService);
    return ArdorPendingTransactionsService;
}());
var AssetInfoService = (function () {
    function AssetInfoService(heat, $q, assetCertification, http) {
        this.heat = heat;
        this.$q = $q;
        this.assetCertification = assetCertification;
        this.http = http;
        this.certifiedSymbols = {
            "btc": "5592059897546023466",
            "fimk": "8593933499455210945",
            "gnt": "12638687347417181640",
            "xrp": "3861265706988762530",
            "nxt": "12723185826655406325",
            "ardr": "17622812277075597103"
        };
        this.cache = {};
        this.resetCache();
        setInterval(this.resetCache, 5 * 60 * 1000);
    }
    AssetInfoService.prototype.resetCache = function () {
        this.cache = {};
        this.cache["0"] = {
            id: "0",
            description: "HEAT Cryptocurrency",
            descriptionUrl: "",
            decimals: 8,
            symbol: "HEAT",
            name: "HEAT Cryptocurrency",
            certified: true,
            timestamp: 100149557,
            issuer: "8150091319858025343",
            issuerPublicName: "HEAT blockchain Genesis account",
            expired: false
        };
    };
    AssetInfoService.prototype.getDisplaySymbol = function (asset, symbol) {
        var lowerCaseSymbol = symbol.toLowerCase();
        if (angular.isString(this.certifiedSymbols[lowerCaseSymbol])) {
            if (this.certifiedSymbols[lowerCaseSymbol] != asset) {
                return symbol.slice(0, -1) + '-';
            }
        }
        return symbol;
    };
    AssetInfoService.prototype.getInfo = function (asset) {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.cache[asset])) {
            deferred.resolve(this.cache[asset]);
        }
        else {
            this.heat.api.getAssetProperties(asset, "0", 1).then(function (data) {
                var properties = _this.parseProperties(data.properties, {
                    symbol: asset.substring(0, 4),
                    name: asset,
                    certified: false
                });
                var info = {
                    type: data.type,
                    id: asset,
                    description: null,
                    descriptionUrl: data.descriptionUrl,
                    decimals: data.decimals,
                    symbol: _this.getDisplaySymbol(asset, properties.symbol || ''),
                    name: properties.name,
                    certified: false,
                    timestamp: data.timestamp,
                    issuer: data.account,
                    issuerPublicName: data.accountPublicName,
                    tradeFee: data.tradeFee,
                    orderFee: data.orderFee,
                    feeRecipient: data.feeRecipient,
                    expiration: data.expiration,
                    expired: utils.isAssetExpired(data.expiration)
                };
                _this.cache[asset] = info;
                _this.assetCertification.getInfo(asset).then(function (certificationData) {
                    if (certificationData.certified) {
                        info.symbol = certificationData.symbol;
                        info.name = certificationData.name;
                        info.certified = certificationData.certified;
                    }
                    deferred.resolve(info);
                }, deferred.reject);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    AssetInfoService.prototype.parseProperties = function (properties, fallback) {
        try {
            var json = JSON.parse(properties);
            return {
                symbol: json[0],
                name: json[1],
                certified: false
            };
        }
        catch (e) {
        }
        return fallback;
    };
    AssetInfoService.prototype.stringifyProperties = function (properties) {
        return JSON.stringify([properties.symbol, properties.name]);
    };
    AssetInfoService.prototype.getAssetDescription = function (info) {
        var deferred = this.$q.defer();
        var noDescription = "No description available ...";
        if (angular.isString(info.description) || !info.descriptionUrl) {
            deferred.resolve(info.description || noDescription);
        }
        else {
            this.http.get(info.descriptionUrl).then(function (text) {
                info.description = text;
                deferred.resolve(text);
            }, function () {
                deferred.resolve(noDescription);
            });
        }
        return deferred.promise;
    };
    AssetInfoService = __decorate([
        Service('assetInfo'),
        Inject('heat', '$q', 'assetCertification', 'http'),
        __metadata("design:paramtypes", [HeatService, Function, AssetCertificationService,
            HttpService])
    ], AssetInfoService);
    return AssetInfoService;
}());
var AssetCertificationService = (function () {
    function AssetCertificationService(heat, $q, settings) {
        this.heat = heat;
        this.$q = $q;
        this.settings = settings;
        this.cache = {};
        this.cache["0"] = {
            asset: "0",
            certified: true,
            symbol: "HEAT",
            name: "HEAT Currency",
            certifierAccount: this.settings.get(SettingsService.HEATLEDGER_CERTIFIER_ACCOUNT)
        };
    }
    AssetCertificationService.prototype.getInfo = function (asset) {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.cache[asset])) {
            deferred.resolve(this.cache[asset]);
        }
        else {
            this.heat.api.getAssetCertification(asset, this.settings.get(SettingsService.HEATLEDGER_CERTIFIER_ACCOUNT)).then(function (data) {
                _this.cache[asset] = data;
                deferred.resolve(_this.cache[asset]);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    AssetCertificationService = __decorate([
        Service('assetCertification'),
        Inject('heat', '$q', 'settings'),
        __metadata("design:paramtypes", [HeatService, Function, SettingsService])
    ], AssetCertificationService);
    return AssetCertificationService;
}());
var BchBlockExplorerService = (function () {
    function BchBlockExplorerService(http, $q, settingsService) {
        var _this = this;
        this.http = http;
        this.$q = $q;
        this.settingsService = settingsService;
        this.cachedGetCachedAccountBalance = new Map();
        this.getCachedAccountBalance = function (address) {
            if (_this.cachedGetCachedAccountBalance.get(address))
                return _this.cachedGetCachedAccountBalance.get(address);
            var deferred = _this.$q.defer();
            _this.cachedGetCachedAccountBalance.set(address, deferred.promise);
            _this.getBalanceFromChain(address).then(deferred.resolve, deferred.reject);
            _this.cachedGetCachedAccountBalance.get(address).finally(function () {
                setTimeout(function () {
                    _this.cachedGetCachedAccountBalance.set(address, null);
                }, 30 * 1000);
            });
            return _this.cachedGetCachedAccountBalance.get(address);
        };
        this.getBalance = function (address) {
            var deferred = _this.$q.defer();
            _this.getCachedAccountBalance(address).then(function (info) {
                deferred.resolve(info);
            });
            return deferred.promise;
        };
        this.settingsService.initialized.then(function () { return BchBlockExplorerService_1.endPoint = SettingsService.getCryptoServerEndpoint('BCH'); });
    }
    BchBlockExplorerService_1 = BchBlockExplorerService;
    BchBlockExplorerService.prototype.isSyncing = function () {
        var deferred = this.$q.defer();
        this.http.get(BchBlockExplorerService_1.endPoint).then(function (response) {
            var parsed;
            try {
                parsed = angular.isString(response) ? JSON.parse(response) : response;
            }
            catch (e) {
                deferred.reject();
            }
            if (parsed && parsed.blockbook && parsed.blockbook.inSync && parsed.blockbook.coin === 'Bcash') {
                deferred.resolve();
            }
            else {
                deferred.reject();
            }
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    BchBlockExplorerService.prototype.getBalanceFromChain = function (address) {
        var deferred = this.$q.defer();
        this.getAddressInfo(address).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed.balance);
        }, function () {
            deferred.resolve("0");
        });
        return deferred.promise;
    };
    BchBlockExplorerService.prototype.getTransactions = function (address, pageNum, pageSize) {
        var getTransactionsApi = "".concat(BchBlockExplorerService_1.endPoint, "/address/").concat(address, "?details=txs&page=").concat(pageNum, "&pageSize=").concat(pageSize);
        var deferred = this.$q.defer();
        this.http.get(getTransactionsApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed.transactions);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    BchBlockExplorerService.prototype.getAddressInfo = function (address) {
        var getTransactionsApi = "".concat(BchBlockExplorerService_1.endPoint, "/address/").concat(address, "?details=basic");
        var deferred = this.$q.defer();
        this.http.get(getTransactionsApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    BchBlockExplorerService.prototype.getEstimatedFee = function () {
        var getEstimatedFeeApi = "".concat(BchBlockExplorerService_1.endPoint, "/estimatefee/1");
        var deferred = this.$q.defer();
        this.http.get(getEstimatedFeeApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed.result);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    BchBlockExplorerService.prototype.getTxInfo = function (txId) {
        var getTxInfoApi = "".concat(BchBlockExplorerService_1.endPoint, "/tx/").concat(txId);
        var deferred = this.$q.defer();
        this.http.get(getTxInfoApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    BchBlockExplorerService.prototype.getUnspentUtxos = function (account) {
        var getTxInfoApi = "".concat(BchBlockExplorerService_1.endPoint, "/utxo/").concat(account);
        var deferred = this.$q.defer();
        this.http.get(getTxInfoApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    BchBlockExplorerService.prototype.broadcast = function (rawTx) {
        var sendTxApi = "".concat(BchBlockExplorerService_1.endPoint, "/sendtx/").concat(rawTx);
        var deferred = this.$q.defer();
        this.http.get(sendTxApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed);
        }, function (error) {
            deferred.reject(error);
        });
        return deferred.promise;
    };
    var BchBlockExplorerService_1;
    BchBlockExplorerService = BchBlockExplorerService_1 = __decorate([
        Service('bchBlockExplorerService'),
        Inject('http', '$q', 'settings'),
        __metadata("design:paramtypes", [HttpService, Function, SettingsService])
    ], BchBlockExplorerService);
    return BchBlockExplorerService;
}());
var BCHCryptoService = (function () {
    function BCHCryptoService($window, http, storage, $rootScope) {
        this.http = http;
        this.$rootScope = $rootScope;
        this.bitcore = $window.heatlibs.bitcore;
        this.bip39 = $window.heatlibs.bip39;
        this.bitcoreCash = $window.heatlibs.bitcoreCash;
        this.store = storage.namespace('wallet-address', $rootScope, true);
    }
    BCHCryptoService_1 = BCHCryptoService;
    BCHCryptoService.prototype.unlock = function (seedOrPrivateKey, reset) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var heatAddress = heat.crypto.getAccountId(seedOrPrivateKey);
            var encryptedWallet = reset ? null : _this.store.get("BCH-".concat(heatAddress));
            if (encryptedWallet) {
                if (!encryptedWallet.data) {
                    _this.store.remove("BCH-".concat(heatAddress));
                    _this.unlock(seedOrPrivateKey);
                }
                var decryptedWallet = heat.crypto.decryptMessage(encryptedWallet.data, encryptedWallet.nonce, heatAddress, seedOrPrivateKey);
                resolve(JSON.parse(decryptedWallet));
            }
            else if (_this.bip39.validateMnemonic(seedOrPrivateKey)) {
                var walletType = _this.getNWalletsFromMnemonics(seedOrPrivateKey, 20);
                if (walletType.addresses.length === 20) {
                    var encryptedWallet_2 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seedOrPrivateKey);
                    _this.store.put("BCH-".concat(heatAddress), encryptedWallet_2);
                    resolve(walletType);
                }
            }
            else if (_this.bitcore.PrivateKey.isValid(seedOrPrivateKey)) {
                try {
                    var privateKey = _this.bitcore.PrivateKey.fromWIF(seedOrPrivateKey);
                    var address = privateKey.toAddress();
                    var walletType = { addresses: [] };
                    walletType.addresses[0] = { address: address.toString(), privateKey: privateKey.toString() };
                    var encryptedWallet_3 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seedOrPrivateKey);
                    _this.store.put("BCH-".concat(heatAddress), encryptedWallet_3);
                    resolve(walletType);
                }
                catch (e) {
                    resolve(null);
                }
            }
            else {
                reject();
            }
        });
    };
    BCHCryptoService.prototype.getNWalletsFromMnemonics = function (mnemonic, keyCount) {
        var walletType = { addresses: [] };
        for (var i = 0; i < keyCount; i++) {
            var wallet = this.getBitcoinCashWallet(mnemonic, i);
            walletType.addresses[i] = { address: wallet.address, privateKey: wallet.privateKey, index: i, balance: "0", inUse: false };
        }
        return walletType;
    };
    BCHCryptoService.prototype.refreshBalances = function (wallet, currencyAddressLoading) {
        wallet.addresses.forEach(function (value) { return value.balance = ""; });
        var addresses = wallet.addresses.filter(function (a) { return !a.isDeleted; }).map(function (a) { return a.address; });
        var emptyAddressCounter = 0;
        var bchBlockExplorerService = heat.$inject.get('bchBlockExplorerService');
        function processNext() {
            return new Promise(function (resolve, reject) {
                var address = addresses.shift();
                if (!address) {
                    resolve(false);
                    return;
                }
                currencyAddressLoading.address = address;
                bchBlockExplorerService.getAddressInfo(address).then(function (info) {
                    var walletAddress = wallet.addresses.find(function (x) { return x.address == address; });
                    if (!walletAddress) {
                        console.error("Address ".concat(address, " is not found among addresses"), wallet.addresses);
                        resolve(false);
                        return;
                    }
                    emptyAddressCounter++;
                    walletAddress.balance = parseFloat(info.balance) / 100000000 + "";
                    walletAddress.inUse = info.txs != 0;
                    if (walletAddress.inUse)
                        emptyAddressCounter = 0;
                    if (emptyAddressCounter >= 2) {
                        resolve(false);
                        return;
                    }
                    resolve(true);
                }, function (reason) {
                    console.error(reason);
                    resolve(false);
                });
            });
        }
        var recurseToNext = function recurseToNext(resolve) {
            processNext().then(function (hasMore) {
                if (hasMore) {
                    setTimeout(function () {
                        recurseToNext(resolve);
                    }, 100);
                }
                else {
                    resolve();
                }
            });
        };
        return new Promise(function (resolve, reject) {
            bchBlockExplorerService.isSyncing().then(function () { recurseToNext(resolve); }).catch(reject);
        });
    };
    BCHCryptoService.prototype.getBitcoinCashWallet = function (mnemonic, index) {
        if (index === void 0) { index = 0; }
        var seedHex = this.bip39.mnemonicToSeedHex(mnemonic);
        var HDPrivateKey = this.bitcore.HDPrivateKey;
        var hdPrivateKey = HDPrivateKey.fromSeed(seedHex, 'mainnet');
        var derived = hdPrivateKey.derive(BCHCryptoService_1.BIP44 + index);
        var address = derived.privateKey.toAddress();
        var privateKey = derived.privateKey.toWIF();
        var cashAddress = this.bitcoreCash.Address.fromObject(address.toObject()).toCashAddress();
        return {
            address: cashAddress,
            privateKey: privateKey.toString()
        };
    };
    BCHCryptoService.prototype.signTransaction = function (txObject, uncheckedSerialize) {
        var _this = this;
        if (uncheckedSerialize === void 0) { uncheckedSerialize = false; }
        var bitcoreCash = this.bitcoreCash;
        var bchBlockExplorerService = heat.$inject.get('bchBlockExplorerService');
        return new Promise(function (resolve, reject) {
            bchBlockExplorerService.getUnspentUtxos(txObject.from).then(function (utxos) {
                if (utxos.length === 0) {
                    reject(new Error('No utxo found for input address'));
                }
                var script = bitcoreCash.Script.buildPublicKeyHashOut(txObject.from);
                var UnspentOutput = _this.bitcoreCash.Transaction.UnspentOutput;
                var unspent = [];
                var availableSatoshis = 0;
                for (var i = 0; i < utxos.length; i += 1) {
                    var utxo = {
                        address: txObject.from,
                        txId: utxos[i].txid,
                        outputIndex: utxos[i].vout,
                        satoshis: parseInt(utxos[i].value),
                        script: script
                    };
                    unspent.push(new UnspentOutput(utxo));
                    availableSatoshis += parseInt(utxos[i].value);
                    if (availableSatoshis >= txObject.amount + txObject.fee)
                        break;
                }
                if (availableSatoshis < txObject.amount + txObject.fee) {
                    reject(new Error('Insufficient balance to broadcast transaction'));
                }
                try {
                    var tx = _this.bitcoreCash.Transaction();
                    tx.from(unspent);
                    tx.to(txObject.to, txObject.amount);
                    tx.change(txObject.from);
                    tx.fee(txObject.fee);
                    tx.sign(txObject.privateKey);
                    var rawTx = uncheckedSerialize ? tx.uncheckedSerialize() : tx.serialize();
                    resolve(rawTx);
                }
                catch (err) {
                    reject(err);
                }
            }, function (err) {
                reject(err);
            });
        });
    };
    BCHCryptoService.prototype.sendBitcoinCash = function (txObject) {
        var _this = this;
        var bchBlockExplorerService = heat.$inject.get('bchBlockExplorerService');
        return new Promise(function (resolve, reject) {
            _this.signTransaction(txObject).then(function (rawTx) {
                bchBlockExplorerService.broadcast(rawTx).then(function (data) {
                    resolve({ txId: data.result });
                }, function (error) {
                    reject(error);
                });
            }, function (error) {
                reject(error);
            });
        });
    };
    var BCHCryptoService_1;
    BCHCryptoService.BIP44 = "m/44'/145'/0'/0/";
    BCHCryptoService = BCHCryptoService_1 = __decorate([
        Service('bchCryptoService'),
        Inject('$window', 'http', 'storage', '$rootScope'),
        __metadata("design:paramtypes", [Object, HttpService,
            StorageService, Object])
    ], BCHCryptoService);
    return BCHCryptoService;
}());
var BchPendingTransactionsService = (function () {
    function BchPendingTransactionsService($q, http, settings, bchBlockExplorerService) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.bchBlockExplorerService = bchBlockExplorerService;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    BchPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('bchPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    BchPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("bchPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp), "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    BchPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("bchPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp));
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    BchPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    BchPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    BchPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    BchPendingTransactionsService = __decorate([
        Service('bchPendingTransactions'),
        Inject('$q', 'http', 'settings', 'bchBlockExplorerService'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            BchBlockExplorerService])
    ], BchPendingTransactionsService);
    return BchPendingTransactionsService;
}());
var BtcBlockExplorerService = (function () {
    function BtcBlockExplorerService($q, btcBlockExplorerBlockbookService, btcFeeService) {
        var _this = this;
        this.$q = $q;
        this.btcBlockExplorerBlockbookService = btcBlockExplorerBlockbookService;
        this.btcFeeService = btcFeeService;
        this.cachedGetCachedAccountBalance = new Map();
        this.cachedAddressInfo = new Map();
        this.getCachedAccountBalance = function (address) {
            var cachedValue = _this.cachedGetCachedAccountBalance.get(address);
            if (cachedValue)
                return cachedValue;
            var deferred = _this.$q.defer();
            _this.cachedGetCachedAccountBalance.set(address, deferred.promise);
            _this.btcProvider.getBalance(address).then(deferred.resolve, deferred.reject);
            _this.cachedGetCachedAccountBalance.get(address).finally(function () {
                setTimeout(function () {
                    _this.cachedGetCachedAccountBalance.set(address, null);
                }, 5 * 60 * 1000);
            });
            return _this.cachedGetCachedAccountBalance.get(address);
        };
        this.getBalance = function (address) {
            var deferred = _this.$q.defer();
            _this.getCachedAccountBalance(address).then(function (info) {
                deferred.resolve(info);
            }, deferred.reject);
            return deferred.promise;
        };
        this.getTransactions = function (address, from, to) {
            var deferred = _this.$q.defer();
            _this.btcProvider.getTransactions(address, from, to).then(function (info) {
                var data = Update3rdPartyAPIResponsesUtil.updateBTCGetTransactions(info, _this.btcProvider);
                deferred.resolve(data);
            }, function (reason) {
                deferred.reject(reason);
            });
            return deferred.promise;
        };
        this.getCachedAddressInfo = function (address) {
            var v = _this.cachedAddressInfo.get(address);
            if (v)
                return v;
            var deferred = _this.$q.defer();
            deferred.promise.finally(function () {
                setTimeout(function () {
                    _this.cachedAddressInfo.set(address, null);
                }, 60 * 1000);
            });
            _this.cachedAddressInfo.set(address, deferred.promise);
            _this.getAddressInfo(address, false).then(deferred.resolve, deferred.reject);
            return _this.cachedAddressInfo.get(address);
        };
        this.getAddressInfo = function (address, useCache) {
            if (useCache === void 0) { useCache = false; }
            if (useCache) {
                return _this.getCachedAddressInfo(address);
            }
            var deferred = _this.$q.defer();
            _this.btcProvider.getAddressInfo(address).then(function (info) {
                var data = Update3rdPartyAPIResponsesUtil.updateBTCGetAddressInfo(info, _this.btcProvider);
                deferred.resolve(data);
            }, function (reason) {
                deferred.reject(reason);
            });
            return deferred.promise;
        };
        this.getTxInfo = function (txId) {
            var deferred = _this.$q.defer();
            _this.btcProvider.getTxInfo(txId).then(function (info) {
                var data = Update3rdPartyAPIResponsesUtil.updateBTCGetTxInfo(info, _this.btcProvider);
                deferred.resolve(data);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.broadcast = function (rawTx) {
            return _this.btcProvider.broadcast(rawTx);
        };
        this.getUnspentUtxos = function (from) {
            return _this.btcProvider.getUnspentUtxos(from);
        };
        this.btcProvider = btcBlockExplorerBlockbookService;
    }
    BtcBlockExplorerService = __decorate([
        Service('btcBlockExplorerService'),
        Inject('$q', 'btcBlockExplorerBlockbookService', 'btcFeeService'),
        __metadata("design:paramtypes", [Function, BtcBlockExplorerBlockbookService,
            BtcFeeService])
    ], BtcBlockExplorerService);
    return BtcBlockExplorerService;
}());
var BitcoinMessagesService = (function () {
    function BitcoinMessagesService() {
        this.messages = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    BitcoinMessagesService.prototype.readLocalStorage = function () {
        this.messages = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('btcMessages:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], message = "".concat(parts[3], ":").concat(parts[4]);
                this.messages[addr] = this.messages[addr] || [];
                this.messages[addr].push({ txId: txId, message: message });
            }
        }
    };
    BitcoinMessagesService.prototype.add = function (address, txId, message) {
        window.localStorage.setItem("btcMessages:".concat(address, ":").concat(txId, ":").concat(message), "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    BitcoinMessagesService.prototype.remove = function (address, txId, message) {
        window.localStorage.removeItem("btcMessages:".concat(address, ":").concat(txId, ":").concat(message));
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    BitcoinMessagesService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    BitcoinMessagesService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    BitcoinMessagesService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    BitcoinMessagesService = __decorate([
        Service('bitcoinMessagesService'),
        __metadata("design:paramtypes", [])
    ], BitcoinMessagesService);
    return BitcoinMessagesService;
}());
var BitcoinPendingTransactionsService = (function () {
    function BitcoinPendingTransactionsService($q, http, settings, btcBlockExplorerService) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.btcBlockExplorerService = btcBlockExplorerService;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    BitcoinPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('btcPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    BitcoinPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("btcPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp), "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    BitcoinPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("btcPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp));
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    BitcoinPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    BitcoinPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    BitcoinPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    BitcoinPendingTransactionsService = __decorate([
        Service('bitcoinPendingTransactions'),
        Inject('$q', 'http', 'settings', 'btcBlockExplorerService'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            BtcBlockExplorerService])
    ], BitcoinPendingTransactionsService);
    return BitcoinPendingTransactionsService;
}());
var BitcoreService = (function () {
    function BitcoreService($window, storage, $rootScope) {
        this.$rootScope = $rootScope;
        this.bitcore = $window.heatlibs.bitcore;
        this.bip39 = $window.heatlibs.bip39;
        this.store = storage.namespace('wallet-address', $rootScope, true);
    }
    BitcoreService_1 = BitcoreService;
    BitcoreService.prototype.unlock = function (seedOrPrivateKey, reset) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var heatAddress = heat.crypto.getAccountId(seedOrPrivateKey);
            var encryptedWallet = reset ? null : _this.store.get("BTC-".concat(heatAddress));
            if (encryptedWallet) {
                if (!encryptedWallet.data) {
                    _this.store.remove("BTC-".concat(heatAddress));
                    _this.unlock(seedOrPrivateKey);
                }
                var decryptedWallet = heat.crypto.decryptMessage(encryptedWallet.data, encryptedWallet.nonce, heatAddress, seedOrPrivateKey);
                resolve(JSON.parse(decryptedWallet));
            }
            else if (_this.bip39.validateMnemonic(seedOrPrivateKey)) {
                var walletType = _this.getNWalletsFromMnemonics(seedOrPrivateKey, 20);
                if (walletType.addresses.length === 20) {
                    var encryptedWallet_4 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seedOrPrivateKey);
                    _this.store.put("BTC-".concat(heatAddress), encryptedWallet_4);
                    resolve(walletType);
                }
            }
            else if (_this.bitcore.PrivateKey.isValid(seedOrPrivateKey)) {
                try {
                    var privateKey = _this.bitcore.PrivateKey.fromWIF(seedOrPrivateKey);
                    var address = privateKey.toAddress();
                    var walletType = { addresses: [] };
                    walletType.addresses[0] = { address: address.toString(), privateKey: privateKey.toString() };
                    var encryptedWallet_5 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seedOrPrivateKey);
                    _this.store.put("BTC-".concat(heatAddress), encryptedWallet_5);
                    resolve(walletType);
                }
                catch (e) {
                    resolve(null);
                }
            }
            else {
                reject("Seed (or private key) is not valid for currency");
            }
        });
    };
    BitcoreService.prototype.getNWalletsFromMnemonics = function (mnemonic, keyCount) {
        var walletType = { addresses: [] };
        for (var i = 0; i < keyCount; i++) {
            var wallet = this.getBitcoinWallet(mnemonic, i);
            walletType.addresses[i] = { address: wallet.address, privateKey: wallet.privateKey, index: i, balance: "0", inUse: false };
        }
        return walletType;
    };
    BitcoreService.prototype.refreshBalances = function (wallet, btcCurrencyAddressLoading) {
        wallet.addresses.forEach(function (value) { return value.balance = ""; });
        var addresses = wallet.addresses.filter(function (a) { return !a.isDeleted; }).map(function (a) { return a.address; });
        var emptyAddressCounter = 0;
        function processNext() {
            return new Promise(function (resolve, reject) {
                var address = addresses.shift();
                if (!address) {
                    resolve(false);
                    return;
                }
                btcCurrencyAddressLoading.address = address;
                var btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
                btcBlockExplorerService.getAddressInfo(address, true).then(function (info) {
                    var walletAddress = wallet.addresses.find(function (x) { return x.address == address; });
                    if (!walletAddress) {
                        console.error("Address ".concat(address, " is not found among addresses"), wallet.addresses);
                        resolve(false);
                        return;
                    }
                    emptyAddressCounter++;
                    walletAddress.balance = info.balanceSat == undefined ? "" : info.balanceSat / 100000000 + "";
                    walletAddress.inUse = info.txApperances ? info.txApperances != 0 : null;
                    if (walletAddress.inUse)
                        emptyAddressCounter = 0;
                    if (emptyAddressCounter >= 2) {
                        resolve(false);
                        return;
                    }
                    resolve(true);
                }).catch(function (reason) {
                    console.error(reason);
                    reject(reason);
                });
            });
        }
        var recurseToNext = function recurseToNext(resolve, reject) {
            processNext().then(function (hasMore) {
                if (hasMore) {
                    setTimeout(function () {
                        recurseToNext(resolve, reject);
                    }, 100);
                }
                else {
                    resolve(null);
                }
            }).catch(function (reason) { return reject(reason); });
        };
        return new Promise(function (resolve, reject) {
            recurseToNext(resolve, reject);
        });
    };
    BitcoreService.prototype.signTransaction = function (txObject, uncheckedSerialize) {
        var _this = this;
        if (uncheckedSerialize === void 0) { uncheckedSerialize = false; }
        var btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
        return new Promise(function (resolve, reject) {
            btcBlockExplorerService.getUnspentUtxos(txObject.from).then(function (utxos) {
                try {
                    var tx = _this.bitcore.Transaction();
                    tx.from(utxos);
                    tx.to(txObject.to, txObject.amount);
                    tx.change(txObject.from);
                    tx.fee(txObject.fee);
                    tx.sign(txObject.privateKey);
                    var rawTx = void 0;
                    if (uncheckedSerialize)
                        rawTx = tx.uncheckedSerialize();
                    else
                        rawTx = tx.serialize();
                    resolve(rawTx);
                }
                catch (err) {
                    reject(err);
                }
            }, function (err) {
                reject(err);
            });
        });
    };
    BitcoreService.prototype.sendBitcoins = function (txObject) {
        var _this = this;
        var btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
        return new Promise(function (resolve, reject) {
            _this.signTransaction(txObject).then(function (rawTx) {
                btcBlockExplorerService.broadcast(rawTx).then(function (txId) {
                    resolve({ txId: txId.txId, message: '' });
                }, function (error) {
                    reject(error);
                });
            }).catch(function (reason) {
                console.error(reason);
                reject(reason);
            });
        });
    };
    BitcoreService.prototype.getBitcoinWallet = function (mnemonic, index) {
        if (index === void 0) { index = 0; }
        var seedHex = this.bip39.mnemonicToSeedHex(mnemonic);
        var HDPrivateKey = this.bitcore.HDPrivateKey;
        var hdPrivateKey = HDPrivateKey.fromSeed(seedHex, 'mainnet');
        var derived = hdPrivateKey.derive(BitcoreService_1.BIP44 + index);
        var address = derived.privateKey.toAddress();
        var privateKey = derived.privateKey.toWIF();
        return {
            address: address.toString(),
            privateKey: privateKey.toString()
        };
    };
    var BitcoreService_1;
    BitcoreService.BIP44 = "m/44'/0'/0'/0/";
    BitcoreService = BitcoreService_1 = __decorate([
        Service('bitcoreService'),
        Inject('$window', 'storage', '$rootScope'),
        __metadata("design:paramtypes", [Object, StorageService, Object])
    ], BitcoreService);
    return BitcoreService;
}());
var BtcBlockExplorerBlockbookService = (function () {
    function BtcBlockExplorerBlockbookService(http, $q, $window) {
        var _this = this;
        this.http = http;
        this.$q = $q;
        this.$window = $window;
        this.getBalance = function (address) {
            var deferred = _this.$q.defer();
            _this.getAddressInfo(address).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError) {
                    deferred.reject();
                }
                deferred.resolve(parseInt(parsed.balance) + parseInt(parsed.unconfirmedBalance));
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactions = function (address, from, to) {
            var pageSize = to - from;
            var page = Math.round(to / pageSize);
            var getTransactionsApi = "".concat(BtcBlockExplorerBlockbookService_1.endPoint, "/address/").concat(address, "?details=txs&page=").concat(page, "&pageSize=").concat(pageSize);
            var deferred = _this.$q.defer();
            _this.http.get(getTransactionsApi).then(function (response) {
                if (!response) {
                    deferred.reject("empty response");
                }
                else {
                    var parsed = utils.parseResponse(response);
                    if (parsed.heatUtilParsingError)
                        deferred.reject();
                    deferred.resolve(parsed.transactions);
                }
            }, function (reason) {
                deferred.reject(reason);
            });
            return deferred.promise;
        };
        this.getAddressInfo = function (address) {
            var url = "".concat(BtcBlockExplorerBlockbookService_1.endPoint, "/address/").concat(address, "?details=txids");
            var deferred = _this.$q.defer();
            _this.http.get(url, true).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    deferred.reject(parsed.heatUtilParsingError);
                var unconfirmedBalance = parseInt(parsed.balance) + parseInt(parsed.unconfirmedBalance);
                wlt.saveCurrencyBalance(address, "BTC", parsed.balance, unconfirmedBalance.toString());
                deferred.resolve(parsed);
            }, function (reason) {
                deferred.reject(reason);
            });
            return deferred.promise;
        };
        this.getEstimatedFee = function (feeBlocks) {
            if (feeBlocks === void 0) { feeBlocks = 1; }
            var url = "https://btc1.heatwallet.com/api/v1/estimatefee/".concat(feeBlocks);
            var deferred = _this.$q.defer();
            var btcKByteFee = 0.0002;
            _this.http.get(url, true).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    deferred.reject(parsed.heatUtilParsingError);
                btcKByteFee = parsed.result;
                if (!btcKByteFee)
                    btcKByteFee = 20;
                deferred.resolve(btcKByteFee);
            }, function (reason) {
                console.log("error response on getting fee for btc. " + reason);
                deferred.resolve(btcKByteFee);
            });
            return deferred.promise;
        };
        this.getTxInfo = function (txId) {
            var getTxInfoApi = "".concat(BtcBlockExplorerBlockbookService_1.endPoint, "/tx/").concat(txId);
            var deferred = _this.$q.defer();
            _this.http.get(getTxInfoApi).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    deferred.reject();
                deferred.resolve(parsed);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getLatestBlockHash = function () {
            var getLatestBlockHash = "".concat(BtcBlockExplorerBlockbookService_1.endPoint, "/status?q=getLastBlockHash");
            var deferred = _this.$q.defer();
            _this.http.get(getLatestBlockHash).then(function (response) {
                var parsed = utils.parseResponse(response);
                deferred.resolve(parsed.lastblockhash);
            }, function () {
                deferred.reject();
            }).catch(function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.isBlockchainSyncing = function () {
            var deferred = _this.$q.defer();
            _this.getLatestBlockHash().then(function (blockHash) {
                _this.getBlockByHash(blockHash).then(function (response) {
                    var parsed = utils.parseResponse(response);
                    if (utils.isTimeWithinThreasholdLimit(parsed.time))
                        deferred.resolve();
                    else
                        deferred.reject();
                });
            }).catch(function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getBlockByHash = function (blockHash) {
            var getBlockByHash = "".concat(BtcBlockExplorerBlockbookService_1.endPoint, "/block/").concat(blockHash);
            var deferred = _this.$q.defer();
            _this.http.get(getBlockByHash).then(function (response) {
                var parsed = utils.parseResponse(response);
                deferred.resolve(parsed);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.broadcast = function (rawTx) {
            return new Promise(function (resolve, reject) {
                _this.http.get("".concat(BtcBlockExplorerBlockbookService_1.endPoint, "/sendtx/").concat(rawTx)).then(function (response) {
                    var responseObj;
                    try {
                        responseObj = typeof response === 'string' ? JSON.parse(response) : response;
                    }
                    catch (e) {
                        responseObj = response;
                    }
                    if (responseObj.result) {
                        resolve({ txId: responseObj.result });
                    }
                    else if (responseObj.error && responseObj.error.message) {
                        reject({
                            message: responseObj.error.message
                        });
                    }
                    else {
                        var responseStr = typeof response === 'string' ? response : JSON.stringify(response);
                        console.log('Broadcast response', response);
                        reject({
                            message: 'Response: ' + responseStr
                        });
                    }
                }, function (error) {
                    if (angular.isString(error)) {
                        reject({ message: error });
                    }
                    else if (angular.isObject(error) && error != null) {
                        reject(error.message || error.error);
                    }
                    else {
                        reject(JSON.stringify(error));
                    }
                });
            });
        };
        BtcBlockExplorerBlockbookService_1.endPoint = 'https://btc1.heatwallet.com/api/v2';
        this.bitcore = $window.heatlibs.bitcore;
    }
    BtcBlockExplorerBlockbookService_1 = BtcBlockExplorerBlockbookService;
    BtcBlockExplorerBlockbookService.prototype.getUnspentUtxos = function (addresses) {
        var Address = this.bitcore.Address;
        var Transaction = this.bitcore.Transaction;
        var Script = this.bitcore.Script;
        var UnspentOutput = Transaction.UnspentOutput;
        var that = this;
        function getUtxos(address) {
            return new Promise(function (resolve, reject) {
                var getUnspentUtxos = "".concat(BtcBlockExplorerBlockbookService_1.endPoint, "/utxo/").concat(address, "?confirmed=true");
                that.http.get(getUnspentUtxos).then(function (response) {
                    var parsed = utils.parseResponse(response);
                    var utxos = [];
                    if (Array.isArray(parsed)) {
                        parsed.forEach(function (_utxo) {
                            var utxo = new UnspentOutput({
                                "txid": _utxo.txid,
                                "vout": _utxo.vout,
                                "address": address,
                                "script": Script.buildPublicKeyHashOut(address).toString(),
                                "amount": utils.formatQNT(_utxo.value)
                            });
                            utxos.push(utxo);
                        });
                    }
                    resolve(utxos);
                }, function (e) {
                    reject(e);
                }).catch(function (e) {
                    reject(e);
                });
            });
        }
        return new Promise(function (resolve, reject) {
            if (!Array.isArray(addresses)) {
                addresses = [addresses];
            }
            addresses = addresses.map(function (address) { return new Address(address); });
            var utxos = [];
            var promises = addresses.map(function (address) { return getUtxos(address).then(function (_utxos) { return _utxos.forEach(function (utxo) { return utxos.push(utxo); }); }); });
            Promise.all(promises).then(function () { return resolve(utxos); }, function (error) { return reject(error); });
        });
    };
    var BtcBlockExplorerBlockbookService_1;
    BtcBlockExplorerBlockbookService = BtcBlockExplorerBlockbookService_1 = __decorate([
        Service('btcBlockExplorerBlockbookService'),
        Inject('http', '$q', '$window'),
        __metadata("design:paramtypes", [HttpService, Function, Object])
    ], BtcBlockExplorerBlockbookService);
    return BtcBlockExplorerBlockbookService;
}());
var BtcFeeService = (function () {
    function BtcFeeService(http, $q, $window) {
        var _this = this;
        this.http = http;
        this.$q = $q;
        this.$window = $window;
        this.getSatByteFee = function () {
            var deferred = _this.$q.defer();
            _this.getSatByteFeeByMethod1().then(function (result) {
                deferred.resolve(result);
            }).catch(function (reason) {
                console.log("error on getting fee for btc by method 1. " + (reason || ""));
                return _this.getSatByteFeeByMethod2();
            }).then(function (result) {
                deferred.resolve(result);
            }).catch(function (reason) {
                var s = "error on getting fee for btc by method 2. " + (reason || "");
                console.log(s);
                deferred.reject(s);
            });
            return deferred.promise;
        };
        this.getSatByteFeeByMethod1 = function () {
            return _this.http.get(BtcFeeService_1.endPoint1).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    throw new Error(parsed.heatUtilParsingError);
                var fees = parsed.fee_by_block_target;
                var result = {
                    "1": Math.ceil(fees["1"] / 1000),
                    "3": Math.ceil(fees["3"] / 1000),
                    "6": Math.ceil(fees["6"] / 1000),
                    "12": Math.ceil(fees["12"] / 1000)
                };
                return result;
            });
        };
        this.getSatByteFeeByMethod2 = function () {
            var result = {};
            var responseHandler = function (blocksNum) { return function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    throw new Error(parsed.heatUtilParsingError);
                var btcKByteFee = parsed.result;
                result["".concat(blocksNum)] = Math.ceil(btcKByteFee * 100000000 / 1024);
                return result;
            }; };
            return _this.http.get("".concat(BtcFeeService_1.endPoint2, "/1"), true)
                .then(responseHandler(1))
                .then(function (v) { return _this.http.get("".concat(BtcFeeService_1.endPoint2, "/3"), true); })
                .then(responseHandler(3))
                .then(function (v) { return _this.http.get("".concat(BtcFeeService_1.endPoint2, "/6"), true); })
                .then(responseHandler(6))
                .then(function (v) { return _this.http.get("".concat(BtcFeeService_1.endPoint2, "/12"), true); })
                .then(responseHandler(12));
        };
    }
    BtcFeeService_1 = BtcFeeService;
    var BtcFeeService_1;
    BtcFeeService.endPoint1 = 'https://bitcoinfees.net/api.json';
    BtcFeeService.endPoint2 = 'https://btc1.heatwallet.com/api/v1/estimatefee';
    BtcFeeService = BtcFeeService_1 = __decorate([
        Service('btcFeeService'),
        Inject('http', '$q', '$window'),
        __metadata("design:paramtypes", [HttpService, Function, Object])
    ], BtcFeeService);
    return BtcFeeService;
}());
var ClipboardService = (function () {
    function ClipboardService($q, $mdToast) {
        this.$q = $q;
        this.$mdToast = $mdToast;
    }
    ClipboardService.prototype.copy = function (element) {
        var deferred = this.$q.defer();
        window.getSelection().removeAllRanges();
        var range = document.createRange();
        range.selectNode(element);
        window.getSelection().addRange(range);
        try {
            if (document.execCommand('copy')) {
                window.getSelection().removeAllRanges();
                deferred.resolve();
            }
            else {
                deferred.reject();
            }
        }
        catch (e) {
            deferred.reject();
        }
        return deferred.promise;
    };
    ClipboardService.prototype.copyText = function (text, successMessage) {
        var tempInput = document.createElement("TextArea");
        tempInput.style = "position: absolute; left: -1000px; top: -1000px";
        tempInput.value = text;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand("copy");
        document.body.removeChild(tempInput);
        if (successMessage) {
            this.$mdToast.show(this.$mdToast.simple().textContent(successMessage).hideDelay(5000));
        }
    };
    ClipboardService.prototype.copyWithUI = function (element, successMessage) {
        var _this = this;
        return this.copy(element).then(function () {
            _this.$mdToast.show(_this.$mdToast.simple()
                .textContent(successMessage)
                .hideDelay(5000));
        }, function () {
            _this.$mdToast.show(_this.$mdToast.simple()
                .textContent("Press CTRL+C to copy")
                .hideDelay(10000));
        });
    };
    ClipboardService.prototype.showSecret = function (secret, currencySymbol) {
        var _this = this;
        if (currencySymbol == "ETH")
            secret = "0x" + secret;
        var panel = heat.$inject.get('panel');
        panel.show("\n      <div layout=\"column\" flex class=\"toolbar-copy-passphrase\">\n        <md-input-container flex>\n          <md-menu>\n            <md-button style=\"margin-top: 5px; margin-right: 20px; padding: 20px;\" ng-click=\"$mdMenu.open($event)\" >\n              <i>If you are sure that you want to see the secret data click here</i>\n            </md-button>\n            <md-menu-content class=\"toolbar-copy-passphrase\">\n              <textarea style=\"min-height: 44px; width: 600px; border: none; background: transparent;\" rows=\"2\"\n                    flex ng-bind=\"vm.secret\" readonly ng-trim=\"false\" aria-label=\"secret\"></textarea>\n              <div class=\"qrcodeBox\" id=\"PKQRCode\"></div>\n              <p>\n              <md-button ng-click=\"vm.copyToClipboard()\" aria-label=\"Copy\" style=\"color: white !important;\">copy</md-button>\n              <md-button class=\"md-primary\" ng-click=\"vm.panel.close()\" aria-label=\"Close\" style=\"float: right; color: white !important;\">Close</md-button>\n              </p>\n            </md-menu-content>\n          </md-menu>\n        </md-input-container>\n      </div>\n    ", {
            panel: panel,
            secret: secret,
            copyToClipboard: function () {
                _this.copyText(secret, 'Copied data to clipboard');
            }
        });
        setTimeout(function () {
            new QRCode("PKQRCode", {
                text: secret,
                width: 160,
                height: 160,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        }, 800);
    };
    ClipboardService.prototype.showTxnBytes = function (txnHEX) {
        var _this = this;
        var panel = heat.$inject.get('panel');
        setTimeout(function () {
            new QRCode("txnHEX", {
                text: txnHEX,
                width: 180,
                height: 180,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        }, 500);
        return panel.show("\n      <div layout=\"column\" flex class=\"toolbar-copy-passphrase\">\n        <md-input-container flex>\n          <textarea style=\"min-height: 44px; width: 600px; overflow: scroll; border: none; background: transparent;\" rows=\"3\"\n                flex ng-bind=\"vm.txnHEX\" readonly ng-trim=\"false\" aria-label=\"transaction bytes\"></textarea>\n          <div class=\"qrcodeBox\" id=\"txnHEX\"></div>\n          <p>\n          <md-button ng-click=\"vm.copyToClipboard()\" aria-label=\"Copy\" style=\"color: white !important;\">copy</md-button>\n          <md-button class=\"md-primary\" ng-click=\"vm.panel.close()\" aria-label=\"Close\" style=\"float: right; color: white !important;\">Close</md-button>\n          </p>\n        </md-input-container>\n      </div>\n    ", {
            panel: panel,
            txnHEX: txnHEX,
            copyToClipboard: function () {
                _this.copyText(txnHEX, 'Copied data to clipboard');
            }
        });
    };
    ClipboardService = __decorate([
        Service('clipboard'),
        Inject('$q', '$mdToast'),
        __metadata("design:paramtypes", [Function, Object])
    ], ClipboardService);
    return ClipboardService;
}());
var OpenDevToolsMode;
(function (OpenDevToolsMode) {
    OpenDevToolsMode[OpenDevToolsMode["right"] = 0] = "right";
    OpenDevToolsMode[OpenDevToolsMode["bottom"] = 1] = "bottom";
    OpenDevToolsMode[OpenDevToolsMode["undocked"] = 2] = "undocked";
    OpenDevToolsMode[OpenDevToolsMode["detach"] = 3] = "detach";
})(OpenDevToolsMode || (OpenDevToolsMode = {}));
var ElectronService = (function () {
    function ElectronService(env) {
        this.enabled = false;
        this.enabled = env.type == EnvType.NODEJS;
    }
    ElectronService.prototype.getMainWindowWebContents = function () {
        try {
            var wcs = require('electron').remote.webContents.getAllWebContents();
            for (var i = 0; i < wcs.length; i++) {
                if (wcs[i].getTitle().toUpperCase().indexOf("HEATWALLET") >= 0)
                    return wcs[i];
            }
            return wcs[wcs.length - 1];
        }
        catch (e) {
            if (this.enabled)
                throw e;
            console.log("Do not access the `electron` service in browser env", e);
        }
    };
    ElectronService.prototype.openDevTools = function (option) {
        this.enabled && this.getMainWindowWebContents().openDevTools({ mode: option });
    };
    ElectronService.prototype.toggleDevTools = function () {
        this.enabled && this.getMainWindowWebContents().toggleDevTools();
    };
    ElectronService.prototype.isDevToolsOpened = function () {
        return this.enabled && this.getMainWindowWebContents().isDevToolsOpened();
    };
    ElectronService.prototype.reload = function () {
        this.enabled && this.getMainWindowWebContents().reload();
    };
    ElectronService = __decorate([
        Service('electron'),
        Inject('env'),
        __metadata("design:paramtypes", [EnvService])
    ], ElectronService);
    return ElectronService;
}());
var EnvType;
(function (EnvType) {
    EnvType[EnvType["NODEJS"] = 0] = "NODEJS";
    EnvType[EnvType["BROWSER"] = 1] = "BROWSER";
})(EnvType || (EnvType = {}));
var EnvService = (function () {
    function EnvService() {
        try {
            if (typeof window['require'] == 'function' && window['require']('child_process')) {
                this.type = EnvType.NODEJS;
            }
            else {
                this.type = EnvType.BROWSER;
            }
        }
        catch (e) {
            this.type = EnvType.BROWSER;
        }
    }
    EnvService.prototype.isBrowser = function () {
        return this.type == EnvType.BROWSER;
    };
    EnvService = __decorate([
        Service('env'),
        __metadata("design:paramtypes", [])
    ], EnvService);
    return EnvService;
}());
var EthBlockExplorerHeatNodeService = (function () {
    function EthBlockExplorerHeatNodeService($q, http, settingsService, web3) {
        var _this = this;
        this.$q = $q;
        this.http = http;
        this.settingsService = settingsService;
        this.web3 = web3;
        this.tokenInfoCache = {};
        this.providerName = 'HEAT';
        this.cachedGetCachedAccountBalance = new Map();
        this.cachedAddressInfo = new Map();
        this.getCachedAccountBalance = function (address) {
            var v = _this.cachedGetCachedAccountBalance.get(address);
            if (v)
                return v;
            var deferred = _this.$q.defer();
            _this.cachedGetCachedAccountBalance.set(address, deferred.promise);
            _this.getBalanceFromChain(address).then(deferred.resolve, deferred.reject);
            _this.cachedGetCachedAccountBalance.get(address).finally(function () {
                setTimeout(function () {
                    _this.cachedGetCachedAccountBalance.set(address, null);
                }, 30 * 1000);
            });
            return _this.cachedGetCachedAccountBalance.get(address);
        };
        this.getBalance = function (address) {
            var deferred = _this.$q.defer();
            _this.getCachedAccountBalance(address).then(function (parsed) {
                var balance = _this.web3.web3.fromWei(parsed, 'ether');
                deferred.resolve(balance);
            });
            return deferred.promise;
        };
        this.getCachedAddressInfo = function (address) {
            var v = _this.cachedAddressInfo.get(address);
            if (v)
                return v;
            var deferred = _this.$q.defer();
            deferred.promise.finally(function () {
                setTimeout(function () {
                    _this.cachedAddressInfo.set(address, null);
                }, 60 * 1000);
            });
            _this.cachedAddressInfo.set(address, deferred.promise);
            _this.getAddressInfo(address, false).then(deferred.resolve, deferred.reject);
            return _this.cachedAddressInfo.get(address);
        };
        EthBlockExplorerHeatNodeService_1.endPoint = 'https://eth1.heatwallet.com/api/v2';
        http.get('https://raw.githubusercontent.com/dmdeklerk/ethereum-lists/master/dist/tokens/eth/tokens-eth.min.json').then(function (response) {
            var array = angular.isString(response) ? JSON.parse(response) : response;
            array.forEach(function (x) {
                _this.tokenInfoCache[x.address] = {
                    address: x.address,
                    totalSupply: 0,
                    name: x.name,
                    symbol: x.symbol,
                    decimals: x.decimals
                };
            });
        });
    }
    EthBlockExplorerHeatNodeService_1 = EthBlockExplorerHeatNodeService;
    EthBlockExplorerHeatNodeService.prototype.getProviderName = function () { return this.providerName; };
    EthBlockExplorerHeatNodeService.prototype.isSyncing = function () {
        var deferred = this.$q.defer();
        this.http.get(EthBlockExplorerHeatNodeService_1.endPoint).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed && parsed.blockbook && parsed.blockbook.inSync && parsed.blockbook.coin === 'Ethereum')
                deferred.resolve();
            else
                deferred.reject();
        }, function () {
            deferred.reject();
        }).catch(function () { return deferred.reject(); });
        return deferred.promise;
    };
    EthBlockExplorerHeatNodeService.prototype.getBalanceFromChain = function (address) {
        var deferred = this.$q.defer();
        this.getAddressInfo(address).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed.balance);
        }, function () {
            deferred.resolve("0");
        });
        return deferred.promise;
    };
    EthBlockExplorerHeatNodeService.prototype.getTransactionCount = function (address) {
        var getTxInfoApi = "".concat(EthBlockExplorerHeatNodeService_1.endPoint, "/address/").concat(address, "?details=basics");
        var deferred = this.$q.defer();
        this.http.get(getTxInfoApi).then(function (response) {
            var _a;
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(((_a = parsed.txids) === null || _a === void 0 ? void 0 : _a.length) || parsed.txs);
        }, function (e) {
            console.log(e);
            deferred.reject(e);
        });
        return deferred.promise;
    };
    EthBlockExplorerHeatNodeService.prototype.getTxInfo = function (txId) {
        var getTxInfoApi = "".concat(EthBlockExplorerHeatNodeService_1.endPoint, "/tx/").concat(txId);
        var deferred = this.$q.defer();
        this.http.get(getTxInfoApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    EthBlockExplorerHeatNodeService.prototype.broadcast = function (txObject) {
        var sendTxApi = "".concat(EthBlockExplorerHeatNodeService_1.endPoint, "/sendtx/").concat(txObject);
        var deferred = this.$q.defer();
        this.http.get(sendTxApi).then(function (response) {
            var r = angular.isString(response) ? JSON.parse(response) : response;
            if (r.error)
                deferred.reject(r.error);
            else
                deferred.resolve({ txId: r.result });
        }, function (error) {
            deferred.reject(error);
        });
        return deferred.promise;
    };
    EthBlockExplorerHeatNodeService.prototype.getAddressInfo = function (address, useCache) {
        var _this = this;
        if (useCache === void 0) { useCache = false; }
        if (useCache) {
            return this.getCachedAddressInfo(address);
        }
        var deferred = this.$q.defer();
        var url = "".concat(EthBlockExplorerHeatNodeService_1.endPoint, "/address/").concat(address, "?details=tokenBalances");
        this.http.get(url).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed.tokens) {
                parsed.tokens.forEach(function (token) {
                    var tokenInfo = {
                        address: token.contract,
                        decimals: token.decimals,
                        symbol: token.symbol,
                        name: token.name
                    };
                    token.tokenInfo = tokenInfo;
                    _this.tokenInfoCache[token.tokenInfo.address] = token.tokenInfo;
                });
            }
            parsed.ETH = {};
            parsed.ETH.balance = _this.web3.web3.fromWei(parsed.balance, 'ether');
            wlt.saveCurrencyBalance(address, "ETH", parsed.ETH.balance);
            deferred.resolve(parsed);
        }, function (error) {
            deferred.reject(error);
        });
        return deferred.promise;
    };
    EthBlockExplorerHeatNodeService.prototype.getAddressTransactions = function (address, pageNum) {
        var deferred = this.$q.defer();
        var getTransactionsApi = "".concat(EthBlockExplorerHeatNodeService_1.endPoint, "/address/").concat(address, "?details=txs&page=").concat(pageNum, "&pageSize=20");
        this.http.get(getTransactionsApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed.transactions && parsed.transactions.length > 0)
                deferred.resolve(parsed.transactions);
            deferred.resolve([]);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    var EthBlockExplorerHeatNodeService_1;
    EthBlockExplorerHeatNodeService = EthBlockExplorerHeatNodeService_1 = __decorate([
        Service('ethBlockExplorerHeatNodeService'),
        Inject('$q', 'http', 'settings', 'web3'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            Web3Service])
    ], EthBlockExplorerHeatNodeService);
    return EthBlockExplorerHeatNodeService;
}());
var EthBlockExplorerService = (function () {
    function EthBlockExplorerService($q, ethplorer, ethBlockExplorerHeatNodeService, http, web3) {
        var _this = this;
        this.$q = $q;
        this.ethplorer = ethplorer;
        this.ethBlockExplorerHeatNodeService = ethBlockExplorerHeatNodeService;
        this.http = http;
        this.web3 = web3;
        this.tokenInfoCache = {};
        setInterval(function () { return _this.refresh(); }, 5 * 60 * 1000);
    }
    EthBlockExplorerService.prototype.getProviderName = function () { return this.ethApiProvider.getProviderName(); };
    EthBlockExplorerService.prototype.refresh = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.ethBlockExplorerHeatNodeService.isSyncing().then(function () {
                _this.ethApiProvider = _this.ethBlockExplorerHeatNodeService;
            }).catch(function () {
                _this.ethApiProvider = _this.ethplorer;
            }).finally(function () {
                _this.tokenInfoCache = _this.ethApiProvider.tokenInfoCache;
                resolve(null);
            });
        });
    };
    EthBlockExplorerService.prototype.getBalance = function (address) {
        return this.ethApiProvider.getBalance(address);
    };
    EthBlockExplorerService.prototype.getTxInfo = function (txId) {
        return this.ethApiProvider.getTxInfo(txId);
    };
    EthBlockExplorerService.prototype.broadcast = function (rawTx) {
        return this.ethApiProvider.broadcast(rawTx);
    };
    EthBlockExplorerService.prototype.getTransactionCount = function (address) {
        return this.ethApiProvider.getTransactionCount(address);
    };
    EthBlockExplorerService.prototype.getAddressTransactions = function (address, pageNum) {
        var _this = this;
        var deferred = this.$q.defer();
        if (this.ethApiProvider.getProviderName() === 'HEAT') {
            this.ethApiProvider.getAddressTransactions(address, pageNum).then(function (response) {
                _this.convertAddressTransactions(response);
                deferred.resolve(response);
            }, deferred.reject);
        }
        else {
            this.ethApiProvider.getAddressTransactions(address).then(function (response) { return deferred.resolve(response); }, deferred.reject);
        }
        return deferred.promise;
    };
    EthBlockExplorerService.prototype.getAddressInfo = function (address, useCache) {
        if (useCache === void 0) { useCache = false; }
        return this.ethApiProvider.getAddressInfo(address, useCache);
    };
    EthBlockExplorerService.prototype.convertAddressTransactions = function (transactions) {
        var _this = this;
        transactions.forEach(function (tx) {
            tx.from = tx.vin[0].addresses[0];
            tx.to = tx.vout[0].addresses[0];
            tx.hash = tx.txid;
            tx.value = _this.web3.web3.fromWei(tx.vout[0].value, 'ether');
            tx.input = '';
            tx.success = '';
            tx.timestamp = tx.blockTime;
        });
    };
    EthBlockExplorerService = __decorate([
        Service('ethBlockExplorerService'),
        Inject('$q', 'ethplorer', 'ethBlockExplorerHeatNodeService', 'http', 'web3'),
        __metadata("design:paramtypes", [Function, EthplorerService,
            EthBlockExplorerHeatNodeService,
            HttpService,
            Web3Service])
    ], EthBlockExplorerService);
    return EthBlockExplorerService;
}());
var EthereumPendingTransactionsService = (function () {
    function EthereumPendingTransactionsService($q, http, settings, web3, ethBlockExplorerService) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.web3 = web3;
        this.ethBlockExplorerService = ethBlockExplorerService;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    EthereumPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('ethPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txHash = parts[2], timestamp = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txHash: txHash, timestamp: timestamp });
            }
        }
    };
    EthereumPendingTransactionsService.prototype.add = function (address, txHash, timestamp) {
        window.localStorage.setItem("ethPendingTxn:".concat(address, ":").concat(txHash, ":").concat(timestamp), "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    EthereumPendingTransactionsService.prototype.remove = function (address, txHash, timestamp) {
        window.localStorage.removeItem("ethPendingTxn:".concat(address, ":").concat(txHash, ":").concat(timestamp));
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    EthereumPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    EthereumPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    EthereumPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    EthereumPendingTransactionsService = __decorate([
        Service('ethereumPendingTransactions'),
        Inject('$q', 'http', 'settings', 'web3', 'ethBlockExplorerService'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            Web3Service,
            EthBlockExplorerService])
    ], EthereumPendingTransactionsService);
    return EthereumPendingTransactionsService;
}());
var EthplorerTransactionPaginator = (function () {
    function EthplorerTransactionPaginator(address, ethplorer) {
        this.address = address;
        this.ethplorer = ethplorer;
        this.pool = [];
        this.endReached = false;
        this.$q = this.ethplorer.$q;
    }
    EthplorerTransactionPaginator.prototype.getNextBatch = function () {
        var _this = this;
        var deferred = this.$q.defer();
        if (this.endReached) {
            deferred.resolve(false);
        }
        else {
            var timestamp = this.pool.length ? this.pool[this.pool.length - 1].timestamp : 0;
            this.ethplorer.getAddressTransactions(this.address, timestamp).then(function (transactions) {
                transactions.forEach(function (txn) {
                    if (!_this.pool.find(function (tx) { return tx.hash == txn.hash; })) {
                        _this.pool.push(txn);
                    }
                });
                _this.endReached = transactions.length != 50;
                deferred.resolve(!_this.endReached);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    EthplorerTransactionPaginator.prototype.ensurePoolLength = function (minLength) {
        var _this = this;
        var deferred = this.$q.defer();
        if (this.pool.length > minLength) {
            deferred.resolve(this.pool.length);
        }
        else {
            this.getNextBatch().then(function (hasMore) {
                if (_this.pool.length - 1 > minLength || !hasMore) {
                    deferred.resolve(_this.pool.length);
                }
                else {
                    _this.getNextBatch().then(function (hasMore) {
                        if (_this.pool.length - 1 > minLength || !hasMore) {
                            deferred.resolve(_this.pool.length);
                        }
                        else {
                            _this.getNextBatch().then(function (hasMore) {
                                deferred.resolve(_this.pool.length);
                            }, deferred.reject);
                        }
                    }, deferred.reject);
                }
            }, deferred.reject);
        }
        return deferred.promise;
    };
    EthplorerTransactionPaginator.prototype.getCount = function () {
        var deferred = this.$q.defer();
        this.ethplorer.getTransactionCount(this.address).then(function (count) {
            deferred.resolve(Math.min(count, 1000));
        }, deferred.reject);
        return deferred.promise;
    };
    EthplorerTransactionPaginator.prototype.getItems = function (from, to) {
        var _this = this;
        var deferred = this.$q.defer();
        this.ensurePoolLength(to - 1).then(function (poolLength) {
            var result = [];
            for (var i = from; i < to; i++) {
                result.push(_this.pool[i]);
            }
            deferred.resolve(result);
        }, deferred.reject);
        return deferred.promise;
    };
    return EthplorerTransactionPaginator;
}());
var EthplorerService = (function () {
    function EthplorerService($q, http, settingsService, web3) {
        var _this = this;
        this.$q = $q;
        this.http = http;
        this.settingsService = settingsService;
        this.web3 = web3;
        this.providerName = 'Ethplorer';
        this.tokenInfoCache = {};
        this.cachedGetCachedAddressInfo = {};
        EthplorerService_1.endPoint = 'https://api.ethplorer.io';
        http.get('https://raw.githubusercontent.com/dmdeklerk/ethereum-lists/master/dist/tokens/eth/tokens-eth.min.json').then(function (response) {
            var array = angular.isString(response) ? JSON.parse(response) : response;
            array.forEach(function (x) {
                _this.tokenInfoCache[x.address] = {
                    address: x.address,
                    totalSupply: 0,
                    name: x.name,
                    symbol: x.symbol,
                    decimals: x.decimals
                };
            });
        });
    }
    EthplorerService_1 = EthplorerService;
    EthplorerService.prototype.getProviderName = function () { return this.providerName; };
    EthplorerService.prototype.createPaginator = function (address) {
        return new EthplorerTransactionPaginator(address, this);
    };
    EthplorerService.prototype.getTransactionCount = function (address) {
        var deferred = this.$q.defer();
        this.getCachedAddressInfo(address).then(function (info) {
            deferred.resolve(info.countTxs);
        }, deferred.reject);
        return deferred.promise;
    };
    EthplorerService.prototype.getBalance = function (address) {
        var deferred = this.$q.defer();
        this.getCachedAddressInfo(address).then(function (info) {
            deferred.resolve(info.ETH.balance);
        }, deferred.reject);
        return deferred.promise;
    };
    EthplorerService.prototype.getCachedAddressInfo = function (address) {
        var _this = this;
        var v = this.cachedGetCachedAddressInfo[address];
        if (v)
            return v;
        var deferred = this.$q.defer();
        this.cachedGetCachedAddressInfo[address] = deferred.promise;
        this.getAddressInfo(address, false).then(deferred.resolve, deferred.reject);
        this.cachedGetCachedAddressInfo[address].finally(function () {
            setTimeout(function () {
                _this.cachedGetCachedAddressInfo[address] = null;
            }, 60 * 1000);
        });
        return this.cachedGetCachedAddressInfo[address];
    };
    EthplorerService.prototype.getAddressInfo = function (address, useCache) {
        var _this = this;
        if (useCache === void 0) { useCache = false; }
        if (useCache) {
            return this.getCachedAddressInfo(address);
        }
        var deferred = this.$q.defer();
        var url = "".concat(EthplorerService_1.endPoint, "/getAddressInfo/").concat(address, "?apiKey=lwA5173TDKj60");
        this.http.get(url)
            .then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed.error) {
                console.log("Ethplorer Error: ".concat(JSON.stringify(parsed)));
                deferred.reject(parsed.error);
            }
            else {
                var info = parsed;
                if (info.tokens) {
                    info.tokens.forEach(function (token) {
                        if (token.tokenInfo) {
                            _this.tokenInfoCache[token.tokenInfo.address] = token.tokenInfo;
                        }
                    });
                }
                deferred.resolve(info);
            }
        }, function (reason) {
            console.log("HTTP reject for ".concat(url, ": ").concat(reason));
            deferred.reject();
        });
        return deferred.promise;
    };
    EthplorerService.prototype.getAddressTransactions = function (address, timestamp, showZeroValues) {
        var deferred = this.$q.defer();
        showZeroValues = showZeroValues || 1;
        var url = "".concat(EthplorerService_1.endPoint, "/getAddressTransactions/").concat(address, "?apiKey=lwA5173TDKj60&limit=50&timestamp=").concat(timestamp, "&showZeroValues=").concat(showZeroValues);
        this.http.get(url)
            .then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed.error) {
                console.log("Ethplorer Error: ".concat(JSON.stringify(parsed)));
                deferred.resolve([]);
            }
            else {
                deferred.resolve(parsed);
            }
        }, function (reason) {
            deferred.reject(reason);
        }, deferred.reject);
        return deferred.promise;
    };
    EthplorerService.prototype.broadcast = function (rawTx) {
        var deferred = this.$q.defer();
        var url = "https://api.blockcypher.com/v1/eth/main/txs/push?token=d7995959366d4369976aabb3355c7216";
        this.http.post(url, { tx: rawTx }).then(function (response) {
            response.txId = response.hash;
            deferred.resolve(response);
        }, function (e) {
            deferred.reject('Error broadcasting transaction');
        });
        return deferred.promise;
    };
    EthplorerService.prototype.getTxInfo = function (txHash) {
        var deferred = this.$q.defer();
        var url = "".concat(EthplorerService_1.endPoint, "/getTxInfo/").concat(txHash, "?apiKey=lwA5173TDKj60");
        this.http.get(url)
            .then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed.error) {
                console.log("Ethplorer Error: ".concat(JSON.stringify(parsed)));
                deferred.reject(parsed.error);
            }
            else {
                deferred.resolve(parsed);
            }
        }, function (error) {
            console.log("HTTP reject for ".concat(url));
            deferred.reject(error);
        });
        return deferred.promise;
    };
    EthplorerService.prototype.getTopTokens = function () {
        var deferred = this.$q.defer();
        var url = "".concat(EthplorerService_1.endPoint, "/getTop?apiKey=lwA5173TDKj60");
        this.http.get(url).then(function (response) {
            deferred.resolve();
        }, function (error) {
            deferred.reject();
        }).catch(function () { return deferred.reject(); });
        return deferred.promise;
    };
    var EthplorerService_1;
    EthplorerService = EthplorerService_1 = __decorate([
        Service('ethplorer'),
        Inject('$q', 'http', 'settings', 'web3'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            Web3Service])
    ], EthplorerService);
    return EthplorerService;
}());
var EthTransactionParserService = (function () {
    function EthTransactionParserService($q, abiDecoder, http, settings, ethBlockExplorerService) {
        this.$q = $q;
        this.abiDecoder = abiDecoder;
        this.http = http;
        this.settings = settings;
        this.ethBlockExplorerService = ethBlockExplorerService;
        this.erc20Abi = [{ "constant": true, "inputs": [], "name": "name", "outputs": [{ "name": "", "type": "string" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "_spender", "type": "address" }, { "name": "_value", "type": "uint256" }], "name": "approve", "outputs": [{ "name": "success", "type": "bool" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "totalSupply", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }], "name": "transferFrom", "outputs": [{ "name": "success", "type": "bool" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "name": "", "type": "uint8" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "version", "outputs": [{ "name": "", "type": "string" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "_owner", "type": "address" }], "name": "balanceOf", "outputs": [{ "name": "balance", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "name": "", "type": "string" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }], "name": "transfer", "outputs": [{ "name": "success", "type": "bool" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "_spender", "type": "address" }, { "name": "_value", "type": "uint256" }, { "name": "_extraData", "type": "bytes" }], "name": "approveAndCall", "outputs": [{ "name": "success", "type": "bool" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "_owner", "type": "address" }, { "name": "_spender", "type": "address" }], "name": "allowance", "outputs": [{ "name": "remaining", "type": "uint256" }], "payable": false, "type": "function" }, { "inputs": [{ "name": "_initialAmount", "type": "uint256" }, { "name": "_tokenName", "type": "string" }, { "name": "_decimalUnits", "type": "uint8" }, { "name": "_tokenSymbol", "type": "string" }], "type": "constructor" }, { "payable": false, "type": "fallback" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_from", "type": "address" }, { "indexed": true, "name": "_to", "type": "address" }, { "indexed": false, "name": "_value", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_owner", "type": "address" }, { "indexed": true, "name": "_spender", "type": "address" }, { "indexed": false, "name": "_value", "type": "uint256" }], "name": "Approval", "type": "event" }];
        this.etherDeltaAbi = [{ "constant": false, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "user", "type": "address" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }, { "name": "amount", "type": "uint256" }], "name": "trade", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }], "name": "order", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "", "type": "address" }, { "name": "", "type": "bytes32" }], "name": "orderFills", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }], "name": "cancelOrder", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "amount", "type": "uint256" }], "name": "withdraw", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "token", "type": "address" }, { "name": "amount", "type": "uint256" }], "name": "depositToken", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "user", "type": "address" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }], "name": "amountFilled", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "", "type": "address" }, { "name": "", "type": "address" }], "name": "tokens", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "feeMake_", "type": "uint256" }], "name": "changeFeeMake", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "feeMake", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "feeRebate_", "type": "uint256" }], "name": "changeFeeRebate", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "feeAccount", "outputs": [{ "name": "", "type": "address" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "user", "type": "address" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }, { "name": "amount", "type": "uint256" }, { "name": "sender", "type": "address" }], "name": "testTrade", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "feeAccount_", "type": "address" }], "name": "changeFeeAccount", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "feeRebate", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "feeTake_", "type": "uint256" }], "name": "changeFeeTake", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "admin_", "type": "address" }], "name": "changeAdmin", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "token", "type": "address" }, { "name": "amount", "type": "uint256" }], "name": "withdrawToken", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "", "type": "address" }, { "name": "", "type": "bytes32" }], "name": "orders", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "feeTake", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [], "name": "deposit", "outputs": [], "payable": true, "type": "function" }, { "constant": false, "inputs": [{ "name": "accountLevelsAddr_", "type": "address" }], "name": "changeAccountLevelsAddr", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "accountLevelsAddr", "outputs": [{ "name": "", "type": "address" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "token", "type": "address" }, { "name": "user", "type": "address" }], "name": "balanceOf", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "admin", "outputs": [{ "name": "", "type": "address" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "user", "type": "address" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }], "name": "availableVolume", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "inputs": [{ "name": "admin_", "type": "address" }, { "name": "feeAccount_", "type": "address" }, { "name": "accountLevelsAddr_", "type": "address" }, { "name": "feeMake_", "type": "uint256" }, { "name": "feeTake_", "type": "uint256" }, { "name": "feeRebate_", "type": "uint256" }], "payable": false, "type": "constructor" }, { "payable": false, "type": "fallback" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "tokenGet", "type": "address" }, { "indexed": false, "name": "amountGet", "type": "uint256" }, { "indexed": false, "name": "tokenGive", "type": "address" }, { "indexed": false, "name": "amountGive", "type": "uint256" }, { "indexed": false, "name": "expires", "type": "uint256" }, { "indexed": false, "name": "nonce", "type": "uint256" }, { "indexed": false, "name": "user", "type": "address" }], "name": "Order", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "tokenGet", "type": "address" }, { "indexed": false, "name": "amountGet", "type": "uint256" }, { "indexed": false, "name": "tokenGive", "type": "address" }, { "indexed": false, "name": "amountGive", "type": "uint256" }, { "indexed": false, "name": "expires", "type": "uint256" }, { "indexed": false, "name": "nonce", "type": "uint256" }, { "indexed": false, "name": "user", "type": "address" }, { "indexed": false, "name": "v", "type": "uint8" }, { "indexed": false, "name": "r", "type": "bytes32" }, { "indexed": false, "name": "s", "type": "bytes32" }], "name": "Cancel", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "tokenGet", "type": "address" }, { "indexed": false, "name": "amountGet", "type": "uint256" }, { "indexed": false, "name": "tokenGive", "type": "address" }, { "indexed": false, "name": "amountGive", "type": "uint256" }, { "indexed": false, "name": "get", "type": "address" }, { "indexed": false, "name": "give", "type": "address" }], "name": "Trade", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "token", "type": "address" }, { "indexed": false, "name": "user", "type": "address" }, { "indexed": false, "name": "amount", "type": "uint256" }, { "indexed": false, "name": "balance", "type": "uint256" }], "name": "Deposit", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "token", "type": "address" }, { "indexed": false, "name": "user", "type": "address" }, { "indexed": false, "name": "amount", "type": "uint256" }, { "indexed": false, "name": "balance", "type": "uint256" }], "name": "Withdraw", "type": "event" }];
        this.abiDecoder.addABI(this.erc20Abi);
        this.abiDecoder.addABI(this.etherDeltaAbi);
    }
    EthTransactionParserService.prototype.parse = function (transactions) {
        var _this = this;
        var result = [];
        transactions.forEach(function (transaction) {
            if (!transaction)
                return;
            var extended = transaction;
            result.push(extended);
            var tokenInfo = _this.ethBlockExplorerService.tokenInfoCache[transaction.to];
            if (tokenInfo) {
                extended.abi = {
                    symbol: tokenInfo.symbol,
                    name: tokenInfo.name,
                    decimals: tokenInfo.decimals,
                    address: tokenInfo.address,
                    decodedData: null
                };
                try {
                    extended.abi.decodedData = _this.abiDecoder.decodeMethod(transaction.input);
                }
                catch (e) {
                    console.log(e);
                }
            }
        });
        return result;
    };
    EthTransactionParserService = __decorate([
        Service('ethTransactionParser'),
        Inject('$q', 'abiDecoder', 'http', 'settings', 'ethBlockExplorerService'),
        __metadata("design:paramtypes", [Function, AbiDecoderService,
            HttpService,
            SettingsService,
            EthBlockExplorerService])
    ], EthTransactionParserService);
    return EthTransactionParserService;
}());
var FIMKCryptoService = (function () {
    function FIMKCryptoService($window, mofoSocketService, $rootScope, storage) {
        this.$window = $window;
        this.mofoSocketService = mofoSocketService;
        this.$rootScope = $rootScope;
        this.nxtCrypto = $window.heatlibs.nxtCrypto;
        this.store = storage.namespace('wallet-address', $rootScope, true);
    }
    FIMKCryptoService.prototype.unlock = function (seedOrPrivateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var heatAddress = heat.crypto.getAccountId(seedOrPrivateKey);
            var encryptedWallet = _this.store.get("FIM-".concat(heatAddress));
            if (encryptedWallet) {
                if (!encryptedWallet.data) {
                    _this.store.remove("FIM-".concat(heatAddress));
                    _this.unlock(seedOrPrivateKey);
                }
                var decryptedWallet = heat.crypto.decryptMessage(encryptedWallet.data, encryptedWallet.nonce, heatAddress, seedOrPrivateKey);
                resolve(JSON.parse(decryptedWallet));
            }
            else {
                var walletType = { addresses: [] };
                walletType.addresses[0] = { address: _this.nxtCrypto.getAccountRSFromSecretPhrase(seedOrPrivateKey, 'FIM'), privateKey: seedOrPrivateKey };
                var encryptedWallet_6 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seedOrPrivateKey);
                _this.store.put("FIM-".concat(heatAddress), encryptedWallet_6);
                resolve(walletType);
            }
        });
    };
    FIMKCryptoService.prototype.refreshBalances = function (wallet) {
        var address = wallet.addresses[0].address;
        return new Promise(function (resolve, reject) {
            var mofoSocketService = heat.$inject.get('mofoSocketService');
            mofoSocketService.mofoSocket().then(function () {
                mofoSocketService.getTransactions(address).then(function (transactions) {
                    mofoSocketService.getAccount(address).then(function (info) {
                        wallet.addresses[0].inUse = true;
                        var balance = parseInt(info.unconfirmedBalanceNQT) / 100000000;
                        var formattedBalance = new Big(balance + "");
                        var balanceUnconfirmed = new Big(formattedBalance).toFixed(8);
                        wallet.addresses[0].balance = balanceUnconfirmed;
                        mofoSocketService.getAccountAssets(address).then(function (accountAssets) {
                            wallet.addresses[0].tokensBalances = [];
                            accountAssets.forEach(function (asset) {
                                wallet.addresses[0].tokensBalances.push({
                                    symbol: asset ? asset.name : '',
                                    name: asset ? asset.name : '',
                                    decimals: asset.decimals,
                                    balance: utils.formatQNT(asset.unconfirmedQuantityQNT, asset.decimals),
                                    address: asset.asset
                                });
                            });
                            resolve(true);
                        });
                    });
                }, function (err) {
                    if (err)
                        console.error(err);
                    resolve(false);
                });
            }).catch(reject);
        });
    };
    FIMKCryptoService = __decorate([
        Service('fimkCryptoService'),
        Inject('$window', 'mofoSocketService', '$rootScope', 'storage'),
        __metadata("design:paramtypes", [Object, MofoSocketService, Object, StorageService])
    ], FIMKCryptoService);
    return FIMKCryptoService;
}());
var FimkPendingTransactionsService = (function () {
    function FimkPendingTransactionsService($q, http, settings, mofoSocketService) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.mofoSocketService = mofoSocketService;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    FimkPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('fimkPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    FimkPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("fimkPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp), "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    FimkPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("fimkPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp));
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    FimkPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    FimkPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    FimkPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    FimkPendingTransactionsService = __decorate([
        Service('fimkPendingTransactions'),
        Inject('$q', 'http', 'settings', 'mofoSocketService'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            MofoSocketService])
    ], FimkPendingTransactionsService);
    return FimkPendingTransactionsService;
}());
var HttpService = (function () {
    function HttpService($http, env, $q) {
        this.$http = $http;
        this.env = env;
        this.$q = $q;
        this.throttled = ['https://blockexplorer.com', 'https://api.ethplorer.io', 'https://insight.bitpay.com'];
        this.queues = [];
        for (var i = 0; i < this.throttled.length; i++)
            this.queues.push([]);
    }
    HttpService_1 = HttpService;
    HttpService.prepareUrl = function (url, forcedApiKey) {
        if (forcedApiKey === void 0) { forcedApiKey = false; }
        if (!SettingsService.REQ_API_KEY_URLS)
            return url;
        if (!forcedApiKey && !SettingsService.REQ_API_KEY_URLS.find(function (search) { return url.indexOf(search) > -1; }))
            return url;
        var s = "apiKey=" + SettingsService.apiKey;
        return url.indexOf("?") == -1
            ? url + "?" + s
            : url + "&" + s;
    };
    HttpService.prototype.waitTurn = function (url, promise) {
        var index = -1;
        for (var i = 0; i < this.throttled.length; i++) {
            if (url.startsWith(this.throttled[i])) {
                index = i;
                break;
            }
        }
        if (index == -1) {
            var deferred_2 = this.$q.defer();
            deferred_2.resolve();
            return deferred_2.promise;
        }
        var queue = this.queues[index];
        var nextRequest = queue[queue.length - 1];
        var request = {
            url: url,
            promise: promise
        };
        queue.push(request);
        request.promise.finally(function () {
            var i = queue.indexOf(request);
            if (i != -1)
                queue.splice(i, 1);
        });
        var deferred = this.$q.defer();
        if (nextRequest) {
            nextRequest.promise.finally(deferred.resolve);
        }
        else {
            deferred.resolve();
        }
        return deferred.promise;
    };
    HttpService.prototype.get = function (url, forcedApiKey) {
        var _this = this;
        if (forcedApiKey === void 0) { forcedApiKey = false; }
        url = HttpService_1.prepareUrl(url, forcedApiKey);
        var deferred = this.$q.defer();
        var promise = deferred.promise;
        this.waitTurn(url, promise).then(function () {
            if (_this.env.type == EnvType.BROWSER) {
                _this.browserHttpGet(url, deferred.resolve, deferred.reject);
            }
            else {
                _this.nodeHttpGet(url, deferred.resolve, deferred.reject);
            }
        });
        return promise;
    };
    HttpService.prototype.browserHttpGet = function (url, onSuccess, onFailure) {
        this.$http.get(url, {
            headers: {
                'Content-Type': 'application/text'
            }
        }).then(function (response) { onSuccess(response.data); }, function (response) { onFailure(response.data); });
    };
    HttpService.prototype.nodeHttpGet = function (url, onSuccess, onFailure) {
        var _url = require('url').parse(url);
        var options = {
            hostname: _url.hostname, port: _url.port, path: _url.path, method: 'GET',
            headers: {
                'Content-Type': 'application/text'
            }
        };
        var http = require(_url.protocol.indexOf('https') == 0 ? 'https' : 'http');
        var req = http.request(options, function (res) {
            res.setEncoding('utf8');
            var body = [];
            res.on('data', function (chunk) {
                body.push(chunk);
            });
            res.on('end', function () {
                onSuccess(body.join(''));
            });
        });
        req.on('error', function (e) {
            onFailure(e);
        });
        req.end();
    };
    HttpService.prototype.post = function (url, data) {
        var deferred = this.$q.defer();
        if (this.env.type == EnvType.BROWSER) {
            this.browserHttpPost(url, data, deferred.resolve, deferred.reject);
        }
        else {
            var a = document.createElement('a');
            a.href = url;
            var hostname = a.hostname;
            var isHttps = a.protocol == 'https:';
            var port = a.port ? parseInt(a.port) : (isHttps ? 443 : 80);
            var path = a.pathname;
            this.nodeHttpPost(isHttps, hostname, port, path, data, deferred.resolve, deferred.reject);
        }
        return deferred.promise;
    };
    HttpService.prototype.browserHttpPost = function (url, data, onSuccess, onFailure) {
        this.$http({
            method: 'POST',
            url: url,
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            transformRequest: function (obj) {
                var str = [];
                for (var p in obj)
                    str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                return str.join("&");
            },
            data: data
        }).then(function (response) { onSuccess(response.data); }, function (response) { onFailure(response.data); });
    };
    HttpService.prototype.nodeHttpPost = function (isHttps, hostname, port, path, request, onSuccess, onFailure) {
        var querystring = require('querystring');
        var body = querystring.stringify(request);
        var options = {
            hostname: hostname, port: port, path: path, method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                "Content-Length": body.length
            }
        };
        var http = require(isHttps ? 'https' : 'http');
        var req = http.request(options, function (res) {
            res.setEncoding('utf8');
            var body = [];
            res.on('data', function (chunk) { body.push(chunk); });
            res.on('end', function () {
                onSuccess(JSON.parse(body.join('')));
            });
        });
        req.on('error', function (e) { onFailure(e); });
        req.write(body);
        req.end();
    };
    var HttpService_1;
    HttpService = HttpService_1 = __decorate([
        Service('http'),
        Inject('$http', 'env', '$q'),
        __metadata("design:paramtypes", [Function, EnvService, Function])
    ], HttpService);
    return HttpService;
}());
var IotaBlockExplorerService = (function () {
    function IotaBlockExplorerService($q, http, $window, settingsService) {
        var _this = this;
        this.$q = $q;
        this.http = http;
        this.$window = $window;
        this.settingsService = settingsService;
        this.cachedGetCachedAccountInfo = new Map();
        this.getTransactions = function (seed, startKeyIndex, security) {
            if (startKeyIndex === void 0) { startKeyIndex = 0; }
            if (security === void 0) { security = 2; }
            var deferred = _this.$q.defer();
            _this.iotaAPI
                .then(function (api) { return api.getAccountData(seed, { start: startKeyIndex, security: security }); })
                .then(function (accountData) {
                var data = JSON.parse(typeof accountData === "string" ? accountData : JSON.stringify(accountData));
                if (data.transfers) {
                    deferred.resolve(data);
                }
                else {
                    deferred.reject("Unable to fetch IOTA address data");
                }
            }, function (reason) {
                deferred.reject(reason);
            })
                .catch(function (reason) { return console.error(reason); });
            return deferred.promise;
        };
        this.getAccountInfo = function (seed, startKeyIndex, security) {
            if (startKeyIndex === void 0) { startKeyIndex = 0; }
            if (security === void 0) { security = 2; }
            var result = _this.cachedGetCachedAccountInfo.get(seed);
            if (result)
                return result;
            result = _this.iotaAPI
                .then(function (api) { return api.getAccountData(seed, { start: startKeyIndex, security: security }); })
                .then(function (accountData) {
                var collapsed = _this.collapseTransfers(accountData.transfers).filter(function (v) { return !!v; });
                var v = { accountData: accountData, transfers: collapsed };
                return v;
            });
            setTimeout(function () {
                _this.cachedGetCachedAccountInfo.set(seed, null);
            }, 60 * 1000);
            _this.cachedGetCachedAccountInfo.set(seed, result);
            return result;
        };
        this.sendIota = function (seed, transfers) {
            var deferred = _this.$q.defer();
            var depth = 3;
            var minWeightMagnitude = 14;
            _this.iotaAPI.then(function (api) {
                api.prepareTransfers(seed, transfers)
                    .then(function (trytes) { return api.sendTrytes(trytes, depth, minWeightMagnitude); })
                    .then(function (bundle) { return deferred.resolve(bundle); })
                    .catch(function (err) {
                    deferred.reject(err);
                });
            });
            return deferred.promise;
        };
        this.getBalance = function (address) {
            if (address.length === 90)
                address = address.slice(0, 81);
            var deferred = _this.$q.defer();
            _this.iotaAPI
                .then(function (api) { return api.getBalances([address], 100); })
                .then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                deferred.resolve(data.balances[0]);
            })
                .catch(function (err) {
                deferred.reject(err);
            });
            return deferred.promise;
        };
        this.getAddressBundles = function (address) {
            if (address.length === 90)
                address = address.slice(0, 81);
            var deferred = _this.$q.defer();
            _this.iotaAPI
                .then(function (api) { return api.getBundlesFromAddresses([address]); })
                .then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                deferred.resolve(data);
            })
                .catch(function (err) {
                deferred.reject(err);
            });
            return deferred.promise;
        };
        this.getInputs = function (seed) {
            var deferred = _this.$q.defer();
            _this.iotaAPI
                .then(function (api) { return api.getInputs(seed, { start: 0, security: 2 }); })
                .then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                deferred.resolve(data);
            })
                .catch(function (err) {
                deferred.reject(err);
            });
            return deferred.promise;
        };
        this.checkAddressReuse = function (address) {
            if (address.length === 90)
                address = address.slice(0, 81);
            var deferred = _this.$q.defer();
            _this.getAddressBundles(address).then(function (bundles) {
                bundles.forEach(function (transactions) {
                    transactions.forEach(function (tx) {
                        if (tx.address === address && tx.value < 0) {
                            deferred.resolve(true);
                            return true;
                        }
                    });
                });
                deferred.resolve(false);
            }).catch(function (err) {
                deferred.reject(err);
            });
            return deferred.promise;
        };
        this.iotaCore = $window.heatlibs.IotaCore;
        this.iotaAPI = new Promise(function (resolve) {
            _this.settingsService.initialized.then(function () {
                resolve(_this.iotaCore.composeAPI({ provider: SettingsService.getCryptoServerEndpoint('IOTA') }));
            });
        });
    }
    IotaBlockExplorerService.prototype.getTransfers = function (addresses) {
        return this.iotaAPI.then(function (api) {
            return api.findTransactions({ addresses: addresses })
                .then(function (hashes) { return api.getTransactionObjects(hashes); })
                .then(function (transactions) {
                var tailHashes = [];
                for (var _i = 0, transactions_1 = transactions; _i < transactions_1.length; _i++) {
                    var t = transactions_1[_i];
                    if (!t.address.startsWith("999999999999999999999999999") && t.currentIndex === 0) {
                        tailHashes.push(t.hash);
                    }
                }
                return tailHashes;
            })
                .then(function (tailHashes) {
                var result = [];
                for (var j in tailHashes) {
                    var tailHash = tailHashes[j];
                    result.push(api.getBundle(tailHash).then(function (bundle) {
                        if (bundle.length === 4) {
                            var transfer = {
                                timestamp: bundle[0].timestamp,
                                from: bundle[1].address,
                                to: bundle[0].address,
                                amount: bundle[0].value,
                                hash: bundle[0].hash,
                                trunkTransaction: bundle[bundle.length - 1].trunkTransaction,
                                branchTransaction: bundle[bundle.length - 1].branchTransaction
                            };
                            console.log(transfer);
                            return transfer;
                        }
                        return null;
                    }, function (reason) { return console.log("rejected " + reason); })
                        .catch(function (reason) {
                        console.error("Error on getting IOTA bundle: ".concat(reason));
                        return reason;
                    }));
                }
                return Promise.all(result);
            });
        });
    };
    IotaBlockExplorerService.prototype.collapseTransfers = function (transfers) {
        return transfers.map(function (v) {
            if (v.length === 4) {
                var transfer = {
                    timestamp: v[0].timestamp,
                    from: v[1].address,
                    to: v[0].address,
                    amount: v[0].value,
                    hash: v[0].hash,
                    trunkTransaction: v[v.length - 1].trunkTransaction,
                    branchTransaction: v[v.length - 1].branchTransaction
                };
                return transfer;
            }
        });
    };
    IotaBlockExplorerService = __decorate([
        Service('iotaBlockExplorerService'),
        Inject('$q', 'http', '$window', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService, Object, SettingsService])
    ], IotaBlockExplorerService);
    return IotaBlockExplorerService;
}());
var IotaCoreService = (function () {
    function IotaCoreService($window, storage, $rootScope) {
        this.$rootScope = $rootScope;
        this.iotaCore = $window.heatlibs.IotaCore;
        this.store = storage.namespace('wallet-address', $rootScope, true);
    }
    IotaCoreService.prototype.unlock = function (seed) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var heatAddress = heat.crypto.getAccountId(seed);
            var encryptedWallet = _this.store.get("IOTA-".concat(heatAddress));
            if (encryptedWallet) {
                if (!encryptedWallet.data) {
                    _this.store.remove("IOTA-".concat(heatAddress));
                    _this.unlock(seed);
                }
                var decryptedWallet = heat.crypto.decryptMessage(encryptedWallet.data, encryptedWallet.nonce, heatAddress, seed);
                resolve(JSON.parse(decryptedWallet));
            }
            else {
                var walletType = _this.getNWalletsFromMnemonics(seed, 1);
                var encryptedWallet_7 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seed);
                _this.store.put("IOTA-".concat(heatAddress), encryptedWallet_7);
                resolve(walletType);
            }
        });
    };
    IotaCoreService.prototype.getNWalletsFromMnemonics = function (mnemonic, keyCount) {
        var walletType = { addresses: [] };
        for (var i = 0; i < keyCount; i++) {
            var wallet = this.getWallet(mnemonic, i, 2);
            walletType.addresses[i] = { address: wallet.address, privateKey: wallet.privateKey, index: i, balance: "0", inUse: false };
        }
        return walletType;
    };
    IotaCoreService.prototype.getWallet = function (mnemonic, index, securityLevel) {
        if (index === void 0) { index = 0; }
        if (securityLevel === void 0) { securityLevel = 2; }
        var address = this.iotaCore.generateAddress(mnemonic, index, securityLevel, true);
        return {
            address: address,
            privateKey: mnemonic
        };
    };
    IotaCoreService.prototype.refreshBalances = function (wallet) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var secretPhrase = wallet.addresses[0].privateKey;
            var iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
            iotaBlockExplorerService.getInputs(wallet.addresses[0].privateKey).then(function (info) {
                if (info.inputs && info.inputs.length !== 0) {
                    var index = 0;
                    wallet.addresses = [];
                    info.inputs.forEach(function (input) {
                        var walletAddress = {};
                        walletAddress.inUse = true;
                        walletAddress.balance = input.balance + "";
                        walletAddress.privateKey = secretPhrase;
                        walletAddress.address = _this.getWallet(secretPhrase, input.keyIndex).address;
                        wallet.addresses.push(walletAddress);
                    });
                    var zeroBalanceAccount = _this.getWallet(secretPhrase, ++index);
                    zeroBalanceAccount.inUse = true;
                    zeroBalanceAccount.balance = "0";
                    wallet.addresses.push(zeroBalanceAccount);
                }
                else {
                    var zeroBalanceAccount = _this.getWallet(secretPhrase);
                    zeroBalanceAccount.inUse = true;
                    zeroBalanceAccount.balance = "0";
                    wallet.addresses.push(zeroBalanceAccount);
                }
                resolve(true);
            }, function () {
                resolve(false);
            });
        });
    };
    IotaCoreService = __decorate([
        Service('iotaCoreService'),
        Inject('$window', 'storage', '$rootScope'),
        __metadata("design:paramtypes", [Object, StorageService, Object])
    ], IotaCoreService);
    return IotaCoreService;
}());
var IotaPendingTransactionsService = (function () {
    function IotaPendingTransactionsService($q, http, settings) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    IotaPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('iotaPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    IotaPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("iotaPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp), "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    IotaPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("iotaPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp));
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    IotaPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    IotaPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    IotaPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    IotaPendingTransactionsService = __decorate([
        Service('iotaPendingTransactions'),
        Inject('$q', 'http', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService])
    ], IotaPendingTransactionsService);
    return IotaPendingTransactionsService;
}());
var LightwalletService = (function () {
    function LightwalletService(web3Service, userService, settingsService, $rootScope, $window, storage) {
        this.web3Service = web3Service;
        this.userService = userService;
        this.settingsService = settingsService;
        this.$rootScope = $rootScope;
        this.$window = $window;
        this.lightwallet = $window.heatlibs.lightwallet;
        this.store = storage.namespace('wallet-address', $rootScope, true);
    }
    LightwalletService_1 = LightwalletService;
    LightwalletService.prototype.generateRandomSeed = function () {
        return this.lightwallet.keystore.generateRandomSeed();
    };
    LightwalletService.prototype.validSeed = function (seed) {
        try {
            return this.lightwallet.keystore.isSeedValid(seed);
        }
        catch (e) {
            console.error("Error on seed validation: " + e);
        }
        return false;
    };
    LightwalletService.prototype.validPrivateKey = function (privKey) {
        return utils.isHex(privKey) && privKey.length == 64;
    };
    LightwalletService.prototype.unlock = function (seedOrPrivateKey, password, reset) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var heatAddress = heat.crypto.getAccountId(seedOrPrivateKey);
            var key = "ETH-".concat(heatAddress);
            var encryptedWallet = reset ? null : _this.store.get(key);
            if (encryptedWallet) {
                if (!encryptedWallet.data) {
                    _this.store.remove(key);
                    _this.unlock(seedOrPrivateKey);
                }
                var decryptedWallet = heat.crypto.decryptMessage(encryptedWallet.data, encryptedWallet.nonce, heatAddress, seedOrPrivateKey);
                resolve(JSON.parse(decryptedWallet));
            }
            else {
                var promise = void 0;
                if (_this.validSeed(seedOrPrivateKey)) {
                    promise = _this.createEtherAddresses(seedOrPrivateKey, password || "");
                }
                else if (_this.validPrivateKey(seedOrPrivateKey)) {
                    promise = _this.createEtherAddressesFromPrivateKey(seedOrPrivateKey, password || "");
                }
                else {
                    reject("Invalid seed or private key");
                }
                promise.then(function (wallet) {
                    var encryptedWallet = heat.crypto.encryptMessage(JSON.stringify(wallet), heatAddress, seedOrPrivateKey);
                    _this.store.put(key, encryptedWallet);
                    resolve(wallet);
                }).catch(function () {
                    reject();
                });
            }
        });
    };
    LightwalletService.prototype.refreshBalances = function (walletAddresses, ethCurrencyAddressLoading) {
        var ethBlockExplorerService = heat.$inject.get('ethBlockExplorerService');
        walletAddresses.addresses.forEach(function (value) { return value.balance = ""; });
        var actualWalletAddresses = walletAddresses.addresses.filter(function (a) { return !a.isDeleted; });
        var emptyAddressCounter = 0;
        function processNext() {
            return new Promise(function (resolve, reject) {
                var walletAddress = actualWalletAddresses.shift();
                if (!walletAddress) {
                    resolve(false);
                    return;
                }
                ethCurrencyAddressLoading.address = walletAddress.address;
                ethBlockExplorerService.refresh().then(function () {
                    ethBlockExplorerService.getAddressInfo(walletAddress.address, true).then(function (info) {
                        walletAddress.balance = info.ETH.balance + "";
                        walletAddress.tokensBalances = [];
                        if (info.tokens) {
                            info.tokens.forEach(function (token) {
                                var tokenInfo = ethBlockExplorerService.tokenInfoCache[token.tokenInfo.address];
                                var decimals = tokenInfo ? +(tokenInfo.decimals || 0) : 8;
                                var amount = token.balance ? new Big(token.balance + "").toFixed() : "0";
                                walletAddress.tokensBalances.push({
                                    symbol: tokenInfo ? tokenInfo.symbol : '',
                                    name: tokenInfo ? tokenInfo.name : '',
                                    decimals: decimals,
                                    balance: utils.formatERC20TokenAmount(amount, decimals),
                                    address: token.tokenInfo.address
                                });
                            });
                        }
                        emptyAddressCounter++;
                        walletAddress.inUse = (info.txs || info.countTxs) > 0;
                        if (walletAddress.inUse)
                            emptyAddressCounter = 0;
                        if (emptyAddressCounter >= 2) {
                            resolve(false);
                            return;
                        }
                        resolve(true);
                    }, function (reason) {
                        console.error(reason);
                        reject(false);
                    });
                });
            });
        }
        var recurseToNext = function recurseToNext(resolve) {
            processNext().then(function (hasMore) {
                if (hasMore) {
                    setTimeout(function () {
                        recurseToNext(resolve);
                    }, 100);
                }
                else {
                    resolve();
                }
            });
        };
        return new Promise(function (resolve, reject) {
            recurseToNext(resolve);
        });
    };
    LightwalletService.prototype.sendEther = function (from, to, value) {
        this.web3Service.sendEther(from, to, value);
    };
    LightwalletService.prototype.createEtherAddresses = function (seed, password) {
        var _this = this;
        var that = this;
        return new Promise(function (resolve, reject) {
            try {
                _this.lightwallet.keystore.createVault({
                    password: password,
                    seedPhrase: seed,
                    hdPathString: LightwalletService_1.BIP44
                }, function (err, ks) {
                    if (err) {
                        reject();
                        return;
                    }
                    var HookedWeb3Provider = _this.$window.heatlibs.HookedWeb3Provider;
                    var web3Provider = new HookedWeb3Provider({
                        host: _this.settingsService.get(SettingsService.WEB3PROVIDER),
                        transaction_signer: ks
                    });
                    _this.web3Service.web3.setProvider(web3Provider);
                    ks.passwordProvider = function (callback) {
                        callback(null, password);
                    };
                    ks.keyFromPassword(password, function (err, pwDerivedKey) {
                        if (err) {
                            reject();
                            return;
                        }
                        try {
                            var keyCount = 20;
                            ks.generateNewAddress(pwDerivedKey, keyCount);
                            var addresses = ks.getAddresses();
                            var wallet = { addresses: [] };
                            for (var i = 0; i < keyCount; i++) {
                                var walletAddress = addresses[i];
                                var privateKey = ks.exportPrivateKey(walletAddress, pwDerivedKey);
                                wallet.addresses[i] = { address: walletAddress, privateKey: privateKey, index: i, balance: "0", inUse: false };
                            }
                            resolve(wallet);
                        }
                        catch (e) {
                            console.error(e);
                            reject();
                        }
                    });
                });
            }
            catch (e) {
                console.error(e);
                reject();
            }
        });
    };
    LightwalletService.prototype.createEtherAddressesFromPrivateKey = function (privkeyHex, password) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                _this.lightwallet.keystore.createVault({
                    password: password,
                    seedPhrase: _this.lightwallet.keystore.generateRandomSeed(),
                    hdPathString: LightwalletService_1.BIP44
                }, function (err, ks) {
                    if (err) {
                        reject();
                        return;
                    }
                    var HookedWeb3Provider = _this.$window.heatlibs.HookedWeb3Provider;
                    var web3Provider = new HookedWeb3Provider({
                        host: _this.settingsService.get(SettingsService.WEB3PROVIDER),
                        transaction_signer: ks
                    });
                    _this.web3Service.web3.setProvider(web3Provider);
                    ks.passwordProvider = function (callback) {
                        callback(null, password);
                    };
                    ks.keyFromPassword(password, function (err, pwDerivedKey) {
                        if (err) {
                            reject();
                            return;
                        }
                        try {
                            var encPrivKey = this.heatlibs.lightwallet.keystore._encryptKey(privkeyHex, pwDerivedKey);
                            var keyObj = {
                                privKey: privkeyHex,
                                encPrivKey: encPrivKey
                            };
                            var address = this.heatlibs.lightwallet.keystore._computeAddressFromPrivKey(keyObj.privKey);
                            ks.encPrivKeys[address] = keyObj.encPrivKey;
                            ks.addresses.push(address);
                            var addresses = ks.getAddresses();
                            var wallet = { addresses: [] };
                            for (var i = 0; i < addresses.length; i++) {
                                var walletAddress = addresses[i];
                                var privateKey = ks.exportPrivateKey(walletAddress, pwDerivedKey);
                                wallet.addresses[i] = { address: walletAddress, privateKey: privateKey, index: i, balance: "", inUse: false };
                            }
                            resolve(wallet);
                        }
                        catch (e) {
                            console.error(e);
                            reject();
                        }
                    });
                });
            }
            catch (e) {
                console.error(e);
                reject();
            }
        });
    };
    var LightwalletService_1;
    LightwalletService.BIP44 = "m/44'/60'/0'/0";
    LightwalletService = LightwalletService_1 = __decorate([
        Service('lightwalletService'),
        Inject('web3', 'user', 'settings', '$rootScope', '$window', 'storage'),
        __metadata("design:paramtypes", [Web3Service,
            UserService,
            SettingsService, Object, Object, StorageService])
    ], LightwalletService);
    return LightwalletService;
}());
var LocalKeyStoreService = (function () {
    function LocalKeyStoreService(storage, walletFile, $rootScope) {
        this.storage = storage;
        this.walletFile = walletFile;
        this.$rootScope = $rootScope;
        this.rememberedPasswords = {};
        this.store = storage.namespace("keystore", null, true);
    }
    LocalKeyStoreService.prototype.rememberPassword = function (account, password) {
        this.rememberedPasswords[account] = password;
    };
    LocalKeyStoreService.prototype.getPasswordForAccount = function (account) {
        return this.rememberedPasswords[account];
    };
    LocalKeyStoreService.prototype.testnet = function () {
        return heat.isTestnet ? '.testnet' : '';
    };
    LocalKeyStoreService.prototype.put = function (key) {
        this.rememberPassword(key.account, key.pincode);
        this.store.put(this.key(key.account), this.encode(key));
        this.store.put(this.nameKey(key.account), key.name);
    };
    LocalKeyStoreService.prototype.list = function () {
        var test = heat.isTestnet ? /key\.\d+\.testnet$/ : /key\.\d+$/;
        return this.store.keys().
            filter(function (keyName) { return test.test(keyName); }).
            map(function (keyName) { return keyName.substring("key.".length).replace(/\.testnet$/, ""); });
    };
    LocalKeyStoreService.prototype.getName = function (account, isTestnet) {
        return this.store.get(this.nameKey(account, isTestnet));
    };
    LocalKeyStoreService.prototype.nameKey = function (account, isTestnet) {
        return "name.".concat(account).concat(isTestnet || this.testnet());
    };
    LocalKeyStoreService.prototype.key = function (account, isTestnet) {
        return "key.".concat(account).concat(isTestnet || this.testnet());
    };
    LocalKeyStoreService.prototype.remove = function (account) {
        this.store.remove(this.key(account));
        this.store.remove(this.nameKey(account));
    };
    LocalKeyStoreService.prototype.encode = function (key) {
        var payload = JSON.stringify({
            account: key.account,
            secretPhrase: key.secretPhrase,
            pincode: key.pincode,
            name: key.name,
            label: key.label
        });
        var message = heat.crypto.passphraseEncrypt(payload, key.pincode);
        return message.encode();
    };
    LocalKeyStoreService.prototype.decode = function (encoded, passphrase, account) {
        var message = heat.crypto.PassphraseEncryptedMessage.decode(encoded);
        var json_str = heat.crypto.passphraseDecrypt(message, passphrase);
        if (json_str) {
            var json = JSON.parse(json_str);
            return {
                account: json['account'],
                secretPhrase: json['secretPhrase'],
                pincode: json['pincode'],
                name: json['name'],
                label: json['label']
            };
        }
        else {
        }
    };
    LocalKeyStoreService.prototype.load = function (account, passphrase) {
        var contents = this.store.get(this.key(account));
        try {
            var result = this.decode(contents, passphrase, account);
            if (result) {
                this.rememberPassword(account, passphrase);
                return result;
            }
        }
        catch (e) {
            console.log(e);
        }
    };
    LocalKeyStoreService.prototype.listLocalKeyEntries = function () {
        var _this = this;
        var entries = [];
        this.store.keys().forEach(function (key) {
            var match = key.match(/key\.(\d+)(\.testnet)?/);
            if (match) {
                var isTestnet = match[2] == '.testnet';
                var account = match[1];
                var name_1 = _this.getName(account, isTestnet);
                var contents = _this.store.get(key);
                entries.push({
                    account: account,
                    contents: contents,
                    name: name_1,
                    isTestnet: isTestnet
                });
            }
        });
        return entries;
    };
    LocalKeyStoreService.prototype.export = function (accountCurrencies, accountAddresses) {
        var walletFileData = {
            version: 2,
            entries: [],
            accountAddresses: accountAddresses
        };
        var store = this.storage.namespace('wallet-address', this.$rootScope, true);
        this.listLocalKeyEntries().forEach(function (entry) {
            var cryptoAddresses;
            wlt.CURRENCIES_LIST.forEach(function (c) {
                var encryptedAddresses = store.get("".concat(c.symbol, "-").concat(entry.account));
                if (encryptedAddresses) {
                    cryptoAddresses = cryptoAddresses || {};
                    cryptoAddresses[c.symbol] = encryptedAddresses;
                }
            });
            var item = {
                account: entry.account,
                contents: entry.contents,
                isTestnet: entry.isTestnet,
                name: entry.name,
                visibleLabel: wlt.getEntryVisibleLabel(entry.account),
                currencies: accountCurrencies.get(entry.account)
            };
            if (cryptoAddresses)
                item.cryptoAddresses = cryptoAddresses;
            walletFileData.entries.push(item);
        });
        return walletFileData;
    };
    LocalKeyStoreService.prototype.import = function (walletFile) {
        var _this = this;
        var putRaw = function (key) {
            var key1 = _this.key(key.account);
            var key2 = _this.nameKey(key.account);
            if (_this.store.get(key1))
                return false;
            _this.store.put(key1, key.contents);
            _this.store.put(key2, key.name || '');
            return true;
        };
        var store = this.storage.namespace('wallet-address', this.$rootScope, true);
        var added = [];
        walletFile.entries.forEach(function (entry) {
            var localKeyEntry = {
                account: entry.account,
                contents: entry.contents,
                isTestnet: entry.isTestnet,
                name: entry.name
            };
            var cryptoAddresses = entry.cryptoAddresses || entry["oldAddresses"];
            if (cryptoAddresses) {
                wlt.CURRENCIES_LIST.forEach(function (c) {
                    var encryptedAddresses = cryptoAddresses[c.symbol];
                    if (encryptedAddresses)
                        store.put("".concat(c.symbol, "-").concat(entry.account), encryptedAddresses);
                });
            }
            if (putRaw(localKeyEntry)) {
                added.push(localKeyEntry);
                if (entry.visibleLabel) {
                    wlt.updateEntryVisibleLabel(entry.account, entry.visibleLabel);
                }
            }
            if (entry.currencies) {
                wlt.updateEntryCurrencies(entry.account, entry.currencies);
            }
        });
        if (walletFile.accountAddresses) {
            try {
                var accountAddressesArray = walletFile.accountAddresses;
                accountAddressesArray.forEach(function (item) {
                    item[1].forEach(function (a) {
                        if (typeof a === "string")
                            wlt.rememberAddressCreated(item[0], a);
                        else if (typeof a[0] === "string")
                            wlt.rememberAddressCreated(item[0], a[0]);
                    });
                });
            }
            catch (e) {
                console.error("Error on importing addresses: " + e.toString());
            }
        }
        var paymentMessagesNum = wlt.importPaymentMessages(walletFile.paymentMessages);
        return added;
    };
    LocalKeyStoreService = __decorate([
        Service('localKeyStore'),
        Inject('storage', 'walletFile', '$rootScope'),
        __metadata("design:paramtypes", [StorageService, WalletFileService, Object])
    ], LocalKeyStoreService);
    return LocalKeyStoreService;
}());
var LtcBlockExplorerService = (function () {
    function LtcBlockExplorerService(http, $q, $http, settingsService) {
        var _this = this;
        this.http = http;
        this.$q = $q;
        this.$http = $http;
        this.settingsService = settingsService;
        this.cachedGetCachedAccountBalance = new Map();
        this.cachedAddressInfo = new Map();
        this.getCachedAccountBalance = function (address) {
            if (_this.cachedGetCachedAccountBalance.get(address))
                return _this.cachedGetCachedAccountBalance.get(address);
            var deferred = _this.$q.defer();
            _this.cachedGetCachedAccountBalance.set(address, deferred.promise);
            _this.getBalanceFromChain(address).then(deferred.resolve, deferred.reject);
            _this.cachedGetCachedAccountBalance.get(address).finally(function () {
                setTimeout(function () {
                    _this.cachedGetCachedAccountBalance.set(address, null);
                }, 30 * 1000);
            });
            return _this.cachedGetCachedAccountBalance.get(address);
        };
        this.getBalance = function (address) {
            var deferred = _this.$q.defer();
            _this.getCachedAccountBalance(address).then(function (info) {
                deferred.resolve(info);
            });
            return deferred.promise;
        };
        this.getCachedAddressInfo = function (address) {
            var v = _this.cachedAddressInfo.get(address);
            if (v)
                return v;
            var deferred = _this.$q.defer();
            deferred.promise.finally(function () {
                setTimeout(function () {
                    _this.cachedAddressInfo.set(address, null);
                }, 60 * 1000);
            });
            _this.cachedAddressInfo.set(address, deferred.promise);
            _this.getAddressInfo(address, false).then(deferred.resolve, deferred.reject);
            return _this.cachedAddressInfo.get(address);
        };
        this.settingsService.initialized.then(function () { return LtcBlockExplorerService_1.endPoint = SettingsService.getCryptoServerEndpoint('LTC'); });
    }
    LtcBlockExplorerService_1 = LtcBlockExplorerService;
    LtcBlockExplorerService.prototype.isSyncing = function () {
        var deferred = this.$q.defer();
        this.http.get(LtcBlockExplorerService_1.endPoint).then(function (response) {
            var parsed;
            try {
                parsed = angular.isString(response) ? JSON.parse(response) : response;
            }
            catch (e) {
                deferred.reject(response);
            }
            if (parsed && parsed.blockbook && parsed.blockbook.inSync && parsed.blockbook.coin === 'Litecoin') {
                deferred.resolve();
            }
            else {
                deferred.reject();
            }
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    LtcBlockExplorerService.prototype.getBalanceFromChain = function (address) {
        var deferred = this.$q.defer();
        this.getAddressInfo(address).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed.balance);
        }, function () {
            deferred.resolve("0");
        });
        return deferred.promise;
    };
    LtcBlockExplorerService.prototype.getTransactions = function (address, pageNum, pageSize) {
        var getTransactionsApi = "".concat(LtcBlockExplorerService_1.endPoint, "/address/").concat(address, "?details=txs&page=").concat(pageNum, "&pageSize=").concat(pageSize);
        var deferred = this.$q.defer();
        this.http.get(getTransactionsApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed.transactions);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    LtcBlockExplorerService.prototype.getAddressInfo = function (address, useCache) {
        if (useCache === void 0) { useCache = false; }
        if (useCache) {
            return this.getCachedAddressInfo(address);
        }
        var getTransactionsApi = "".concat(LtcBlockExplorerService_1.endPoint, "/address/").concat(address, "?details=basic");
        var deferred = this.$q.defer();
        this.http.get(getTransactionsApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    LtcBlockExplorerService.prototype.getEstimatedFee = function () {
        var getEstimatedFeeApi = "https://api.blockcypher.com/v1/ltc/main";
        var deferred = this.$q.defer();
        var fee = 10;
        this.http.get(getEstimatedFeeApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            fee = parsed.medium_fee_per_kb ? parseFloat(parsed.medium_fee_per_kb) : 10000;
            deferred.resolve(fee);
        }, function () {
            deferred.resolve(fee);
        });
        return deferred.promise;
    };
    LtcBlockExplorerService.prototype.getTxInfo = function (txId) {
        var getTxInfoApi = "".concat(LtcBlockExplorerService_1.endPoint, "/tx/").concat(txId);
        var deferred = this.$q.defer();
        this.http.get(getTxInfoApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    LtcBlockExplorerService.prototype.getUnspentUtxos = function (account) {
        var getTxInfoApi = "".concat(LtcBlockExplorerService_1.endPoint, "/utxo/").concat(account);
        var deferred = this.$q.defer();
        this.http.get(getTxInfoApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    LtcBlockExplorerService.prototype.broadcast = function (txObject) {
        var sendTxApi = "".concat(LtcBlockExplorerService_1.endPoint, "/sendtx/").concat(txObject);
        var deferred = this.$q.defer();
        this.$http.get(sendTxApi).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            deferred.resolve(parsed.data);
        }, function (error) {
            deferred.reject(error);
        });
        return deferred.promise;
    };
    var LtcBlockExplorerService_1;
    LtcBlockExplorerService = LtcBlockExplorerService_1 = __decorate([
        Service('ltcBlockExplorerService'),
        Inject('http', '$q', '$http', 'settings'),
        __metadata("design:paramtypes", [HttpService, Function, Function, SettingsService])
    ], LtcBlockExplorerService);
    return LtcBlockExplorerService;
}());
var LTCCryptoService = (function () {
    function LTCCryptoService($window, storage, $rootScope) {
        this.$rootScope = $rootScope;
        this.litecore = $window.heatlibs.litecore;
        this.bip39 = $window.heatlibs.bip39;
        this.store = storage.namespace('wallet-address', $rootScope, true);
    }
    LTCCryptoService_1 = LTCCryptoService;
    LTCCryptoService.prototype.unlock = function (seedOrPrivateKey, reset) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var heatAddress = heat.crypto.getAccountId(seedOrPrivateKey);
            var encryptedWallet = reset ? null : _this.store.get("LTC-".concat(heatAddress));
            if (encryptedWallet) {
                if (!encryptedWallet.data) {
                    _this.store.remove("LTC-".concat(heatAddress));
                    _this.unlock(seedOrPrivateKey);
                }
                var decryptedWallet = heat.crypto.decryptMessage(encryptedWallet.data, encryptedWallet.nonce, heatAddress, seedOrPrivateKey);
                resolve(JSON.parse(decryptedWallet));
            }
            else if (_this.bip39.validateMnemonic(seedOrPrivateKey)) {
                var walletType = _this.getNWalletsFromMnemonics(seedOrPrivateKey, 20);
                var encryptedWallet_8 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seedOrPrivateKey);
                _this.store.put("LTC-".concat(heatAddress), encryptedWallet_8);
                resolve(walletType);
            }
            else if (_this.litecore.PrivateKey.isValid(seedOrPrivateKey)) {
                try {
                    var privateKey = _this.litecore.PrivateKey.fromWIF(seedOrPrivateKey);
                    var address = privateKey.toAddress();
                    var walletType = { addresses: [] };
                    walletType.addresses[0] = { address: address.toString(), privateKey: privateKey.toString() };
                    var encryptedWallet_9 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seedOrPrivateKey);
                    _this.store.put("LTC-".concat(heatAddress), encryptedWallet_9);
                    resolve(walletType);
                }
                catch (e) {
                    resolve(null);
                }
            }
            else {
                reject();
            }
        });
    };
    LTCCryptoService.prototype.getNWalletsFromMnemonics = function (mnemonic, keyCount) {
        var walletType = { addresses: [] };
        for (var i = 0; i < keyCount; i++) {
            var wallet = this.getLitecoinWallet(mnemonic, i);
            walletType.addresses[i] = { address: wallet.address, privateKey: wallet.privateKey, index: i, balance: "0", inUse: false };
        }
        return walletType;
    };
    LTCCryptoService.prototype.refreshBalances = function (wallet, ltcCurrencyAddressLoading) {
        wallet.addresses.forEach(function (value) { return value.balance = ""; });
        var addresses = wallet.addresses.filter(function (a) { return !a.isDeleted; }).map(function (a) { return a.address; });
        var emptyAddressCounter = 0;
        var ltcBlockExplorerService = heat.$inject.get('ltcBlockExplorerService');
        function processNext() {
            return new Promise(function (resolve, reject) {
                var address = addresses.shift();
                if (!address) {
                    resolve(false);
                    return;
                }
                ltcCurrencyAddressLoading.address = address;
                ltcBlockExplorerService.getAddressInfo(address, true).then(function (info) {
                    var walletAddress = wallet.addresses.find(function (x) { return x.address == address; });
                    if (!walletAddress) {
                        console.error("Address ".concat(address, " is not found among addresses"), wallet.addresses);
                        resolve(false);
                        return;
                    }
                    emptyAddressCounter++;
                    walletAddress.inUse = info.txs != 0;
                    walletAddress.balance = parseFloat(info.balance) / 100000000 + "";
                    if (walletAddress.inUse)
                        emptyAddressCounter = 0;
                    if (emptyAddressCounter >= 2) {
                        resolve(false);
                        return;
                    }
                    resolve(true);
                }, function (reason) {
                    console.error(reason);
                    resolve(false);
                });
            });
        }
        var recurseToNext = function recurseToNext(resolve) {
            processNext().then(function (hasMore) {
                if (hasMore) {
                    setTimeout(function () {
                        recurseToNext(resolve);
                    }, 100);
                }
                else {
                    resolve();
                }
            });
        };
        return new Promise(function (resolve, reject) {
            ltcBlockExplorerService.isSyncing().then(function () { recurseToNext(resolve); }).catch(reject);
        });
    };
    LTCCryptoService.prototype.signTransaction = function (txObject, uncheckedSerialize) {
        var _this = this;
        if (uncheckedSerialize === void 0) { uncheckedSerialize = false; }
        var ltcBlockExplorerService = heat.$inject.get('ltcBlockExplorerService');
        return new Promise(function (resolve, reject) {
            ltcBlockExplorerService.getUnspentUtxos(txObject.sender).then(function (utxos) {
                if (utxos.length === 0) {
                    reject(new Error('No utxo found'));
                }
                ltcBlockExplorerService.getTxInfo(utxos[0].txid).then(function (txData) {
                    var script = "";
                    for (var i = 0; i < txData.vout.length; i += 1) {
                        if (txData.vout[i].addresses[0] === txObject.sender) {
                            script = txData.vout[i].hex;
                            break;
                        }
                    }
                    var unspent = [];
                    var availableSatoshis = 0;
                    for (var i = 0; i < utxos.length; i += 1) {
                        var utxo = {
                            txid: utxos[i].txid,
                            vout: utxos[i].vout,
                            satoshis: parseInt(utxos[i].value),
                            script: script
                        };
                        unspent.push(utxo);
                        availableSatoshis += parseInt(utxos[i].value);
                        if (availableSatoshis >= txObject.value + txObject.fee)
                            break;
                    }
                    if (availableSatoshis < txObject.value + txObject.fee) {
                        reject(new Error('Insufficient balance to broadcast transaction'));
                    }
                    try {
                        var tx = _this.litecore.Transaction();
                        tx.from(unspent);
                        tx.to(txObject.recipient, txObject.value);
                        tx.change(txObject.sender);
                        tx.fee(txObject.fee);
                        tx.sign(txObject.privateKey);
                        var rawTx = uncheckedSerialize ? tx.uncheckedSerialize() : tx.serialize();
                        resolve(rawTx);
                    }
                    catch (err) {
                        reject(err);
                    }
                }, function (err) {
                    reject(err);
                });
            }, function (err) {
                reject(err);
            });
        });
    };
    LTCCryptoService.prototype.getLitecoinWallet = function (mnemonic, index) {
        if (index === void 0) { index = 0; }
        var seedHex = this.bip39.mnemonicToSeedHex(mnemonic);
        var HDPrivateKey = this.litecore.HDPrivateKey;
        var hdPrivateKey = HDPrivateKey.fromSeed(seedHex, 'mainnet');
        var derived = hdPrivateKey.derive(LTCCryptoService_1.BIP44 + index);
        var address = derived.privateKey.toAddress();
        var privateKey = derived.privateKey.toWIF();
        return {
            address: address.toString(),
            privateKey: privateKey.toString()
        };
    };
    var LTCCryptoService_1;
    LTCCryptoService.BIP44 = "m/44'/2'/0'/0/";
    LTCCryptoService = LTCCryptoService_1 = __decorate([
        Service('ltcCryptoService'),
        Inject('$window', 'storage', '$rootScope'),
        __metadata("design:paramtypes", [Object, StorageService, Object])
    ], LTCCryptoService);
    return LTCCryptoService;
}());
var LtcPendingTransactionsService = (function () {
    function LtcPendingTransactionsService($q, http, settings) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    LtcPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('ltcPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    LtcPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("ltcPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp), "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    LtcPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("ltcPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp));
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    LtcPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    LtcPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    LtcPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    LtcPendingTransactionsService = __decorate([
        Service('ltcPendingTransactions'),
        Inject('$q', 'http', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService])
    ], LtcPendingTransactionsService);
    return LtcPendingTransactionsService;
}());
var MofoSocketService = (function () {
    function MofoSocketService($q, $timeout, $interval, $rootScope, settingsService) {
        var _this = this;
        this.$q = $q;
        this.$timeout = $timeout;
        this.$interval = $interval;
        this.$rootScope = $rootScope;
        this.settingsService = settingsService;
        this.hostIndex = 0;
        this.mofoSocket = function (url) {
            if (url === void 0) { url = _this.url; }
            if (_this.url == url && _this.socket !== undefined && _this.socket.readyState === 1) {
                return new Promise(function (resolve, reject) {
                    resolve(_this.socket);
                });
            }
            var switchUrl = function (reason) {
                console.error(reason);
                _this.hostIndex++;
                _this.url = SettingsService.getCryptoServerEndpoint('FIM', _this.hostIndex);
                if (!_this.url) {
                    _this.hostIndex = 0;
                    _this.url = SettingsService.getCryptoServerEndpoint('FIM', _this.hostIndex);
                }
                return _this.createSocket(_this.url);
            };
            return _this.createSocket(url)
                .then(function (socket) { return socket; }, switchUrl)
                .then(function (socket) { return socket; }, switchUrl);
        };
        this.getSocketUrl = function () {
            return _this.url;
        };
        this.createSocket = function (url) {
            return new Promise(function (resolve, reject) {
                _this.url = url;
                _this.socket = new WebSocket(url);
                _this.socket.onclose = function (evt) { _this.onclose(evt); reject(); };
                _this.socket.onopen = function (evt) { _this.onopen(evt); resolve(_this.socket); };
                _this.socket.onerror = function (evt) {
                    _this.onmessage(evt);
                    reject(evt);
                };
                _this.socket.onmessage = function (evt) { _this.onmessage(evt); };
            });
        };
        this._send = function (argv) {
            if (_this.socket && _this.socket.readyState == 1) {
                var message = JSON.stringify(argv);
                _this.socket.send(message);
            }
        };
        this.onopen = function (event) {
            console.log('WEBSOCKET - onopen ' + new Date(), { socket: _this.socket, event: event });
            if (_this.alive_cb)
                _this.$interval.cancel(_this.alive_cb);
            _this.alive_cb = _this.$interval(_this._createKeepAliveIntervalHandler(), 10000);
        };
        this._createKeepAliveIntervalHandler = function () {
            return function () {
                _this._send('ping');
            };
        };
        this.onclose = function (event) {
            console.log('WEBSOCKET - onclose ' + new Date(), { socket: _this.socket, event: event });
        };
        this.onerror = function (event) {
            console.log('WEBSOCKET - onerror REMOVE BAD URL [' + _this.url + ']' + new Date(), { event: event });
        };
        this.onmessage = function (event) {
            var message = event.data;
            if (message == "pong" || !message) {
                return;
            }
            try {
                var data = JSON.parse(message);
            }
            catch (e) {
                console.log('WEBSOCKET - JSON parse error', { socket: _this.socket, event: event });
                return;
            }
            if (!Array.isArray(data)) {
                throw new Error('WEBSOCKET - Expected an array');
            }
            var op = data[0];
            if (op == "response") {
                _this.$rootScope.$broadcast(data[1], data[2]);
            }
            else {
                throw new Error('WEBSOCKET - Unsupported operation');
            }
        };
        this.getTransactions = function (account, timestamp) {
            if (timestamp === void 0) { timestamp = 0; }
            var deferred = _this.$q.defer();
            _this._send(['call', 'getTransactions', 'getActivity', { account: account }]);
            _this.$rootScope.$on('getTransactions', function (event, opts) {
                if (opts.transactions)
                    deferred.resolve(opts.transactions);
                else
                    deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactionsCount = function (account) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'getTransactionsCount', 'getActivity', { account: account }]);
            _this.$rootScope.$on('getTransactionsCount', function (event, opts) {
                deferred.resolve(15);
            });
            return deferred.promise;
        };
        this.getAccount = function (address) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'getFIMKAccount', 'getAccount', { account: address }]);
            _this.$rootScope.$on('getFIMKAccount', function (event, opts) {
                if (opts.unconfirmedBalanceNQT) {
                    deferred.resolve(opts);
                }
                else if (opts.errorDescription == "Unknown account") {
                    deferred.resolve("0.00000000");
                }
                else {
                    deferred.reject(opts.errorDescription);
                }
            });
            return deferred.promise;
        };
        this.sendFim = function (txObject) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'sendMoney', 'callAPIFunction', txObject]);
            _this.$rootScope.$on('sendMoney', function (event, opts) {
                if (!opts.unsignedTransactionBytes) {
                    deferred.reject(opts.errorDescription);
                }
                var userService = heat.$inject.get('user');
                var signature = heat.crypto.signBytes(opts.unsignedTransactionBytes, converters.stringToHexString(userService.secretPhrase));
                var payload = opts.unsignedTransactionBytes.substr(0, 192) + signature + opts.unsignedTransactionBytes.substr(320);
                _this._send(['call', 'broadcastTransaction', 'callAPIFunction', { requestType: 'broadcastTransaction', transactionBytes: payload }]);
                _this.$rootScope.$on('broadcastTransaction', function (event, opts) {
                    if (opts.errorCode) {
                        deferred.reject(opts.errorDescription);
                    }
                    else {
                        deferred.resolve({ txId: opts.transaction });
                    }
                });
            });
            return deferred.promise;
        };
        this.getRecentTx = function (account) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'getRecentTransactions', 'getRecentTransactions', { accounts: [account] }]);
            _this.$rootScope.$on('getRecentTransactions', function (event, opts) {
                if (!opts.errorCode) {
                    deferred.resolve(opts);
                }
                else {
                    deferred.reject(opts.error);
                }
            });
            return deferred.promise;
        };
        this.getAccountAssets = function (account) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'getAccountAssets', 'callAPIFunction', { requestType: 'getAccountAssets', account: account }]);
            _this.$rootScope.$on('getAccountAssets', function (event, opts) {
                if (!opts.errorCode) {
                    deferred.resolve(opts.accountAssets);
                }
                else {
                    deferred.reject(opts.error);
                }
            });
            return deferred.promise;
        };
        this.settingsService.initialized.then(function () { return _this.url = SettingsService.getCryptoServerEndpoint('FIM', _this.hostIndex); });
    }
    MofoSocketService = __decorate([
        Service('mofoSocketService'),
        Inject('$q', '$timeout', '$interval', '$rootScope', 'settings'),
        __metadata("design:paramtypes", [Function, Function, Function, Object, SettingsService])
    ], MofoSocketService);
    return MofoSocketService;
}());
var NxtBlockExplorerService = (function () {
    function NxtBlockExplorerService($q, http, settingsService) {
        var _this = this;
        this.$q = $q;
        this.http = http;
        this.settingsService = settingsService;
        this.cachedGetCachedAccountBalance = new Map();
        this.getHostUrl = function () {
            return _this.url;
        };
        this.getBlockchainStatus = function () {
            var deferred = _this.$q.defer();
            _this.settingsService.initialized.then(function () {
                _this.setUrl(SettingsService.getCryptoServerEndpoint('NXT'));
                _this.http.get("".concat(_this.url, "/nxt?requestType=getBlockchainStatus")).then(function (ret) {
                    var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                    if (data) {
                        deferred.resolve(data);
                    }
                    else
                        deferred.reject();
                }).catch(function () { return deferred.reject(); });
            });
            return deferred.promise;
        };
        this.getTransactions = function (account, firstIndex, lastIndex) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getBlockchainTransactions&account=").concat(account, "&firstIndex=").concat(firstIndex, "&lastIndex=").concat(lastIndex)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.transactions) {
                    deferred.resolve(data.transactions);
                }
                else
                    deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactionsCount = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getBlockchainTransactions&account=").concat(account, "&lastIndex=-1")).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.transactions)
                    deferred.resolve(data.transactions.length);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAccount = function (address) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getAccount&account=").concat(address)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.unconfirmedBalanceNQT)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.sendNxt = function (txObject) {
            var deferred = _this.$q.defer();
            _this.http.post(_this.url + "/" + txObject, {}).then(function (ret) {
                var userService = heat.$inject.get('user');
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.errorDescription) {
                    deferred.reject(data.errorDescription);
                }
                var signature = heat.crypto.signBytes(data.unsignedTransactionBytes, converters.stringToHexString(userService.secretPhrase));
                var payload = data.unsignedTransactionBytes.substr(0, 192) + signature + data.unsignedTransactionBytes.substr(320);
                _this.http.post("".concat(_this.url, "/nxt?requestType=broadcastTransaction&transactionBytes=").concat(payload), {}).then(function (ret) {
                    var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                    if (data.errorDescription) {
                        deferred.reject(data.errorDescription);
                    }
                    deferred.resolve({ txId: data.transaction });
                });
            }, function (err) {
                deferred.reject(err === null || err === void 0 ? void 0 : err.errorDescription);
            });
            return deferred.promise;
        };
        this.getTransactionStatus = function (transactionId) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getTransaction&transaction=").concat(transactionId)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (!data.errorDescription)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAccountAssets = function (tx) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getAccountAssets&account=").concat(tx)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.accountAssets)
                    deferred.resolve(data.accountAssets);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getCachedAccountBalance = function (address) {
            if (_this.cachedGetCachedAccountBalance.get(address))
                return _this.cachedGetCachedAccountBalance.get(address);
            var deferred = _this.$q.defer();
            _this.cachedGetCachedAccountBalance.set(address, deferred.promise);
            _this.getBalanceFromChain(address).then(deferred.resolve, deferred.reject);
            _this.cachedGetCachedAccountBalance.get(address).finally(function () {
                setTimeout(function () {
                    _this.cachedGetCachedAccountBalance.set(address, null);
                }, 30 * 1000);
            });
            return _this.cachedGetCachedAccountBalance.get(address);
        };
        this.getBalanceFromChain = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getBalance&account=").concat(account)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.unconfirmedBalanceNQT)
                    deferred.resolve(data.unconfirmedBalanceNQT);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getBalance = function (account) {
            var deferred = _this.$q.defer();
            _this.getCachedAccountBalance(account).then(function (info) {
                deferred.resolve(info);
            }, deferred.reject);
            return deferred.promise;
        };
        this.getPublicKeyFromAddress = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getAccountPublicKey&account=").concat(account)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.publicKey)
                    deferred.resolve(data.publicKey);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAssetInfo = function (asset) {
            var deferred = _this.$q.defer();
            _this.http.get("".concat(_this.url, "/nxt?requestType=getAsset&asset=").concat(asset)).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.name)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.settingsService.initialized.then(function () { return _this.setUrl(SettingsService.getCryptoServerEndpoint('NXT')); });
    }
    NxtBlockExplorerService.prototype.setUrl = function (url) {
        this.url = url;
    };
    NxtBlockExplorerService = __decorate([
        Service('nxtBlockExplorerService'),
        Inject('$q', 'http', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService])
    ], NxtBlockExplorerService);
    return NxtBlockExplorerService;
}());
var NXTCryptoService = (function () {
    function NXTCryptoService($window, storage, $rootScope) {
        this.$window = $window;
        this.$rootScope = $rootScope;
        this.nxtCrypto = $window.heatlibs.nxtCrypto;
        this.store = storage.namespace('wallet-address', $rootScope, true);
    }
    NXTCryptoService.prototype.unlock = function (seedOrPrivateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var heatAddress = heat.crypto.getAccountId(seedOrPrivateKey);
            var encryptedWallet = _this.store.get("NXT-".concat(heatAddress));
            if (encryptedWallet) {
                if (!encryptedWallet.data) {
                    _this.store.remove("NXT-".concat(heatAddress));
                    _this.unlock(seedOrPrivateKey);
                }
                var decryptedWallet = heat.crypto.decryptMessage(encryptedWallet.data, encryptedWallet.nonce, heatAddress, seedOrPrivateKey);
                resolve(JSON.parse(decryptedWallet));
            }
            else {
                var walletType = { addresses: [] };
                walletType.addresses[0] = { address: _this.nxtCrypto.getAccountRSFromSecretPhrase(seedOrPrivateKey, 'NXT'), privateKey: seedOrPrivateKey };
                var encryptedWallet_10 = heat.crypto.encryptMessage(JSON.stringify(walletType), heatAddress, seedOrPrivateKey);
                _this.store.put("NXT-".concat(heatAddress), encryptedWallet_10);
                resolve(walletType);
            }
        });
    };
    NXTCryptoService.prototype.refreshBalances = function (wallet) {
        var address = wallet.addresses[0].address;
        return new Promise(function (resolve, reject) {
            var nxtBlockExplorerService = heat.$inject.get('nxtBlockExplorerService');
            nxtBlockExplorerService.getBlockchainStatus().then(function () {
                nxtBlockExplorerService.getAccount(wallet.addresses[0].address).then(function (data) {
                    wallet.addresses[0].balance = new Big(utils.convertToQNTf(data.unconfirmedBalanceNQT)).toFixed(8);
                    wallet.addresses[0].inUse = true;
                    nxtBlockExplorerService.getAccountAssets(address).then(function (accountAssets) {
                        wallet.addresses[0].tokensBalances = [];
                        var promises = [];
                        accountAssets.forEach(function (asset) {
                            var promise = nxtBlockExplorerService.getAssetInfo(asset.asset).then(function (assetInfo) {
                                wallet.addresses[0].tokensBalances.push({
                                    symbol: assetInfo ? assetInfo.name : '',
                                    name: assetInfo ? assetInfo.name : '',
                                    decimals: assetInfo.decimals,
                                    balance: utils.formatQNT(asset.unconfirmedQuantityQNT, assetInfo.decimals),
                                    address: asset.asset
                                });
                            });
                            promises.push(promise);
                        });
                        Promise.all(promises).then(function () { return resolve(true); });
                        if (accountAssets.length === 0)
                            resolve(true);
                    });
                }, function (err) {
                    console.error(err);
                    resolve(false);
                });
            }).catch(reject);
        });
    };
    NXTCryptoService = __decorate([
        Service('nxtCryptoService'),
        Inject('$window', 'storage', '$rootScope'),
        __metadata("design:paramtypes", [Object, StorageService, Object])
    ], NXTCryptoService);
    return NXTCryptoService;
}());
var NxtPendingTransactionsService = (function () {
    function NxtPendingTransactionsService($q, http, settings) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    NxtPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('nxtPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    NxtPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("nxtPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp), "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    NxtPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("nxtPendingTxn:".concat(address, ":").concat(txId, ":").concat(timestamp));
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    NxtPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    NxtPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    NxtPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    NxtPendingTransactionsService = __decorate([
        Service('nxtPendingTransactions'),
        Inject('$q', 'http', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService])
    ], NxtPendingTransactionsService);
    return NxtPendingTransactionsService;
}());
var PanelService = (function () {
    function PanelService($mdPanel) {
        this.$mdPanel = $mdPanel;
    }
    PanelService.prototype.show = function (template, locals) {
        var _this = this;
        var position = this.$mdPanel.newPanelPosition().absolute().center();
        var config = {
            attachTo: angular.element(document.body),
            controller: function () { },
            controllerAs: 'vm',
            disableParentScroll: true,
            template: template,
            hasBackdrop: false,
            panelClass: 'demo-dialog-example',
            position: position,
            trapFocus: false,
            zIndex: 88,
            clickOutsideToClose: true,
            escapeToClose: true,
            focusOnOpen: true,
            locals: locals
        };
        return this.$mdPanel.open(config)
            .then(function (panel) { return _this.panel = panel; });
    };
    PanelService.prototype.close = function () {
        if (this.panel)
            this.panel.close();
    };
    PanelService = __decorate([
        Service('panel'),
        Inject('$mdPanel'),
        __metadata("design:paramtypes", [Object])
    ], PanelService);
    return PanelService;
}());
var RenderService = (function () {
    function RenderService() {
    }
    RenderService.prototype.render = function (rawText, renderers) {
        var text = rawText;
        renderers.forEach(function (renderer) {
            text = renderer.toHtml(text);
        });
        return text;
    };
    RenderService = __decorate([
        Service('render')
    ], RenderService);
    return RenderService;
}());
var SecretGeneratorService = (function () {
    function SecretGeneratorService($q, settings, lightwalletService) {
        this.$q = $q;
        this.settings = settings;
        this.lightwalletService = lightwalletService;
    }
    SecretGeneratorService.prototype.generate = function (langCode) {
        var deferred = this.$q.defer();
        deferred.resolve(this.lightwalletService.generateRandomSeed());
        return deferred.promise;
    };
    SecretGeneratorService = __decorate([
        Service('secretGenerator'),
        Inject('$q', 'settings', 'lightwalletService'),
        __metadata("design:paramtypes", [Function, SettingsService,
            LightwalletService])
    ], SecretGeneratorService);
    return SecretGeneratorService;
}());
var ServerService = (function (_super) {
    __extends(ServerService, _super);
    function ServerService($rootScope, $q, $interval, $timeout, settings, user, $mdToast) {
        var _this = _super.call(this) || this;
        _this.$rootScope = $rootScope;
        _this.$q = $q;
        _this.$interval = $interval;
        _this.$timeout = $timeout;
        _this.settings = settings;
        _this.user = user;
        _this.$mdToast = $mdToast;
        _this.MAX_CONSOLE_LINE_LENGTH = 20000;
        _this.isRunning = false;
        _this.isReady = false;
        _this.buffer = [" ", " ", " "];
        var onbeforeunload = function () {
            if (_this.isRunning) {
                _this.$mdToast.show(_this.$mdToast.simple().textContent("Embedded server is running, first stop it then retry the operation")
                    .hideDelay(8000));
                return "dont close";
            }
        };
        window.onbeforeunload = onbeforeunload;
        user.on(UserService.EVENT_LOCKED, function () {
            if (_this.isRunning) {
                _this.stopServer();
            }
            _this.applicationShutdown();
        });
        var path = require('path');
        _this.stopServerSignalFile = path.join(__dirname, '..', 'heatledger', 'stopserver.signal');
        _this.serverStoppedSignalFile = path.join(__dirname, '..', 'heatledger', 'serverstopped.signal');
        _this.cwd = path.join(__dirname, '..', 'heatledger');
        return _this;
    }
    ServerService.prototype.initOsDepends = function () {
        var os = this.getOS();
        var path = require('path');
        if (os == 'WIN') {
            this.command = path.join('bin', 'heatledger.bat');
        }
        if (os == 'MAC') {
            this.command = path.join('bin', 'heatledger');
        }
        if (os == 'LINUX') {
            this.command = path.join('bin', 'heatledger');
        }
        var embeddedInWalletSignalFilePath = path.join(__dirname, '..', 'heatledger', 'embeddedinwallet.signal');
        var fs = require('fs');
        if (!fs.existsSync(embeddedInWalletSignalFilePath)) {
            fs.writeFile(embeddedInWalletSignalFilePath, '', { flag: 'w' }, function (err) {
                if (err)
                    console.error(err);
            });
        }
    };
    ServerService.prototype.isHeatledgerServerDirExists = function () {
        var fs = require('fs');
        return fs.existsSync(this.cwd);
    };
    ServerService.prototype.getAppDir = function (dirName) {
        var path = require('path');
        var dir = path.join(__dirname, '..', 'heatledger', dirName);
        return path.resolve(dir);
    };
    ServerService.prototype.startServer = function () {
        var _this = this;
        console.log('ServerService::start server');
        if (this.isRunning) {
            throw new Error('Server starting or already up, check server.isRunning before calling this method');
        }
        this.initOsDepends();
        var spawn = require('child-process-promise').spawn;
        this.isRunning = true;
        this.getUserDataDirFromMainProcess().then(function (userDataDir) {
            var env = process.env;
            if (userDataDir) {
                var path = require('path');
                env['HEAT_WALLET_DIR'] = path.join(userDataDir, '.');
            }
            var namespace = heat.isTestnet ? "(heatwallet\\,testnet)" : "(heatwallet)";
            _this.args = ["-properties", "namespace=" + namespace];
            _this.log("[SERVER] command >> " + _this.command);
            _this.log("[SERVER] arguments >> " + _this.args);
            _this.log("[SERVER] cwd     >> " + _this.cwd);
            var promise = spawn(_this.command, _this.args, {
                cwd: _this.cwd,
                env: env
            });
            _this.childProcess = promise.childProcess;
            _this.log("[SERVER] pid     >> " + _this.childProcess.pid);
            _this.childProcess.stdout.on('data', function (data) {
                _this.log(data.toString());
            });
            _this.childProcess.stderr.on('data', function (data) {
                _this.log(data.toString());
            });
            promise.then(function () {
                _this.log("[SPAWN] DONE!");
                _this.$rootScope.$evalAsync(function () {
                    _this.isRunning = false;
                    _this.isReady = false;
                    if (_this.needsRecoveryRestart()) {
                        _this.$timeout(function () {
                            _this.startServer();
                        }, 2000, true);
                    }
                });
            }).catch(function (err) {
                var message = angular.isObject(err) ? (err.message || '') : '';
                _this.log("[SPAWN EXIT] ".concat(message), err);
                _this.$rootScope.$evalAsync(function () {
                    _this.isRunning = false;
                    _this.isReady = false;
                    if (_this.needsRecoveryRestart()) {
                        _this.$timeout(function () {
                            _this.startServer();
                        }, 2000, true);
                    }
                });
            });
        });
    };
    ServerService.prototype.getUserDataDirFromMainProcess = function () {
        var ipcRenderer = require('electron').ipcRenderer;
        return new Promise(function (resolve) {
            var timeout = setTimeout(resolve, 2000);
            ipcRenderer.on('userData-is-here-reply', function (event, arg) {
                clearTimeout(timeout);
                resolve(arg);
            });
            ipcRenderer.send('userData-is-where-request', '');
        });
    };
    ServerService.prototype.log = function (msg, error) {
        var _this = this;
        if ((!msg || msg.trim().length == 0) && !error)
            return;
        if (error)
            console.log(msg, error);
        else if (this.settings.get(SettingsService.LOG_HEAT_SERVER_ALL))
            console.log(msg);
        if (!this.isReady) {
            if (msg.indexOf('** HEAT SERVER READY **') != -1) {
                this.$rootScope.$evalAsync(function () {
                    _this.isReady = true;
                });
            }
        }
        var lines = msg.split(/(\r?\n)/g);
        for (var i = 0; i < lines.length; i++) {
            if (lines[i].match(/\S/)) {
                lines[i] = new String(lines[i]);
                this.buffer.splice(this.buffer.length - 3, 0, lines[i]);
                if (this.buffer.length > this.MAX_CONSOLE_LINE_LENGTH) {
                    this.buffer.splice(0, this.buffer.length - this.MAX_CONSOLE_LINE_LENGTH);
                }
            }
        }
        this.emit('output');
    };
    ServerService.prototype.stopServer = function () {
        var _this = this;
        if (!this.isRunning)
            throw new Error('Server already stopped, check server.isRunning before calling this method');
        this.$mdToast.show(this.$mdToast.simple().textContent("Please wait while the HEAT server will be stopped").hideDelay(10000));
        var fs = require('fs');
        this.clearSignalFiles();
        var finalStopAction = function () {
            _this.clearSignalFiles();
            var kill = require('tree-kill');
            kill(pid, 'SIGTERM');
        };
        var pid = this.childProcess.pid;
        fs.writeFile(this.stopServerSignalFile, '', { flag: 'w' }, function (err) {
            if (err) {
                finalStopAction();
                console.error(err);
            }
        });
        var initStopTime = Date.now();
        var promise = this.$interval(function () {
            if (_this.isRunning) {
                var expired = Date.now() - initStopTime > 60 * 1000;
                if (fs.existsSync(_this.serverStoppedSignalFile) || expired) {
                    if (expired)
                        console.error('The waiting time has expired, the server process is stopped forcibly');
                    _this.$interval.cancel(promise);
                    finalStopAction();
                }
            }
        }, 2000, 40);
    };
    ServerService.prototype.clearSignalFiles = function () {
        var fs = require('fs');
        if (fs.existsSync(this.serverStoppedSignalFile))
            fs.unlinkSync(this.serverStoppedSignalFile);
        if (fs.existsSync(this.stopServerSignalFile))
            fs.unlinkSync(this.stopServerSignalFile);
    };
    ServerService.prototype.getOS = function () {
        if (navigator.appVersion.indexOf("Win") != -1)
            return 'WIN';
        if (navigator.appVersion.indexOf("Mac") != -1)
            return 'MAC';
        if (navigator.appVersion.indexOf("X11") != -1)
            return 'LINUX';
        if (navigator.appVersion.indexOf("Linux") != -1)
            return 'LINUX';
        throw new Error('Could not detect OS');
    };
    ServerService.prototype.applicationShutdown = function () {
        var _this = this;
        var deferred = this.$q.defer();
        dialogs.showProgressMessage(null, 'Shutting down');
        this.$interval(function () {
            if (!_this.isRunning) {
                deferred.resolve();
            }
        }, 1000);
        return deferred.promise;
    };
    ServerService.prototype.needsRecoveryRestart = function () {
        var end = this.buffer.length - 30;
        for (var i = this.buffer.length; i > end; --i) {
            if ((this.buffer[i] + "").indexOf("To complete storage recovery process please restart") != -1) {
                return true;
            }
        }
        return false;
    };
    ServerService.prototype.getServerProperties = function (filePath) {
        var fs = require('fs');
        return new Promise(function (resolve, reject) {
            fs.readFile(filePath, function (err, data) {
                if (err) {
                    console.log("Cannot load '".concat(filePath, "': ").concat(err));
                    reject(err);
                }
                resolve(data);
            });
        });
    };
    ServerService.prototype.getHeatConfigFilePath = function () {
        var path = require('path');
        return path.join(__dirname, '..', 'heatledger', 'conf', 'heat-default.properties');
    };
    ServerService = __decorate([
        Service('server'),
        Inject('$rootScope', '$q', '$interval', '$timeout', 'settings', 'user', '$mdToast'),
        __metadata("design:paramtypes", [Object, Function, Function, Function, SettingsService,
            UserService, Object])
    ], ServerService);
    return ServerService;
}(EventEmitter));
var SettingsService = (function () {
    function SettingsService(env, http) {
        this.env = env;
        this.http = http;
        this.VERSION = "4.5.2";
        this.BUILD = "2025-02-05";
        this.failoverEnabled = true;
        this.settings = {};
        this.applyFailoverConfig();
        this.settings[SettingsService_1.DATEFORMAT_DEFAULT] = 'yyyy-mm-dd HH:MM:ss';
        this.settings[SettingsService_1.TIMEFORMAT_DEFAULT] = 'HH:MM:ss';
        this.settings[SettingsService_1.APPLICATION_NAME] = 'Heatwallet';
        this.settings[SettingsService_1.APPLICATION_VERSION] = this.VERSION;
        this.settings[SettingsService_1.APPLICATION_BUILD] = this.BUILD;
        this.settings[SettingsService_1.SOCKET_RPC_TIMEOUT] = 30 * 1000;
        this.settings[SettingsService_1.SOCKET_RECONNECT_DELAY] = 2000;
        this.settings[SettingsService_1.LOG_API_ERRORS] = true;
        this.settings[SettingsService_1.LOG_API_ALL] = false;
        this.settings[SettingsService_1.LOG_NOTIFY_ALL] = false;
        this.settings[SettingsService_1.DICE_WORD_FOLDER] = "dice-words";
        this.settings[SettingsService_1.DICE_WORD_SUPPORTED_LANG] = {
            "de": ["de.txt", "677da2d5148342780f3cd1b09eaf489fac4ba00fe1083ba3296d41bdf088f471"],
            "en": ["en.txt", "b329cea782bdd8b1de49bbb9fbdef9e8230e15eb08f0d7952613992246c38f96"],
            "fi": ["fi.txt", "62323e0dc9ee39e191c98a361f20aa1417cb58da2eb5e40b9008d7973017d138"],
            "fr": ["fr.txt", "9f6e8d4845ff178cdfe8215976adeaab9e9ebaa88ab2e8ca4de14cc7a1e1989c"],
            "it": ["it.txt", "9a14dadd488e0fba95597c0b892320145d563a8b0554911af485179e91211847"],
            "jp": ["jp.txt", "b9a5e099990617e058315f98def2ff5cd1be2d65178511d93c22153f20b6d164"],
            "nl": ["nl.txt", "67b8baf68345041b029dd72fc51d1bd71c806587979d4ba7542c2534f1612168"],
            "pl": ["pl.txt", "3822db4a595364dd44f8791f523c3482d4f1276ef31bb64e10d2cd2bb4e40a99"],
            "sv": ["sv.txt", "87d1bf55193c95c03aa8e0d221dfaa94ccd8d6ea153b3d735eac235d592273fe"]
        };
        this.settings[SettingsService_1.HEAT_WEBSOCKET_REMOTE] = "wss://heat1.heatwallet.com/ws/";
        this.settings[SettingsService_1.HEAT_HOST_REMOTE] = "https://heat1.heatwallet.com";
        this.settings[SettingsService_1.HEAT_PORT_REMOTE] = "";
        this.settings[SettingsService_1.HEAT_RPC_TIMEOUT] = 30 * 1000;
        this.settings[SettingsService_1.HEAT_WEBSOCKET_LOCAL] = "ws://localhost:7755/ws/";
        this.settings[SettingsService_1.LOG_HEAT_ERRORS] = true;
        this.settings[SettingsService_1.LOG_HEAT_ALL] = false;
        this.settings[SettingsService_1.LOG_HEAT_NOTIFY_ALL] = true;
        this.settings[SettingsService_1.LOG_HEAT_SERVER_ALL] = false;
        this.settings[SettingsService_1.HEAT_HOST_LOCAL] = "http://localhost";
        this.settings[SettingsService_1.HEAT_PORT_LOCAL] = "7733";
        this.settings[SettingsService_1.HEATLEDGER_CERTIFIER_ACCOUNT] = '2243498237075721643';
        this.settings[SettingsService_1.HEATLEDGER_BTC_ASSET] = '5592059897546023466';
        this.settings[SettingsService_1.HEATLEDGER_NAME_ASSIGNER] = '14439304480879065693';
        this.settings[SettingsService_1.TRANSACTION_PROCESSING_VISUALIZATION] = 111;
        this.settings[SettingsService_1.CAPTCHA_SITE_KEY] = "6Le7pBITAAAAANPHWrIsoP_ZvlxWr0bSjOPrlszc";
        this.settings[SettingsService_1.CAPTCHA_POPUP] = "https://heatwallet.com/captcha.html";
        this.settings[SettingsService_1.ETHPLORER_INFO_URL] = "https://api.ethplorer.io/getAddressInfo/:address?apiKey=lwA5173TDKj60";
        this.settings[SettingsService_1.ETHERSCAN_BALANCES_URL] = "https://api.etherscan.io/api?module=account&action=balancemulti&address=:addresses&tag=latest&apikey=:apiToken";
        this.settings[SettingsService_1.ETHERSCAN_TRANSACTION_URL] = "https://api.etherscan.io/api?module=account&action=txlist&address=:address&startblock=0&endblock=99999999&page=:page&offset=:offset&sort=desc&apikey=:apiToken";
        this.settings[SettingsService_1.ETHERSCAN_CONTRACT_ABI] = "https://api.etherscan.io/api?module=contract&action=getabi&address=:address&apikey=:apiToken";
        this.settings[SettingsService_1.ETHERSCAN_API_TOKEN] = "S54GZXNCVGEAVCF1AQZZ8A8WDMQ9811HW9";
        this.settings[SettingsService_1.WEB3PROVIDER] = "https://mainnet.infura.io/OT4wn16VtAydG2y9NVna";
        this.settings[SettingsService_1.ETH_TX_GAS_PRICE] = 20000000000;
        this.settings[SettingsService_1.ETH_TX_GAS_REQUIRED] = 21000;
        this.settings[SettingsService_1.BIP44_WALLET] = "m/44'/60'/0'/0";
        if (heat.isTestnet) {
            this.settings[SettingsService_1.HEAT_HOST_REMOTE] = "https://alpha.heatledger.com";
            this.settings[SettingsService_1.HEAT_PORT_REMOTE] = "7734";
            this.settings[SettingsService_1.HEATLEDGER_CERTIFIER_ACCOUNT] = '4729421738299387565';
            this.settings[SettingsService_1.HEATLEDGER_BTC_ASSET] = '2801534132504071984';
            this.settings[SettingsService_1.HEATLEDGER_NAME_ASSIGNER] = '0000000';
            this.settings[SettingsService_1.HEAT_WEBSOCKET_REMOTE] = "wss://alpha.heatledger.com:7755/ws/";
        }
        if (heat.isBetanet) {
            this.settings[SettingsService_1.HEAT_PORT_REMOTE] = "7762";
            this.settings[SettingsService_1.HEAT_PORT_LOCAL] = "7761";
            this.settings[SettingsService_1.HEAT_WEBSOCKET_REMOTE] = "wss://heatwallet.com:7763/ws/";
            this.settings[SettingsService_1.HEAT_WEBSOCKET_LOCAL] = "ws://localhost:7763/ws/";
        }
        this.settings[SettingsService_1.HEAT_HOST] = this.settings[SettingsService_1.HEAT_HOST_REMOTE];
        this.settings[SettingsService_1.HEAT_PORT] = this.settings[SettingsService_1.HEAT_PORT_REMOTE];
        this.settings[SettingsService_1.HEAT_WEBSOCKET] = this.settings[SettingsService_1.HEAT_WEBSOCKET_REMOTE];
        var usingServerValue = sessionStorage.getItem(heat.serverDescriptionKey);
        if (usingServerValue) {
            try {
                var usingServer = JSON.parse(usingServerValue);
                this.settings[SettingsService_1.HEAT_HOST] = usingServer.host;
                this.settings[SettingsService_1.HEAT_PORT] = usingServer.port;
                this.settings[SettingsService_1.HEAT_WEBSOCKET] = usingServer.websocket;
            }
            catch (e) {
                console.error("error on process sessionStorage value by key " + heat.serverDescriptionKey, e);
            }
        }
        this.generateApiKeyForBrowser();
        SettingsService_1.instance = this;
    }
    SettingsService_1 = SettingsService;
    SettingsService.getFailoverDescriptor = function () {
        if (!SettingsService_1.FAILOVER_DESCRIPTOR)
            SettingsService_1.FAILOVER_DESCRIPTOR = {
                messaging: { host: "", port: 0, websocket: "" },
                failoverEnabled: false,
                heightDeltaThreshold: 2,
                balancesMismatchesThreshold: 0.9,
                balancesEqualityThreshold: 0.8,
                connectedPeersThreshold: 0.8,
                knownServers: []
            };
        return SettingsService_1.FAILOVER_DESCRIPTOR;
    };
    SettingsService.changeCryptoNodeProperty = function (currency, host, property, value) {
        if (!SettingsService_1.CRYPTO_NODES)
            return;
        var node = SettingsService_1.CRYPTO_NODES.find(function (descriptor) { return descriptor.currencyName === currency; }).nodes.find(function (node) { return node.host === host; });
        if (!node)
            return;
        node[property] = value;
    };
    SettingsService.getCryptoServer = function (currency, index) {
        if (index === void 0) { index = 0; }
        var nodes = SettingsService_1.CRYPTO_NODES
            .find(function (descriptor) { return descriptor.currencyName === currency; })
            .nodes.filter(function (node) { return node.status === 'ACTIVE'; });
        return nodes.sort(function (n1, n2) { return n1.priority < n2.priority ? -1 : 1; })[index];
    };
    SettingsService.getCryptoServerEndpoint = function (currency, index) {
        if (index === void 0) { index = 0; }
        if (!SettingsService_1.CRYPTO_NODES)
            return "";
        var node = this.getCryptoServer(currency, index);
        if (!node)
            return "";
        return node.port ? "".concat(node.host, ":").concat(node.port) : "".concat(node.host);
    };
    SettingsService.forceServerPriority = function (host, port) {
        var portNum = parseInt(port);
        for (var _i = 0, _a = SettingsService_1.getFailoverDescriptor().knownServers; _i < _a.length; _i++) {
            var server = _a[_i];
            if (server.host == host && server.port == portNum) {
                server.originalPriority = server.priority;
                server.priority = 0;
            }
            else {
                if (server.originalPriority)
                    server.priority = server.originalPriority;
            }
        }
    };
    SettingsService.prototype.setConnectionWay = function (connectionWay) {
        this.failoverEnabled = connectionWay.failoverEnabled;
        this.settings[SettingsService_1.HEAT_HOST] =
            this.settings[connectionWay.way == "local" ? SettingsService_1.HEAT_HOST_LOCAL : SettingsService_1.HEAT_HOST_REMOTE];
        this.settings[SettingsService_1.HEAT_PORT] =
            this.settings[connectionWay.way == "local" ? SettingsService_1.HEAT_PORT_LOCAL : SettingsService_1.HEAT_PORT_REMOTE];
        this.settings[SettingsService_1.HEAT_WEBSOCKET] =
            this.settings[connectionWay.way == "local" ? SettingsService_1.HEAT_WEBSOCKET_LOCAL : SettingsService_1.HEAT_WEBSOCKET_REMOTE];
        this.settings[SettingsService_1.HEAT_MESSAGING] = connectionWay.sameMessagingHost
            ? {
                host: this.settings[SettingsService_1.HEAT_HOST],
                port: this.settings[SettingsService_1.HEAT_PORT],
                websocket: this.settings[SettingsService_1.HEAT_WEBSOCKET]
            }
            : SettingsService_1.FAILOVER_DESCRIPTOR.messaging;
    };
    SettingsService.prototype.get = function (id) {
        return this.settings[id];
    };
    SettingsService.prototype.put = function (id, value) {
        return this.settings[id] = value;
    };
    SettingsService.prototype.setCurrentServer = function (server) {
        this.settings[SettingsService_1.HEAT_HOST] = server.host;
        this.settings[SettingsService_1.HEAT_PORT] = server.port;
        this.settings[SettingsService_1.HEAT_WEBSOCKET] = server.websocket;
    };
    SettingsService.prototype.getHeatwalletConfigFilePath = function () {
        var fileName = 'app-config.json';
        if (this.env.type == EnvType.BROWSER) {
            return fileName;
        }
        if (this.env.type == EnvType.NODEJS) {
            var path = require('path');
            return path.join(__dirname, '..', '..', fileName);
        }
    };
    SettingsService.prototype.applyFailoverConfig = function () {
        var _this = this;
        var resolveFailoverDescriptor = function (json) {
            if (heat.isTestnet) {
                SettingsService_1.FAILOVER_DESCRIPTOR = json.heatNodes.testnet;
            }
            else if (heat.isBetanet) {
                SettingsService_1.FAILOVER_DESCRIPTOR = json.heatNodes.betanet;
            }
            else {
                SettingsService_1.FAILOVER_DESCRIPTOR = json.heatNodes.mainnet;
            }
            _this.settings[SettingsService_1.HEAT_MESSAGING] = SettingsService_1.FAILOVER_DESCRIPTOR.messaging;
            SettingsService_1.CRYPTO_NODES = json.cryptoNodes;
            _this.failoverEnabled = SettingsService_1.FAILOVER_DESCRIPTOR.failoverEnabled || true;
        };
        this.initialized = new Promise(function (resolve, reject) {
            if (_this.env.type == EnvType.BROWSER) {
                _this.http.get('app-config.json').then(function (json) {
                    resolveFailoverDescriptor(json);
                    resolve();
                }, function (reason) {
                    var message = "Cannot load 'app-config.json': " + reason ? reason : "";
                    console.log(message);
                    reject(message);
                });
            }
            else if (_this.env.type == EnvType.NODEJS) {
                var fs = require('fs');
                fs.readFile(_this.getHeatwalletConfigFilePath(), function (err, data) {
                    if (err) {
                        var message = "Cannot load '".concat(_this.getHeatwalletConfigFilePath(), "'. Error: ").concat(err);
                        console.log(message);
                        reject(message);
                        throw err;
                    }
                    var json = JSON.parse(data);
                    resolveFailoverDescriptor(json);
                    resolve();
                });
            }
        });
    };
    SettingsService.prototype.generateApiKeyForBrowser = function () {
        if (!SettingsService_1.REQ_API_KEY_URLS) {
            this.initialized.then(function (value) {
                var ar = [];
                SettingsService_1.CRYPTO_NODES.forEach(function (v) { return ar.push.apply(ar, v.nodes); });
                SettingsService_1.REQ_API_KEY_URLS = ar.filter(function (v) { return v.status == 'ACTIVE'; })
                    .map(function (v) { return v.host; })
                    .filter(function (v) { return v.indexOf("heatwallet.com") > -1; })
                    || [];
                return value;
            });
        }
        var now = new Date();
        var startOfYear = new Date(Date.UTC(now.getUTCFullYear(), 0, 0));
        var diff = now - startOfYear;
        var oneDay = 1000 * 60 * 60 * 24;
        var dayOfYear = Math.floor(diff / oneDay);
        var hashInput = "".concat(now.getUTCFullYear(), "-").concat(dayOfYear);
        var encoder = new TextEncoder();
        var data = encoder.encode(hashInput);
        return crypto.subtle.digest('SHA-256', data).then(function (hashBuffer) {
            var hashArray = Array.from(new Uint8Array(hashBuffer));
            SettingsService_1.apiKey = hashArray.map(function (b) { return b.toString(16).padStart(2, '0'); }).join('');
        });
    };
    var SettingsService_1;
    SettingsService.EMBEDDED_HEATLEDGER_VERSION = "4.4.2";
    SettingsService.EMBEDDED_HEATLEDGER_BUILD_DATE = "2025-01-28";
    SettingsService.DATEFORMAT_DEFAULT = 'settings.dateformat_default';
    SettingsService.TIMEFORMAT_DEFAULT = 'settings.timeformat_default';
    SettingsService.APPLICATION_NAME = 'settings.application_name';
    SettingsService.APPLICATION_VERSION = 'settings.application_version';
    SettingsService.APPLICATION_BUILD = 'settings.application_build';
    SettingsService.SOCKET_RPC_TIMEOUT = 'settings.socket_rpc_timeout';
    SettingsService.SOCKET_RECONNECT_DELAY = 'settings.socket_reconnect_delay';
    SettingsService.LOG_API_ERRORS = 'settings.log_api_errors';
    SettingsService.LOG_API_ALL = 'settings.log_api_all';
    SettingsService.LOG_NOTIFY_ALL = 'settings.log_notify_all';
    SettingsService.DICE_WORD_FOLDER = 'settings.dice_word_folder';
    SettingsService.DICE_WORD_SUPPORTED_LANG = 'settings.dice_word_supported_lang';
    SettingsService.TRANSACTION_PROCESSING_VISUALIZATION = 'settings.transaction_processing_visualization';
    SettingsService.CAPTCHA_SITE_KEY = 'settings.captcha_site_key';
    SettingsService.CAPTCHA_POPUP = 'settings.captcha_popup';
    SettingsService.HEAT_RPC_TIMEOUT = 'settings.heat_rpc_timeout';
    SettingsService.HEAT_WEBSOCKET_REMOTE = 'settings.heat_websocket_remote';
    SettingsService.HEAT_WEBSOCKET_LOCAL = 'settings.heat_websocket_local';
    SettingsService.HEAT_WEBSOCKET = 'settings.heat_websocket';
    SettingsService.HEAT_MESSAGING = 'settings.heat_messaging';
    SettingsService.LOG_HEAT_ERRORS = 'settings.log_heat_errors';
    SettingsService.LOG_HEAT_ALL = 'settings.log_heat_all';
    SettingsService.LOG_HEAT_NOTIFY_ALL = 'settings.log_heat_notify_all';
    SettingsService.LOG_HEAT_SERVER_ALL = 'settings.log_heat_server_all';
    SettingsService.HEAT_HOST = 'settings.heat_host';
    SettingsService.HEAT_PORT = 'settings.heat_port';
    SettingsService.HEAT_HOST_REMOTE = 'settings.heat_host_remote';
    SettingsService.HEAT_PORT_REMOTE = 'settings.heat_port_remote';
    SettingsService.HEAT_HOST_LOCAL = 'settings.heat_host_local';
    SettingsService.HEAT_PORT_LOCAL = 'settings.heat_port_local';
    SettingsService.HEATLEDGER_CERTIFIER_ACCOUNT = 'settings.heatledger_certifier_account';
    SettingsService.HEATLEDGER_BTC_ASSET = 'settings.heatledger_btc_asset';
    SettingsService.HEATLEDGER_NAME_ASSIGNER = 'settings.heatledger_name_assigner';
    SettingsService.ETHPLORER_INFO_URL = 'settings.ethplorer_get_info_url';
    SettingsService.ETHERSCAN_BALANCES_URL = 'settings.etherscan_get_balances_url';
    SettingsService.ETHERSCAN_TRANSACTION_URL = 'settings.etherscan_get_transactions_url';
    SettingsService.ETHERSCAN_CONTRACT_ABI = 'settings.etherscan_get_contract_abi';
    SettingsService.ETHERSCAN_API_TOKEN = 'settings.etherscan_api.token';
    SettingsService.WEB3PROVIDER = 'settings.web3_provider';
    SettingsService.BIP44_WALLET = 'settings.bip44_wallet';
    SettingsService.ETH_TX_GAS_PRICE = 'settings.gas_price';
    SettingsService.ETH_TX_GAS_REQUIRED = 'settings.gas';
    SettingsService.BENCHMARK_WEB_URL = 'https://benchmarkrewards.com';
    SettingsService = SettingsService_1 = __decorate([
        Service('settings'),
        Inject('env', 'http'),
        __metadata("design:paramtypes", [EnvService,
            HttpService])
    ], SettingsService);
    return SettingsService;
}());
var StatusService = (function () {
    function StatusService() {
    }
    StatusService.prototype.contains = function (status, flag) {
        return Boolean(status & flag);
    };
    StatusService.READ = 1;
    StatusService.TRASHED = 2;
    StatusService.REPLIED = 4;
    StatusService.STARRED = 8;
    StatusService = __decorate([
        Service('status')
    ], StatusService);
    return StatusService;
}());
var StorageService = (function () {
    function StorageService() {
        this.stores = {};
    }
    StorageService.prototype.namespace = function (namespace, $scope, globalScope) {
        var _this = this;
        var store = new Store(namespace, this);
        if ($scope) {
            $scope.$on('$destroy', function () {
                if (store.userServiceListener) {
                    _this.user.removeListener(UserService.EVENT_UNLOCKED, store.userServiceListener);
                }
                _this.removeStore(store);
            });
        }
        this.addStore(store);
        if (!angular.isDefined(globalScope) || !globalScope) {
            this.user = this.user || heat.$inject.get('user');
            if (this.user.unlocked) {
                store.enable(this.user.account);
            }
            if (!store.userServiceListener) {
                store.userServiceListener = function () {
                    store.enable(_this.user.account);
                };
                this.user.on(UserService.EVENT_UNLOCKED, store.userServiceListener);
            }
        }
        else {
            store.enable();
        }
        return store;
    };
    StorageService.prototype.addStore = function (store) {
        (this.stores[store.namespace] = this.stores[store.namespace] || []).push(store);
    };
    StorageService.prototype.removeStore = function (store) {
        if (angular.isArray(this.stores[store.namespace])) {
            this.stores[store.namespace] = this.stores[store.namespace].filter(function (s) { return s != store; });
            if (this.stores[store.namespace].length == 0) {
                delete this.stores[store.namespace];
            }
        }
        store.removeAllListeners();
    };
    StorageService.prototype.emit = function (namespace, event) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var ns = this.stores[namespace];
        if (angular.isArray(ns)) {
            ns.forEach(function (store) {
                store.emit.apply(store, [event].concat(args));
            });
        }
    };
    StorageService = __decorate([
        Service('storage')
    ], StorageService);
    return StorageService;
}());
var Store = (function (_super) {
    __extends(Store, _super);
    function Store(namespace, storage) {
        var _this = _super.call(this) || this;
        _this.namespace = namespace;
        _this.storage = storage;
        _this._enabled = false;
        if (!angular.isString(namespace) || !utils.emptyToNull(namespace))
            throw new Error('Illegal argument, namespace must be a non-empty string');
        return _this;
    }
    Object.defineProperty(Store.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        enumerable: false,
        configurable: true
    });
    Store.prototype.enable = function (userScope) {
        this.prefix = this.namespace + ".";
        if (angular.isDefined(userScope)) {
            this.prefix = userScope + "." + this.prefix;
        }
        this._enabled = true;
    };
    Store.prototype.disable = function () {
        this._enabled = false;
    };
    Store.prototype.ensureIsEnabled = function () {
        if (!this._enabled) {
            throw new Error('Store not enabled. Are you accessing a user scoped Store without a user being signed in?');
        }
    };
    Store.prototype.clear = function () {
        var _this = this;
        this.forEach(function (namespacedKey) { _this.remove(namespacedKey); });
    };
    Store.prototype.remove = function (path) {
        this.ensureIsEnabled();
        var key = this.prefix + path;
        localStorage.removeItem(key);
        this.storage.emit(this.namespace, Store.EVENT_REMOVE, key);
    };
    Store.prototype.put = function (path, val) {
        this.ensureIsEnabled();
        var key = this.prefix + path, value = JSON.stringify(val);
        localStorage.setItem(key, value);
        this.storage.emit(this.namespace, Store.EVENT_PUT, key, value);
    };
    Store.prototype.get = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.getObject = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.getNumber = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.getBoolean = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.getString = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.forEach = function (callbackFn) {
        var _this = this;
        this.keys().forEach(function (namespacedKey) {
            if (callbackFn.length > 1)
                callbackFn(namespacedKey, _this.get(namespacedKey), _this.prefix + namespacedKey);
            else
                callbackFn(namespacedKey);
        });
    };
    Store.prototype.keys = function () {
        var keys = [];
        var fullyQualifiedKey, namespacedKey;
        for (var i = 0; i < localStorage.length; i++) {
            fullyQualifiedKey = localStorage.key(i);
            if (fullyQualifiedKey.indexOf(this.prefix) == 0) {
                namespacedKey = fullyQualifiedKey.substring(this.prefix.length);
                keys.push(namespacedKey);
            }
        }
        return keys;
    };
    Store.prototype.read = function (path, defaultValue) {
        this.ensureIsEnabled();
        var text = localStorage.getItem(this.prefix + path);
        if (angular.isString(text) && text != 'undefined') {
            try {
                return JSON.parse(text);
            }
            catch (e) {
                console.error("Could not read localStorage key '".concat(path, "', throws"), e);
            }
        }
        return angular.isDefined(defaultValue) ? defaultValue : null;
    };
    Store.EVENT_PUT = 'put';
    Store.EVENT_REMOVE = 'remove';
    return Store;
}(EventEmitter));
var TrollboxService = (function () {
    function TrollboxService($rootScope, heat, user) {
        this.$rootScope = $rootScope;
        this.heat = heat;
        this.user = user;
        this.host = "https://heatwallet.com";
        this.port = 7734;
        this.wss = "wss://heatwallet.com:7755/ws/";
        this.subscriber = heat.createSubscriber(this.wss);
    }
    TrollboxService.prototype.join = function (name) {
        this.name = name;
    };
    TrollboxService.prototype.getMessages = function () {
        var fromSlack = this.heat.getRaw(this.host, this.port, '/microservice/trollbox/messages');
        return [fromSlack];
    };
    TrollboxService.prototype.sendMessage = function (message) {
        return this.heat.postRaw(this.host, this.port, '/microservice/trollbox/send', {
            username: this.name,
            message: message,
            publicKey: this.user.publicKey,
            signature: heat.crypto.signBytes(converters.stringToHexString("hello"), converters.stringToHexString(this.user.secretPhrase))
        });
    };
    TrollboxService.prototype.subscribe = function (callback, $scope) {
        return this.subscriber.microservice({ 'microservice': 'trollbox.service' }, callback, $scope);
    };
    TrollboxService = __decorate([
        Service('trollbox'),
        Inject('$rootScope', 'heat', 'user'),
        __metadata("design:paramtypes", [Object, HeatService,
            UserService])
    ], TrollboxService);
    return TrollboxService;
}());
var Update3rdPartyAPIResponsesUtil = (function () {
    function Update3rdPartyAPIResponsesUtil() {
    }
    Update3rdPartyAPIResponsesUtil.updateBTCGetAddressInfo = function (info, btcProvider) {
        if (btcProvider instanceof BtcBlockExplorerBlockbookService) {
            var transactions_2 = new Set();
            if (info.txids) {
                info.txids.forEach(function (txid) {
                    transactions_2.add(txid);
                });
            }
            info.transactions = Array.from(transactions_2);
            info.txApperances = info.txs;
            info.balanceSat = parseInt(info.balance);
            info.unconfirmedBalance = parseInt(info.unconfirmedBalance);
            return info;
        }
        return info;
    };
    Update3rdPartyAPIResponsesUtil.updateBTCGetTxInfo = function (info, btcProvider) {
        if (btcProvider instanceof BtcBlockExplorerBlockbookService) {
            info.blockheight = info.blockHeight;
            return info;
        }
        return info;
    };
    Update3rdPartyAPIResponsesUtil.updateBTCGetTransactions = function (info, btcProvider) {
        if (btcProvider instanceof BtcBlockExplorerBlockbookService) {
            if (Array.isArray(info)) {
                return info.map(function (blockbookTxn) {
                    var vin = (blockbookTxn.vin || []).map(function (input) {
                        return {
                            addr: (input.addresses || [])[0] || "",
                            value: utils.formatQNT(input.value)
                        };
                    });
                    var vout = (blockbookTxn.vout || []).map(function (output) {
                        return {
                            scriptPubKey: {
                                addresses: output.addresses
                            },
                            value: utils.formatQNT(output.value)
                        };
                    });
                    var insightTxn = {
                        blockhash: blockbookTxn.blockHash,
                        blockheight: blockbookTxn.blockHeight,
                        blocktime: blockbookTxn.blockTime,
                        confirmations: blockbookTxn.confirmations,
                        fees: blockbookTxn.fees,
                        hex: blockbookTxn.hex,
                        time: blockbookTxn.blockTime,
                        txid: blockbookTxn.txid,
                        valueIn: utils.formatQNT(blockbookTxn.valueIn),
                        value: utils.formatQNT(blockbookTxn.value),
                        version: 1,
                        vin: vin,
                        vout: vout
                    };
                    return insightTxn;
                });
            }
        }
        return info;
    };
    Update3rdPartyAPIResponsesUtil = __decorate([
        Service('update3rdPartyAPIResponsesUtil')
    ], Update3rdPartyAPIResponsesUtil);
    return Update3rdPartyAPIResponsesUtil;
}());
var UserService = (function (_super) {
    __extends(UserService, _super);
    function UserService($q, $window, localKeyStore, settings, $location, $rootScope) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.$window = $window;
        _this.localKeyStore = localKeyStore;
        _this.settings = settings;
        _this.$location = $location;
        _this.$rootScope = $rootScope;
        _this.unlocked = false;
        return _this;
    }
    UserService_1 = UserService;
    Object.defineProperty(UserService.prototype, "secretPhrase", {
        get: function () {
            return this.__secretPhrase;
        },
        set: function (s) {
            this.__secretPhrase = s;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserService.prototype, "publicKey", {
        get: function () {
            return this.__publicKey;
        },
        set: function (p) {
            this.__publicKey = p;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserService.prototype, "account", {
        get: function () {
            return this.__acount;
        },
        set: function (a) {
            this.__acount = a;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserService.prototype, "accountName", {
        get: function () {
            return this.__accountName;
        },
        set: function (a) {
            this.__accountName = a;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserService.prototype, "accountNameIsPrivate", {
        get: function () {
            return this.__accountNameIsPrivate;
        },
        set: function (a) {
            this.__accountNameIsPrivate = a;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserService.prototype, "key", {
        get: function () {
            return this.__key;
        },
        set: function (k) {
            this.__key = k;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserService.prototype, "currency", {
        get: function () {
            return this.__currency;
        },
        set: function (c) {
            this.__currency = c;
        },
        enumerable: false,
        configurable: true
    });
    UserService.prototype.refresh = function () {
        var _this = this;
        var deferred = this.$q.defer();
        var assigner = this.settings.get(SettingsService.HEATLEDGER_NAME_ASSIGNER);
        var heatService = heat.$inject.get('heat');
        heatService.api.getTransactionsFromTo(assigner, this.account, 0, 10).then(function (transactions) {
            for (var i = 0; i < transactions.length; i++) {
                var rawText = heatService.getHeatMessageContents(transactions[i]);
                if (rawText) {
                    if (_this.tryParseRegistrationMessage(rawText)) {
                        return;
                    }
                }
            }
        }).finally(deferred.resolve);
        return deferred.promise;
    };
    UserService.prototype.unlock = function (secretPhrase, key, bip44Compatible, currency) {
        var _this = this;
        var deferred = this.$q.defer();
        this.$rootScope.$evalAsync(function () {
            _this.$rootScope.$evalAsync(function () {
                if (key)
                    _this.key = key;
                _this.unlocked = true;
                _this.accountName = '[no name]';
                var masterSecretPhrase;
                if (!currency || currency.symbol == 'HEAT') {
                    masterSecretPhrase = secretPhrase;
                    var address = heat.crypto.getAccountId(masterSecretPhrase);
                    _this.currency = new HEATCurrency(masterSecretPhrase, masterSecretPhrase, address);
                }
                else {
                    masterSecretPhrase = currency.masterSecretPhrase;
                    _this.currency = currency;
                }
                if (masterSecretPhrase && _this.secretPhrase !== masterSecretPhrase) {
                    _this.bip44Compatible = bip44Compatible || false;
                    _this.secretPhrase = masterSecretPhrase;
                    _this.publicKey = heat.crypto.secretPhraseToPublicKey(masterSecretPhrase);
                    _this.account = heat.crypto.getAccountId(masterSecretPhrase);
                }
                _this.accountName = _this.account || _this.currency.address;
                _this.refresh().then(function () {
                    deferred.resolve();
                    _this.emit(UserService_1.EVENT_UNLOCKED);
                });
            });
        });
        return deferred.promise;
    };
    UserService.prototype.lock = function (noreload) {
        this.key = null;
        this.secretPhrase = null;
        this.unlocked = false;
        this.account = null;
        this.currency = null;
        this.bip44Compatible = false;
        this.emit(UserService_1.EVENT_LOCKED);
        if (noreload)
            return;
        dialogs.showProgressMessage(null, "Signing out");
        setTimeout(function () { return window.location.reload(); }, 2000);
    };
    UserService.prototype.requireLogin = function () {
        if (!this.unlocked) {
            this.$location.path('login');
        }
    };
    UserService.prototype.tryParseRegistrationMessage = function (rawText) {
        var regexp = /You have chosen the (public|private) user name `(.*)`/m;
        var match = rawText.match(regexp);
        if (match) {
            this.accountNameIsPrivate = match[1] == 'private';
            this.accountName = match[2];
            if (this.key && this.key.name != this.accountName) {
                this.key.name = this.accountName;
                this.localKeyStore.put(this.key);
            }
            return true;
        }
        return false;
    };
    var UserService_1;
    UserService.EVENT_UNLOCKED = 'unlocked';
    UserService.EVENT_LOCKED = 'locked';
    UserService = UserService_1 = __decorate([
        Service('user'),
        Inject('$q', '$window', 'localKeyStore', 'settings', '$location', '$rootScope'),
        __metadata("design:paramtypes", [Object, Object, LocalKeyStoreService,
            SettingsService, Object, Object])
    ], UserService);
    return UserService;
}(EventEmitter));
var WalletFileService = (function () {
    function WalletFileService() {
    }
    WalletFileService.prototype.createFromText = function (data) {
        return this.decode(data);
    };
    WalletFileService.prototype.encode = function (walletFile) {
        return JSON.stringify(walletFile, null, 2);
    };
    WalletFileService.prototype.decode = function (data) {
        if (!data)
            return null;
        var version = data.version;
        if (!angular.isNumber(version))
            return null;
        var supportedDecodingVersion = [1, 2];
        if (!supportedDecodingVersion.includes(version))
            return null;
        var entries = data.entries;
        if (!angular.isArray(entries))
            return null;
        var walletFile = {
            version: version,
            entries: [],
            accountAddresses: data.accountAddresses,
            paymentMessages: data.paymentMessages
        };
        entries.forEach(function (entry) {
            if (angular.isString(entry.contents)) {
                walletFile.entries.push(entry);
            }
        });
        return walletFile;
    };
    WalletFileService.prototype.parseJSON = function (contents) {
        try {
            var json = JSON.parse(contents);
            if (angular.isObject(json))
                return json;
        }
        catch (e) {
            console.log('Could not parse wallet file', e);
        }
    };
    WalletFileService.prototype.importRawData = function (data) {
        try {
            var keys = Object.keys(data);
            keys.forEach(function (k) { return localStorage.setItem(k, data[k]); });
            return "Imported ".concat(keys.length, " items");
        }
        catch (e) {
            return " Error " + e.toString();
        }
    };
    WalletFileService = __decorate([
        Service('walletFile')
    ], WalletFileService);
    return WalletFileService;
}());
var Web3Service = (function () {
    function Web3Service($q, userService, settingsService, $window, http, storage) {
        var _this = this;
        this.$q = $q;
        this.userService = userService;
        this.settingsService = settingsService;
        this.$window = $window;
        this.http = http;
        this.storage = storage;
        this.getAddressNonce = function (address) {
            return new Promise(function (resolve, reject) {
                _this.http.get(_this.blockbookEndpoint + "/address/" + address).then(function (resp) {
                    var respObj = angular.isString(resp) ? JSON.parse(resp) : resp;
                    if (respObj.nonce) {
                        resolve(respObj.nonce);
                    }
                    else {
                        reject("response has no nonce");
                    }
                }, function (reason) {
                    var $rootScope = heat.$inject.get('$rootScope');
                    var store = _this.storage.namespace('currency-cache-eth', $rootScope, true);
                    var cache = {
                        get: function (key) { return store.get(address + "-" + key); }
                    };
                    var info = cache.get("info");
                    if (info) {
                        resolve(info.nonce);
                    }
                    else {
                        reject(reason);
                    }
                });
            });
        };
        this.getGasPrice = function () {
            return new Promise(function (resolve) {
                _this.http.get(_this.blockbookEndpoint + "/estimatefee/5").then(function (response) {
                    if (!response)
                        resolve(20000000000);
                    var r = angular.isString(response) ? JSON.parse(response) : response;
                    resolve(_this.web3.toWei(r.result, 'ether'));
                }, function (reason) {
                    resolve(20000000000);
                });
            });
        };
        this.createRawTx2 = function (account, to, value, gasPriceParam, gasLimitParam, getAddressNonce) {
            return new Promise(function (resolve, reject) {
                _this.getGasPrice().then(function (gasPrice) {
                    var f = getAddressNonce || _this.getAddressNonce;
                    return f(account.address).then(function (nonce) {
                        var defaultGasLimit = _this.settingsService.get(SettingsService.ETH_TX_GAS_REQUIRED);
                        var txParams = {
                            nonce: '0x' + Number(nonce).toString(16),
                            gasLimit: _this.web3.toHex(gasLimitParam || defaultGasLimit),
                            gasPrice: _this.web3.toHex(String(gasPriceParam || gasPrice)),
                            to: to,
                            value: '0x' + Number(value).toString(16)
                        };
                        var tx;
                        try {
                            tx = new _this.$window.heatlibs.ethereumTx.Transaction(txParams);
                        }
                        catch (e) {
                            reject((e === null || e === void 0 ? void 0 : e.message) || e || "ETH transaction creation error");
                            return;
                        }
                        var privateKey = _this.$window.heatlibs.safeBuffer.Buffer.from(account.privateKey, 'hex');
                        tx.sign(privateKey);
                        resolve('0x' + tx.serialize().toString('hex'));
                    }, function (reason) { return reject(reason); });
                });
            });
        };
        var Web3 = $window.heatlibs.Web3;
        this.safeBuffer = $window.heatlibs.safeBuffer;
        this.ethereumTx = $window.heatlibs.ethereumTx;
        this.web3 = new Web3(new Web3.providers.HttpProvider(this.settingsService.get(SettingsService.WEB3PROVIDER)));
        this.settingsService.initialized.then(function () { return _this.blockbookEndpoint = SettingsService.getCryptoServerEndpoint('ETH'); });
    }
    Web3Service.prototype.parseInput = function (input) {
        return this.web3.toAscii(input);
    };
    Web3Service.prototype.sendEther = function (account, _to, _value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.createRawTx2(account, _to, _value).then(function (rawTx) {
                _this.http.get(_this.blockbookEndpoint + "/sendtx/" + rawTx).then(function (resp) {
                    resolve({ txHash: resp });
                }, function (reason) {
                    reject(reason);
                });
            }).catch(function (reason) { return reject(reason); });
        });
    };
    Web3Service = __decorate([
        Service('web3'),
        Inject('$q', 'user', 'settings', '$window', 'http', 'storage'),
        __metadata("design:paramtypes", [Function, UserService,
            SettingsService, Object, HttpService,
            StorageService])
    ], Web3Service);
    return Web3Service;
}());
var dialogs;
(function (dialogs) {
    function about($event) {
        var settings = heat.$inject.get('settings');
        var env = heat.$inject.get('env');
        dialogs.dialog({
            id: 'about',
            title: 'About',
            targetEvent: $event,
            template: "\n        <p>{{vm.applicationName}} {{vm.applicationVersion}}<br>Build date: {{vm.applicationBuild}}</p>\n        <p>HEAT server {{vm.heatServerVersion}}<br>Build date: {{vm.heatServerBuildDate}}</p>\n        <p><a href=\"#\" ng-click=\"vm.goTo('main')\">Go to MAIN NET</a></p>\n        <p><a href=\"#\" ng-click=\"vm.goTo('test')\">Go to TEST NET</a></p>\n<!--        <p><a href=\"#\" ng-click=\"vm.goTo('beta')\">Go to BETA NET</a></p>-->\n        <p>\n<!--            <a ng-href=\"{{vm.benchmarkUrl}}\" target=\"_blank\" rel=\"noopener noreferrer\">BENCHMARK application</a><br/>-->\n            <a href=\"#\" ng-click=\"vm.goTo('bench')\">BENCHMARK application</a>\n        </p>\n        <br>\n        <p>Ethereum API <u>Powered by <a href=\"https://ethplorer.io\">Ethplorer.io</a></u></p>\n        <!--\n        <p><button onclick=\"gtag_report_conversion_signup(undefined)\">Signup Test</button></p>\n        <p><button onclick=\"gtag_report_conversion_bid(undefined, Date.now()+'')\">Bid Test</button></p>\n        <p><button onclick=\"gtag_report_conversion_signup_SECURE(undefined)\">Signup Test [SECURE]</button></p>\n        <p><button onclick=\"gtag_report_conversion_bid_SECURE(undefined, Date.now()+'')\">Bid Test [SECURE]</button></p>\n        -->\n\n      ",
            locals: {
                applicationName: settings.get(SettingsService.APPLICATION_NAME),
                applicationVersion: settings.get(SettingsService.APPLICATION_VERSION),
                applicationBuild: settings.get(SettingsService.APPLICATION_BUILD),
                heatServerVersion: SettingsService.EMBEDDED_HEATLEDGER_VERSION,
                heatServerBuildDate: SettingsService.EMBEDDED_HEATLEDGER_BUILD_DATE,
                isTestnet: window.localStorage.getItem('testnet') == 'true',
                benchmarkUrl: SettingsService.BENCHMARK_WEB_URL,
                isEnvNodeJS: env.type == EnvType.NODEJS,
                goTo: function (target) {
                    window.localStorage.setItem('testnet', 'false');
                    window.localStorage.setItem('betanet', 'false');
                    if (target == 'test') {
                        window.localStorage.setItem('testnet', 'true');
                    }
                    else if (target == 'beta') {
                        window.localStorage.setItem('betanet', 'true');
                    }
                    else if (target == 'bench') {
                        if (env.type == EnvType.NODEJS) {
                            var BrowserWindow = require('electron').remote.BrowserWindow;
                            var benchWindow_1 = new BrowserWindow({
                                width: 1200,
                                height: 800,
                                webPreferences: {
                                    nodeIntegration: false
                                },
                                show: false,
                                backgroundColor: '#d22424'
                            });
                            benchWindow_1.once('ready-to-show', function () {
                                benchWindow_1.show();
                            });
                            benchWindow_1.loadURL(SettingsService.BENCHMARK_WEB_URL);
                        }
                        else {
                            window.location.assign(SettingsService.BENCHMARK_WEB_URL);
                        }
                        return;
                    }
                    window.location.reload();
                }
            }
        });
    }
    dialogs.about = about;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function assetInfo($event, info) {
        var assetInfoService = heat.$inject.get('assetInfo');
        var unsafeWarning = "This asset is operated by a third party.\nHeat Ledger has no control over the asset and does not provide support for it.\nIt's possible the asset does NOT represent what you think it does.\nPlease ensure from asset issuer that the asset is valid before purchasing it, as there may be no refunds or redemptions available.\nAsset purchases are non-refundable.";
        assetInfoService.getAssetDescription(info).then(function (description) {
            var orderFeePercentage = parseInt(info.orderFee || '0') / 1000000;
            var tradeFeePercentage = parseInt(info.tradeFee || '0') / 1000000;
            var feeRecipient = (info.feeRecipient || '0') == '0' ? info.issuer : info.feeRecipient;
            info.expired = utils.isAssetExpired(info.expiration);
            dialogs.dialog({
                id: 'assetInfo',
                title: 'Asset Info',
                targetEvent: $event,
                cancelButton: false,
                locals: {
                    description: description,
                    info: info,
                    unsafeWarning: unsafeWarning,
                    createdDate: utils.timestampToDate(info.timestamp).toLocaleString(),
                    expirationDate: info.expiration == 0
                        ? "no expiration"
                        : (info.expiration ? utils.timestampToDate(info.expiration).toLocaleString() : null),
                    orderFeePercentage: parseInt(info.orderFee || '0') / 1000000,
                    tradeFeePercentage: parseInt(info.tradeFee || '0') / 1000000,
                    feeRecipient: (info.feeRecipient || '0') == '0' ? info.issuer : info.feeRecipient
                },
                style: "\n          .grey {\n            color: darkgrey;\n          }\n        ",
                template: "\n          <div layout=\"column\">\n            <span ng-if=\"!vm.info.certified\">{{vm.unsafeWarning}}<br><br></span>\n            <span><b>{{vm.info.symbol}}</b> {{vm.info.name}}</span>\n            <p class=\"grey\" ng-if=\"vm.info.type==1\">\n              <span>PRIVATE ASSET</span><br/>\n              Order fee: {{vm.orderFeePercentage}}% &nbsp;&nbsp;&nbsp;Trade fee: {{vm.tradeFeePercentage}}% &nbsp;&nbsp;&nbsp;Fee recipient: {{vm.feeRecipient}}\n            </p>\n            <p class=\"grey\">\n                id: {{vm.info.id}} &nbsp;&nbsp;&nbsp; decimals: {{vm.info.decimals}}<br/>\n                created: {{vm.createdDate}}<br/>\n                expiration: {{vm.expirationDate || \"-\"}} &nbsp;&nbsp;<b>{{vm.info.expired ? \"EXPIRED\" : \"\"}}</b><br/>\n                issuer: {{vm.info.issuerPublicName || vm.info.issuer}}\n            </p>\n            <pre>{{vm.description}}</pre>\n          </div>\n        "
            });
        });
    }
    dialogs.assetInfo = assetInfo;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function blockDetails($event, blockId) {
        var $q = heat.$inject.get('$q');
        var heatApi = heat.$inject.get('heat');
        var deferred = $q.defer();
        heatApi.api.getBlock(blockId, true).then(function (response) {
            var sumofamounts = new Big("0");
            response.transactions.forEach(function (transaction) {
                sumofamounts = sumofamounts.add(new Big(transaction.amount));
            });
            dialogs.dialog({
                id: 'blockDetails',
                title: 'Block details',
                targetEvent: $event,
                cancelButton: false,
                locals: {
                    blockId: blockId,
                    height: response.height,
                    baseTarget: response.baseTarget,
                    numberOfTransactions: response.numberOfTransactions,
                    generator: response.generator,
                    posRewardHQT: response.posRewardHQT,
                    popRewardHQT: response.popRewardHQT,
                    sumofamounts: utils.commaFormat(utils.formatQNT(sumofamounts.toString(), 8)) + ' HEAT',
                    transactions: response.transactions,
                    showTransactionDetails: function ($event, transaction) {
                        dialogs.transactionDetails($event, transaction);
                    }
                },
                style: "\n         .dialog-block-details td {\n            padding: 8px;\n         }\n         .dialog-block-details ul {\n            list-style-type: none;\n            padding-left: 0px;\n            margin-left: 0px;\n         }\n         .dialog-block-details ul li {\n            padding-bottom: 5px;\n         }\n         .dialog-block-details .link-block {\n            cursor: pointer;\n            color: #3b5998;\n            text-decoration: underline;\n          }\n        ",
                template: "\n           <div layout=\"column\" class=\"dialog-block-details\">\n             <table>\n               <tr><td>Block id</td><td>{{vm.blockId}}</td></tr>\n               <tr><td>Block height</td><td>{{vm.height}}</td></tr>\n               <tr><td>Base target</td><td>{{vm.baseTarget}}</td></tr>\n               <tr><td>Number of transactions</td><td>{{vm.numberOfTransactions}}</td></tr>\n               <tr><td>Generator</td><td>{{vm.generator}}</td></tr>\n               <tr><td>POS reward</td><td>{{vm.posRewardHQT}}</td></tr>\n               <tr><td>POP reward</td><td>{{vm.popRewardHQT}}</td></tr>\n               <tr><td>Total HEAT transferred</td><td>{{vm.sumofamounts}}</td></tr>\n               <tr ng-if=\"vm.transactions.length\"><td>Transactions</td>\n                <td>\n                  <ul>\n                    <li ng-repeat=\"trans in vm.transactions\" ng-click=\"vm.showTransactionDetails($event, trans)\" class=\"link-block\">{{trans.transaction}}</li>\n                  </ul>\n                </td>\n               </tr>\n             </table>\n           </div>\n         "
            }).then(deferred.resolve, deferred.reject);
        });
        return deferred.promise;
    }
    dialogs.blockDetails = blockDetails;
})(dialogs || (dialogs = {}));
var QRCode;
var dialogs;
(function (dialogs) {
    function depositAsset($event, assetInfo) {
        var http = heat.$inject.get('http');
        var user = heat.$inject.get('user');
        var $q = heat.$inject.get('$q');
        var clipboard = heat.$inject.get('clipboard');
        var localKeyStore = heat.$inject.get('localKeyStore');
        var env = heat.$inject.get('env');
        var account = user.account, publicKey = user.publicKey;
        var noteOne = "Deposit address is associated with account HEAT ".concat(account, " and public key ").concat(publicKey);
        var url = "https://heatwallet.com/getaddr.cgi?heataccount=".concat(account, "&publickey=").concat(publicKey, "&aid=").concat(assetInfo.id);
        var deferred = $q.defer();
        http.get(url).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            dialogs.dialog({
                id: 'depositAsset',
                title: "Deposit ".concat(assetInfo.symbol),
                targetEvent: $event,
                okButton: true,
                style: "\n          .qrcodeBox {\n            margin:10px;\n          }\n        ",
                template: "\n          <div>\n            <p>{{vm.symbol}} Deposit address <b id=\"deposit-dialog-btc-address-element\">{{vm.address}}</b>&nbsp;<a ng-click=\"vm.copyAddress()\">[copy]</a></p>\n            <p>{{vm.noteOne}}</p>\n            <p><div class=\"qrcodeBox\" id=\"depositeAddressQRCode\"></div></p>\n            <p></p>\n            <p>\n              <div ng-bind-html=\"vm.dialogue\"></div>\n            </p>\n          </div>\n        ",
                locals: {
                    noteOne: noteOne,
                    dialogue: parsed.deposit.dialogue,
                    isBtc: parsed.deposit.dialogue.includes('5592059897546023466'),
                    address: parsed.deposit.address,
                    shorQR: function () {
                        showQrCodeOnDialogLoad(parsed.deposit.address);
                    }(),
                    copyAddress: function () {
                        clipboard.copyWithUI(document.getElementById('deposit-dialog-btc-address-element'), 'Copied address to clipboard');
                    },
                    symbol: assetInfo.symbol
                }
            }).then(deferred.resolve, deferred.reject);
        });
        return deferred.promise;
    }
    dialogs.depositAsset = depositAsset;
    function showQrCodeOnDialogLoad(data) {
        setTimeout(function () {
            new QRCode("depositeAddressQRCode", {
                text: data,
                width: 128,
                height: 128,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        }, 1000);
    }
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function showEtherDepositDialog($event, address) {
        var clipboard = heat.$inject.get('clipboard');
        return dialogs.dialog({
            id: 'showEtherDepositDialog',
            title: "Deposit Ether",
            targetEvent: $event,
            cancelButton: false,
            okButton: true,
            locals: {
                userEtherWalletAddress: address,
                copyAddress: function () {
                    clipboard.copyWithUI(document.getElementById('deposit-dialog-eth-address-element'), 'Copied address to clipboard');
                }
            },
            template: "\n        <div layout=\"column\" flex>\n          Deposit the desired amount of Ether(ETH) to your Ethereum Address\n          <b id=\"deposit-dialog-eth-address-element\"> {{vm.userEtherWalletAddress}} </b>&nbsp;\n          <a ng-click=\"vm.copyAddress()\">[copy]</a>&nbsp;\n        </div>\n      "
        });
    }
    dialogs.showEtherDepositDialog = showEtherDepositDialog;
})(dialogs || (dialogs = {}));
heat.Loader.directive('autoFocus', function ($timeout) {
    'use strict';
    return {
        restrict: 'A',
        link: function (_scope, _element) {
            $timeout(function () {
                _element[0].focus();
            }, 500);
        }
    };
});
var dialogs;
(function (dialogs) {
    function $mdDialog() {
        return heat.$inject.get('$mdDialog');
    }
    dialogs.$mdDialog = $mdDialog;
    function dialog(options) {
        if (angular.isString(options.style)) {
            var styleId = 'dialog-style-' + options.id;
            if (!document.getElementById(styleId)) {
                angular.element(document).find('head').append("<style type=\"text/css\" id=\"".concat(styleId, "\">").concat(options.style, "</style>"));
            }
        }
        return dialogs.$mdDialog().show({
            controller: options.controller || function () { },
            locals: angular.extend({
                isBetanet: heat.isBetanet,
                title: options.title,
                okButton: angular.isDefined(options.okButton) ? options.okButton : true,
                cancelButton: options.cancelButton,
                $mdDialog: dialogs.$mdDialog()
            }, options.locals || {}),
            controllerAs: 'vm',
            bindToController: true,
            parent: angular.element(document.body),
            targetEvent: options.targetEvent,
            template: "\n      <md-dialog>\n        <md-toolbar ng-if=\"vm.isBetanet\" style=\"background-color: #bf112f !important\">\n          <div class=\"md-toolbar-tools\">\n            <h2>B E T A N E T</h2>\n          </div>\n        </md-toolbar>\n        <form name=\"dialogForm\">\n          <md-toolbar>\n            <div class=\"md-toolbar-tools\"><h2>{{vm.title}}</h2></div>\n          </md-toolbar>\n          <md-dialog-content style=\"min-width:500px;max-width:650px\" layout=\"column\" layout-padding>\n            <div flex layout=\"column\">\n              ".concat(options.template, "\n            </div>\n          </md-dialog-content>\n          <md-dialog-actions layout=\"row\">\n            <span flex></span>\n            <md-button ng-if=\"vm.cancelButton\" class=\"md-warn\" ng-click=\"vm.cancelButtonClick ? vm.cancelButtonClick() : vm.$mdDialog.cancel()\" aria-label=\"Cancel\">Cancel</md-button>\n            <md-button type=\"submit\" ng-disabled=\"dialogForm.$invalid\" ng-if=\"vm.okButton\" class=\"md-primary\"\n              ng-click=\"vm.okButtonClick ? vm.okButtonClick() : vm.$mdDialog.hide()\" aria-label=\"OK\">{{vm.okButtonLabel?vm.okButtonLabel:'OK'}}</md-button>\n          </md-dialog-actions>\n        </form>\n      </md-dialog>\n      ")
        });
    }
    dialogs.dialog = dialog;
    function wizard(options) {
        if (angular.isString(options.style)) {
            var styleId = 'wizard-style-' + options.id;
            if (!document.getElementById(styleId)) {
                angular.element(document).find('head').append("<style type=\"text/css\" id=\"".concat(styleId, "\">").concat(options.style, "</style>"));
            }
        }
        return dialogs.$mdDialog().show({
            controller: options.controller || function () { },
            locals: angular.extend({
                title: options.title,
                cancelButton: options.cancelButton,
                $mdDialog: dialogs.$mdDialog(),
                pages: options.pages,
                wizardIndex: 0,
                goToNextPage: function () {
                    this.wizardIndex++;
                    if (angular.isFunction(this.pages[this.wizardIndex].show)) {
                        this.pages[this.wizardIndex].show(this, this.wizardIndex - 1);
                    }
                },
                goToPreviousPage: function () {
                    this.wizardIndex--;
                    if (angular.isFunction(this.pages[this.wizardIndex].show)) {
                        this.pages[this.wizardIndex].show(this, this.wizardIndex + 1);
                    }
                }
            }, options.locals || {}),
            controllerAs: 'vm',
            bindToController: true,
            parent: angular.element(document.body),
            targetEvent: options.targetEvent,
            template: "\n      <md-dialog>\n        <form name=\"dialogForm\">\n          <md-toolbar>\n            <div class=\"md-toolbar-tools\"><h2>{{vm.title}}<span ng-show=\"vm.pages[vm.wizardIndex].title\">{{vm.pages[vm.wizardIndex].title}}</span></h2></div>\n          </md-toolbar>\n          <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n            <div flex layout=\"column\">\n              ".concat(options.pages.map(function (page, index) {
                return "<div flex layout=\"column\" ng-if=\"vm.wizardIndex==".concat(index, "\">") +
                    page.template +
                    '</div>';
            }).join(''), "\n            </div>\n          </md-dialog-content>\n          <md-dialog-actions layout=\"row\">\n            <md-button ng-show=\"!vm.hideCancelBtn\"\n                ng-click=\"vm.cancelButtonClick ? vm.cancelButtonClick() : vm.$mdDialog.cancel()\" aria-label=\"Cancel\">Cancel</md-button>\n            <span flex></span>\n            <md-button ng-click=\"vm.goToPreviousPage()\"\n                ng-show=\"vm.wizardIndex>0 && !vm.hideBackBtn\" aria-label=\"Back\">Back</md-button>\n            <md-button ng-disabled=\"dialogForm.$invalid\"\n                ng-show=\"vm.wizardIndex < (vm.pages.length-1)\"\n                ng-click=\"vm.goToNextPage()\" aria-label=\"Continue\">{{vm.pages[vm.wizardIndex].continueBtnLabel||'Continue'}}</md-button>\n            <md-button ng-disabled=\"dialogForm.$invalid\"\n                ng-show=\"vm.wizardIndex == (vm.pages.length-1) && !vm.hideOkBtn\"\n                ng-click=\"vm.okButtonClick ? vm.okButtonClick() : vm.$mdDialog.hide()\" aria-label=\"Ok\">{{vm.pages[vm.wizardIndex].okBtnLabel||'Ok'}}</md-button>\n          </md-dialog-actions>\n        </form>\n      </md-dialog>\n      ")
        });
    }
    dialogs.wizard = wizard;
    function confirm(title, content, mdDialog) {
        if (mdDialog) {
            mdDialog($mdDialog());
        }
        return dialogs.dialog({
            id: 'confirmDialog',
            title: title,
            okButton: true,
            cancelButton: true,
            locals: {
                content: content
            },
            template: "\n        <!--<md-input-container flex>-->\n        <p ng-bind-html=\"vm.content\"></p>\n        <!--</md-input-container>-->\n      "
        });
    }
    dialogs.confirm = confirm;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function download($event, account) {
        var $q = heat.$inject.get('$q');
        var heatApi = heat.$inject.get('heat');
        var $timeout = heat.$inject.get('$timeout');
        var $rootScope = heat.$inject.get('$rootScope');
        var settings = heat.$inject.get('settings');
        var assetInfo = heat.$inject.get('assetInfo');
        var format = settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var locals = {
            transactions: {
                total: 0,
                array: [],
                percent: 0,
                done: false
            },
            trades: {
                total: 0,
                array: [],
                percent: 0,
                done: false
            },
            currencies: [],
            symbols: {}
        };
        heatApi.api.getTransactionsForAccountCount(account).then(function (count) {
            var scopes = [];
            for (var i = 0; i < count; i += 100) {
                scopes.push([i, i + 99]);
            }
            $rootScope.$evalAsync(function () {
                locals.transactions.total = count;
            });
            recursiveGetTransactions(account, scopes, function (transaction) {
                $rootScope.$evalAsync(function () {
                    if (transaction == null) {
                        locals.transactions.percent = 100;
                        locals.transactions.done = true;
                        done();
                    }
                    else {
                        locals.transactions.array.push(transaction);
                        locals.transactions.percent = Math.round(locals.transactions.array.length / (locals.transactions.total / 100));
                    }
                });
            });
        });
        heatApi.api.getAllAccountTradesCount(account).then(function (count) {
            var scopes = [];
            for (var i = 0; i < count; i += 100) {
                scopes.push([i, i + 99]);
            }
            $rootScope.$evalAsync(function () {
                locals.trades.total = count;
            });
            recursiveGetTrades(account, scopes, function (trade) {
                $rootScope.$evalAsync(function () {
                    if (trade == null) {
                        locals.trades.percent = 100;
                        locals.trades.done = true;
                        done();
                    }
                    else {
                        locals.trades.array.push(trade);
                        locals.trades.percent = Math.round(locals.trades.array.length / (locals.trades.total / 100));
                    }
                });
            });
        });
        function done() {
            if (locals.transactions.done && locals.trades.done) {
                console.log('duplicates', collectDuplicates(locals.transactions.array));
                var assets_1 = collectAssets(locals.transactions.array, locals.trades.array);
                getAssetSymbols(assets_1).then(function (symbols) {
                    $rootScope.$evalAsync(function () {
                        assets_1.forEach(function (asset) {
                            var symbol = symbols[asset].symbol;
                            locals.currencies.push({
                                id: asset,
                                symbol: symbol,
                                download: createDownloadFunction(asset, symbol)
                            });
                            locals.symbols[asset] = symbol;
                        });
                    });
                });
            }
        }
        function createDownloadFunction(currency, symbol) {
            return function () {
                var entries = [];
                locals.transactions.array.forEach(function (t) {
                    if (filterTransaction(currency, t))
                        entries.push(transactionToHistory(currency, t));
                });
                locals.trades.array.forEach(function (t) {
                    if (filterTrade(currency, t))
                        entries.push(tradeToHistory(currency, t));
                });
                entries.sort(function (a, b) { return a.timestamp - b.timestamp; });
                var csv = historyToCSV(entries);
                download(csv, account + '.' + symbol + '.csv');
            };
        }
        function collectAssets(transactions, trades) {
            var assets = { "0": 1 };
            transactions.forEach(function (transaction) {
                var type = transaction.type, subType = transaction.subtype;
                if (type == 2 && subType == 4 || type == 2 && subType == 3) {
                    assets[transaction.attachment.asset] = 1;
                    assets[transaction.attachment.currency] = 1;
                }
                if (type == 2 && subType == 2) {
                    assets[transaction.attachment.asset] = 1;
                }
            });
            trades.forEach(function (trade) {
                assets[trade.asset] = 1;
                assets[trade.currency] = 1;
            });
            return Object.getOwnPropertyNames(assets);
        }
        function collectDuplicates(transactions) {
            var dups = {};
            transactions.forEach(function (transaction) {
                if (typeof dups[transaction.transaction] == "number") {
                    dups[transaction.transaction]++;
                }
                else {
                    dups[transaction.transaction] = 1;
                }
            });
            var collect = {};
            Object.getOwnPropertyNames(dups).forEach(function (name) {
                if (dups[name] > 1) {
                    collect[name] = dups[name];
                }
            });
            return collect;
        }
        function getAssetSymbols(assets) {
            var promises = [];
            var data = {};
            assets.forEach(function (asset) {
                promises.push(assetInfo.getInfo(asset).then(function (info) {
                    data[asset] = info;
                }));
            });
            return Promise.all(promises).then(function () { return data; });
        }
        function filterTransaction($currency, transaction) {
            if ($currency == "0")
                return true;
            var type = transaction.type, subType = transaction.subtype;
            if (type == 2 && subType == 4 || type == 2 && subType == 3) {
                return transaction.attachment.asset == $currency || transaction.attachment.currency == $currency;
            }
            if (type == 2 && subType == 2) {
                return transaction.attachment.asset == $currency;
            }
        }
        function filterTrade($currency, trade) {
            return trade.currency == $currency || trade.asset == $currency;
        }
        function recursiveGetTransactions(account, scopes, reporter) {
            var scope = scopes.shift();
            if (!scope) {
                reporter(null);
                return;
            }
            var deferred = $q.defer();
            heatApi.api.getTransactionsForAccount(account, scope[0], scope[1]).then(function (transactions) {
                transactions.forEach(function (transaction) {
                    reporter(transaction);
                });
                $timeout(function () {
                    recursiveGetTransactions(account, scopes, reporter);
                });
            }).catch(deferred.reject);
            return deferred.promise;
        }
        function recursiveGetTrades(account, scopes, reporter) {
            var scope = scopes.shift();
            if (!scope) {
                reporter(null);
                return;
            }
            var deferred = $q.defer();
            heatApi.api.getAllAccountTrades(account, "0", 0, scope[0], scope[1]).then(function (trades) {
                trades.forEach(function (trade) {
                    reporter(trade);
                });
                $timeout(function () {
                    recursiveGetTrades(account, scopes, reporter);
                });
            }).catch(deferred.reject);
            return deferred.promise;
        }
        function transactionToHistory($currency, transaction) {
            var entry = {}, type = transaction.type, subType = transaction.subtype;
            entry.timestamp = transaction.timestamp;
            entry.ID = transaction.transaction;
            entry.TIME = dateFormat(utils.timestampToDate(transaction.timestamp), format);
            entry.TYPE = encodeTxType(type, subType);
            if (transaction.sender == account)
                entry.FEE = utils.formatQNT(transaction.fee, 8);
            else
                entry.FEE = "0";
            entry.MESSAGE = heatApi.getHeatMessageContents(transaction);
            entry.ACCOUNT = transaction.sender == account ? transaction.recipient : transaction.sender;
            entry.AMOUNT = '0';
            entry.ASSET = '';
            entry.PRICE = '';
            entry.TOTAL = '';
            if (type == 2 && subType == 4) {
                var total = utils.calculateTotalOrderPriceQNT(transaction.attachment.quantity, transaction.attachment.price);
                entry.PRICE = utils.formatQNT(transaction.attachment.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                entry.ASSET = transaction.attachment.asset == $currency ? transaction.attachment.asset : transaction.attachment.currency;
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            }
            else if (type == 2 && subType == 3) {
                var total = utils.calculateTotalOrderPriceQNT(transaction.attachment.quantity, transaction.attachment.price);
                entry.PRICE = utils.formatQNT(transaction.attachment.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                entry.ASSET = transaction.attachment.asset == $currency ? transaction.attachment.asset : transaction.attachment.currency;
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            }
            else if (type == 1 && subType == 0) {
            }
            else if (type == 0 && subType == 0) {
                entry.ASSET = "0";
                entry.ASSET_SYMBOL = "HEAT";
                if (transaction.sender == transaction.recipient)
                    entry.AMOUNT = "0";
                else if (transaction.recipient == account)
                    entry.AMOUNT = utils.formatQNT(transaction.amount, 8);
                else
                    entry.AMOUNT = "-" + utils.formatQNT(transaction.amount, 8);
            }
            else if (type == 2 && subType == 2) {
                entry.ASSET = transaction.attachment.asset;
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
                if (transaction.sender == transaction.recipient)
                    entry.AMOUNT = "0";
                else if (transaction.recipient == account)
                    entry.AMOUNT = utils.formatQNT(transaction.attachment.quantity, 8);
                else
                    entry.AMOUNT = "-" + utils.formatQNT(transaction.attachment.quantity, 8);
            }
            else if (type == 2 && subType == 6) {
                var quantity = transaction.attachment.cancelledOrderQuantity || "0";
                var price = transaction.attachment.cancelledOrderPrice || "0";
                var total = quantity != "0" && price != "0" ? utils.calculateTotalOrderPriceQNT(quantity, price) : "0";
                entry.PRICE = utils.formatQNT(transaction.attachment.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                entry.ASSET = transaction.attachment.cancelledOrderAsset ? (transaction.attachment.cancelledOrderAsset == $currency ? transaction.attachment.asset : transaction.attachment.currency) : '';
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            }
            else if (type == 2 && subType == 5) {
                var quantity = transaction.attachment.cancelledOrderQuantity || "0";
                var price = transaction.attachment.cancelledOrderPrice || "0";
                var total = quantity != "0" && price != "0" ? utils.calculateTotalOrderPriceQNT(quantity, price) : "0";
                entry.PRICE = utils.formatQNT(transaction.attachment.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                entry.ASSET = transaction.attachment.cancelledOrderAsset ? (transaction.attachment.cancelledOrderAsset == $currency ? transaction.attachment.asset : transaction.attachment.currency) : '';
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            }
            else if (type == 4 && subType == 0) {
            }
            else if (type == 2 && subType == 0) {
                if (transaction.transaction == $currency) {
                    entry.AMOUNT = utils.formatQNT(transaction.attachment.quantity, 8);
                }
            }
            return entry;
        }
        function tradeToHistory($currency, trade) {
            var entry = {};
            entry.timestamp = trade.timestamp;
            entry.ID = trade.askOrder + "." + trade.bidOrder;
            entry.TYPE = 'Trade';
            entry.TIME = dateFormat(utils.timestampToDate(trade.timestamp), format);
            entry.ACCOUNT = trade.seller == account ? trade.buyer : trade.seller;
            entry.FEE = "0";
            entry.MESSAGE = '';
            entry.PRICE = '';
            entry.TOTAL = '';
            entry.ASSET = $currency;
            entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            if (trade.seller == account && trade.buyer == account) {
                entry.AMOUNT = '0';
            }
            else {
                var total = utils.calculateTotalOrderPriceQNT(trade.quantity, trade.price);
                entry.PRICE = utils.formatQNT(trade.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                if (trade.currency == $currency) {
                    if (trade.buyer == account) {
                        entry.AMOUNT = '-' + utils.formatQNT(total, 8);
                    }
                    else {
                        entry.AMOUNT = utils.formatQNT(total, 8);
                    }
                }
                else {
                    if (trade.buyer == account) {
                        entry.AMOUNT = utils.formatQNT(trade.quantity, 8);
                    }
                    else {
                        entry.AMOUNT = '-' + utils.formatQNT(trade.quantity, 8);
                    }
                }
            }
            return entry;
        }
        function getSymbol(id) {
            return id;
        }
        function encodeTxType(type, subType) {
            if (type == 2 && subType == 4)
                return 'Buy order';
            if (type == 2 && subType == 3)
                return 'Sell order';
            if (type == 1 && subType == 0)
                return 'Message';
            if (type == 0 && subType == 0)
                return 'Transfer';
            if (type == 2 && subType == 2)
                return 'Transfer';
            if (type == 2 && subType == 6)
                return 'Cancel buy';
            if (type == 2 && subType == 5)
                return 'Cancel sell';
            if (type == 4 && subType == 0)
                return 'Balance lease';
            if (type == 2 && subType == 0)
                return 'Asset Issuance';
            return 'Other';
        }
        function removeCommas(str) {
            return str ? str.replace(/,/g, '') : '';
        }
        function historyToCSV(entries) {
            var buffer = [];
            buffer.push("ID,TIME,TYPE,ACCOUNT,ASSET,ASSET_SYMBOL,AMOUNT,PRICE,TOTAL,FEE,MESSAGE");
            entries.reverse();
            entries.forEach(function (history) {
                buffer.push([
                    JSON.stringify(history.ID),
                    history.TIME,
                    history.TYPE,
                    history.ACCOUNT,
                    history.ASSET,
                    history.ASSET_SYMBOL,
                    history.AMOUNT,
                    history.PRICE,
                    history.TOTAL,
                    history.FEE,
                    JSON.stringify(history.MESSAGE)
                ].map(function (x) { return removeCommas(x); }).join(','));
            });
            return buffer.join('\n');
        }
        function download(content, fileName) {
            var blob = new Blob([content], { type: "text/plain;charset=utf-8" });
            saveAs(blob, fileName);
        }
        return dialogs.dialog({
            id: 'download',
            title: 'Download account history (CSV)',
            targetEvent: $event,
            okButton: false,
            cancelButton: true,
            locals: locals,
            style: "\n        .dialog-download md-progress-linear {\n          margin-top: 8px !important;\n          margin-bottom: 8px !important;\n        }\n        .dialog-download .md-button {\n          text-align: left !important;\n          margin-left: 0px !important;\n          padding-left: 0px !important;\n        }\n      ",
            template: "\n        <div layout=\"column\" class=\"dialog-download\">\n          <div layout=\"row\">Transactions ({{vm.transactions.array.length}})</div>\n          <md-progress-linear md-mode=\"determinate\" ng-value=\"vm.transactions.percent\"></md-progress-linear>\n          <div layout=\"row\">Trades ({{vm.trades.array.length}})</div>\n          <md-progress-linear md-mode=\"determinate\" ng-value=\"vm.trades.percent\"></md-progress-linear>\n          <!--<div>\n            <p>Total Transactions: {{vm.transactions.total}}</p>\n            <p>Count Transactions: {{vm.transactions.array.length}}</p>\n            <p>Percent: {{vm.transactions.percent}}</p>\n            <p>Total Trades: {{vm.trades.total}}</p>\n            <p>Count Trades: {{vm.trades.array.length}}</p>\n            <p>Percent: {{vm.trades.percent}}</p>\n          </div>-->\n          <div>\n            <div ng-repeat=\"currency in vm.currencies\">\n              <md-button ng-click=\"currency.download()\">Download {{currency.symbol}}.csv</md-button> View\n            </div>\n          </div>\n        </div>\n      "
        });
    }
    dialogs.download = download;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function etherTransactionReceipt(status, message) {
        return dialogs.dialog({
            id: 'EtherTransactionReceipt',
            title: "Transaction Receipt",
            cancelButton: false,
            okButton: true,
            locals: {
                status: status,
                message: message
            },
            template: "\n        <h2>{{vm.status}}</h2><br>\n        <label ng-if=\"vm.status==='Success'\">Transaction hash is: {{vm.message}}</label>\n        <label ng-if=\"vm.status==='Error'\">{{vm.message}}</label>\n      "
        });
    }
    dialogs.etherTransactionReceipt = etherTransactionReceipt;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function jsonDetails($event, jsonObject, title, fields, detailedObject, jsonText) {
        return dialogs.dialog({
            id: 'jsonDetails',
            title: title,
            targetEvent: $event,
            cancelButton: false,
            locals: {
                jsonObject: jsonObject,
                detailedObject: detailedObject || jsonObject,
                viewNum: (fields === null || fields === void 0 ? void 0 : fields.length) > 0 ? 0 : 1,
                fields: fields,
                jsonText: jsonText,
                toggle: function (num) {
                    this.viewNum = num;
                }
            },
            style: "\n         .details td {\n            padding: 8px;\n         }\n         .value {\n            opacity: 0.6;\n         }\n         .switcher-col {\n           margin-left: -40px;\n           margin-right: -20px;\n         }\n         .switcher {\n            opacity: 40%;\n            transform: rotate(-90deg);\n            font-size: smaller !important;    \n            width: 100px;\n            height: 93px;\n            min-width: 32px;\n            padding: 0;\n            margin: 0;\n         }\n         .on {\n            opacity: 100%;\n         }\n        ",
            template: "\n        <div layout=\"row\" flex>\n        \n          <div ng-if=\"vm.fields || vm.json\" layout=\"column\" class=\"switcher-col\">\n            <md-button ng-if=\"vm.fields\" ng-class=\"{'on': vm.viewNum == 0}\" ng-click=\"vm.toggle(0)\" class=\"switcher\">\n                Table view\n            </md-button>\n            <md-button ng-class=\"{'on': vm.viewNum == 1}\" ng-click=\"vm.toggle(1)\" class=\"switcher\">\n                JSON formatted\n            </md-button>\n            <md-button ng-if=\"vm.jsonText\" ng-class=\"{'on': vm.viewNum == 2}\" ng-click=\"vm.toggle(2)\" class=\"switcher\">\n                JSON text\n            </md-button>\n          </div>\n          \n          <div ng-if=\"vm.viewNum == 0\">\n            <table class=\"details\">\n                <tr ng-repeat=\"item in vm.fields\" class=\"row\">\n                    <td>{{item[1] || item[0]}}</td><td class=\"value\" ng-bind-html=\"vm.detailedObject[item[0]]\"></td>\n                </tr>\n            </table>\n          </div>\n          \n          <div layout=\"column\" flex ng-if=\"vm.viewNum == 1\">\n            <json-formatter json=\"vm.jsonObject\" open=\"1\" class=\"json-formatter-dark\"></json-formatter>\n          </div>\n          \n          <div layout=\"column\" flex ng-if=\"vm.viewNum == 2\">\n            <textarea readonly style=\"height: 100%\">{{vm.jsonObject | json}}</textarea>\n          </div>\n        </div>\n      "
        });
    }
    dialogs.jsonDetails = jsonDetails;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function prompt($event, title, description, defaultValue) {
        var $q = heat.$inject.get('$q');
        var deferred = $q.defer();
        var locals = {
            v: {
                value: defaultValue || ''
            },
            description: description || '',
        };
        dialogs.dialog({
            id: 'prompt',
            title: title,
            targetEvent: $event,
            template: "\n        <p>{{vm.description}}</p>\n        <md-input-container flex>\n          <input id=\"pwd\" type=\"password\" ng-model=\"vm.v.value\" autocomplete=\"off\" aria-label=\"Password\" auto-focus/><br>\n        </md-input-container>\n      ",
            locals: locals
        }).then(function () {
            deferred.resolve(locals.v.value);
        }, deferred.reject);
        return deferred.promise;
    }
    dialogs.prompt = prompt;
    function simplePrompt($event, title, description, fields) {
        var $q = heat.$inject.get('$q');
        var deferred = $q.defer();
        var locals = {
            description: description,
            fields: fields
        };
        dialogs.dialog({
            id: 'prompt',
            title: title,
            targetEvent: $event,
            template: "\n        <p>{{vm.description}}</p>\n        <md-list>\n          <md-list-item class=\"md-2-line\" ng-repeat=\"item in vm.fields\">\n            <md-input-container flex>\n              <label>{{item.label}}</label>\n              <!--<input id=\"1\" type=\"text\" ng-model=\"item.value\" autocomplete=\"off\" auto-focus/>-->\n              <input type=\"text\" ng-model=\"item.value\" autocomplete=\"off\"/>\n            </md-input-container>\n          </md-list-item>\n        </md-list>\n      ",
            locals: locals
        }).then(function () {
            deferred.resolve(locals.fields.map(function (v) { return v.value; }));
        }, deferred.reject);
        return deferred.promise;
    }
    dialogs.simplePrompt = simplePrompt;
    function alert($event, title, description) {
        var $q = heat.$inject.get('$q');
        var deferred = $q.defer();
        var locals = {
            description: description || '',
        };
        dialogs.dialog({
            id: 'alert',
            title: title,
            targetEvent: $event,
            template: "\n        <p>{{vm.description}}</p>\n      ",
            locals: locals
        }).then(function () {
            deferred.resolve();
        }, deferred.reject);
        return deferred.promise;
    }
    dialogs.alert = alert;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function showProgressMessage($event, message) {
        dialogs.dialog({
            id: 'shutdown',
            title: message,
            targetEvent: $event,
            okButton: false,
            template: "\n        <div layout=\"row\" layout-padding layout-align=center center\" flex>\n          <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n        </div>\n      "
        });
    }
    dialogs.showProgressMessage = showProgressMessage;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function textEditor(title, content, saveContentFunc, copyToClipboardFunc) {
        dialogs.dialog({
            id: 'textEditor',
            title: title,
            okButton: false,
            cancelButton: false,
            locals: {
                copyToClipboard: copyToClipboardFunc
                    ? function () {
                        copyToClipboardFunc(this.content);
                    }
                    : null,
                save: function () {
                    saveContentFunc(this.content);
                    dialogs.$mdDialog().hide();
                },
                close: function () {
                    dialogs.$mdDialog().hide();
                },
                content: content
            },
            template: "\n        <!--<md-input-container flex>-->\n        <p>\n          <textarea rows=\"20\" ng-model=\"vm.content\" id=\"content-textarea\"></textarea>\n        </p>\n        <!--</md-input-container>-->\n        <div layout=\"row\" layout-align=\"center center\" style=\"min-height: 25px\">\n          <md-button class=\"md-primary\" ng-if=\"vm.copyToClipboard\" ng-click=\"vm.copyToClipboard()\">Copy</md-button>\n          <md-button class=\"md-primary\" ng-click=\"vm.save()\">Save</md-button>\n          <md-button class=\"md-primary\" ng-click=\"vm.close()\">Close</md-button>\n        </div>\n      ",
            style: "\n        #content-textarea {\n            width: 100%;\n        }\n      "
        });
    }
    dialogs.textEditor = textEditor;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function transactionDetails($event, transaction) {
        var settings = heat.$inject.get('settings');
        dialogs.dialog({
            id: 'transactionDetails',
            title: 'Transaction details',
            targetEvent: $event,
            cancelButton: false,
            locals: {
                date: dateFormat(utils.timestampToDate(transaction.timestamp), settings.get(SettingsService.DATEFORMAT_DEFAULT)),
                amount: utils.commaFormat(utils.convertToQNTf(transaction.amount.toString())) + ' HEAT',
                source: transaction.sender,
                destination: transaction.recipient,
                transactionId: transaction.transaction,
                confirmed: transaction.confirmations ? 'YES' : 'NO'
            },
            style: "\n        .dialog-transaction-details td {\n          padding: 8px;\n        }\n      ",
            template: "\n        <div layout=\"column\" class=\"dialog-transaction-details\">\n          <table>\n            <tr><td>Time</td><td>{{vm.date}}</td></tr>\n            <tr><td>Amount</td><td>{{vm.amount}}</td></tr>\n            <tr><td>Source</td><td>{{vm.source}}</td></tr>\n            <tr><td>Destination</td><td>{{vm.destination}}</td></tr>\n            <tr><td>Transaction ID</td><td>{{vm.transactionId}}</td></tr>\n            <tr><td>Confirmed</td><td>{{vm.confirmed}}</td></tr>\n          </table>\n        </div>\n      "
        });
    }
    dialogs.transactionDetails = transactionDetails;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function withdraw(_to, _amount) {
        var lightwalletService = heat.$inject.get('lightwalletService');
        var user = heat.$inject.get('user');
        lightwalletService.sendEther(user.currency.address, _to, _amount);
        dialogs.$mdDialog().hide();
    }
    function withdrawEther($event) {
        return dialogs.dialog({
            id: 'withdrawEtherWallet',
            title: "Send Ether",
            targetEvent: $event,
            cancelButton: true,
            okButton: false,
            locals: {
                withdraw: withdraw,
                recipient: undefined,
                amount: undefined
            },
            style: "\n      .fee-button {\n        max-width:140px !important;\n      }\n    ",
            template: "\n        <md-input-container flex>\n          <input ng-model=\"vm.recipient\" name=\"recipient\" placeholder=\"Recipient address\" autocomplete=\"off\" required />\n        </md-input-container>\n        <md-input-container flex>\n          <input ng-model=\"vm.amount\" name=\"amount\" placeholder = \"Amount (in Wei)\" autocomplete=\"off\" required />\n        </md-input-container>\n        <md-button ng-click=\"0\" ng-disabled=\"true\" class=\"fee fee-button\">Fee: 0.000420 ETH</md-button>\n        <div layout=\"row\" layout-align=\"center center\" style=\"min-height: 25px\">\n          <md-button class=\"md-primary\" ng-disabled=\"!vm.amount || !vm.recipient\" ng-href=\"#/ethwallet\" ng-click=\"vm.withdraw(vm.recipient, vm.amount)\">Send</md-button>\n        </div>\n      "
        });
    }
    dialogs.withdrawEther = withdrawEther;
})(dialogs || (dialogs = {}));
var LoginComponent = (function () {
    function LoginComponent($scope, $q, user, $location, heat, localKeyStore, secretGenerator, clipboard, $mdToast, env, settings, walletFile, panel, lightwalletService) {
        this.$scope = $scope;
        this.$q = $q;
        this.user = user;
        this.$location = $location;
        this.heat = heat;
        this.localKeyStore = localKeyStore;
        this.secretGenerator = secretGenerator;
        this.clipboard = clipboard;
        this.$mdToast = $mdToast;
        this.env = env;
        this.settings = settings;
        this.walletFile = walletFile;
        this.panel = panel;
        this.lightwalletService = lightwalletService;
        this.bip44Compatible = false;
        this.page = '';
        this.localKeys = [];
        this.key = null;
        this.hasWhitespace = /^\s+|\s+$/gm;
        this.availableAPIServers = [];
        this.pageAddCalculatedAccountId = 'Enter secret phrase to see account id';
        this.pageAddWalletInvalid = false;
        this.pageSigninWrongPincode = false;
        this.pageCreateNameType = 'public';
        this.pageCreateUserName = '';
        this.pageCreateLoading = false;
        this.visiblePassphrase = true;
        try {
            this.isFileSaverSupported = !!new Blob;
        }
        catch (e) { }
        this.useExternalCaptcha = env.type != EnvType.BROWSER;
        this.generateNewSecretPhrase();
        this.initLocalKeys();
        if (this.localKeys.length != 0) {
            this.pageSigninAccount = this.localKeys[0].account;
            this.page = 'signin';
        }
        else {
            this.page = 'create';
        }
        new ClipboardJS('#copy-secret');
    }
    LoginComponent.prototype.initLocalKeys = function () {
        var _this = this;
        this.localKeys = this.localKeyStore.list().map(function (account) {
            return {
                name: _this.localKeyStore.getName(account),
                account: account
            };
        });
    };
    LoginComponent.prototype.apiServerChanged = function () {
        var parts = this.apiServer.split(":");
        this.settings.put(SettingsService.HEAT_PORT, parts.splice(-1, 1)[0]);
        this.settings.put(SettingsService.HEAT_HOST, parts.join(''));
    };
    LoginComponent.prototype.pageAddRemoveSecretPhraseHiddenChars = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pageAddSecretPhrase = _this.pageAddSecretPhrase.replace(/^\s+/, "").replace(/\s+$/, "");
            _this.pageAddSecretPhraseChanged();
        });
    };
    LoginComponent.prototype.pageAddLogin = function () {
        var _this = this;
        this.user.unlock(this.pageAddSecretPhrase, undefined, this.lightwalletService.validSeed(this.pageAddSecretPhrase)).then(function () {
            _this.$location.path("explorer-account/".concat(_this.user.account, "/transactions"));
        });
    };
    LoginComponent.prototype.pageAddSecretPhraseChanged = function () {
        var _this = this;
        this.pageAddPublicKey = heat.crypto.secretPhraseToPublicKey(this.pageAddSecretPhrase);
        this.pageAddAccount = heat.crypto.getAccountIdFromPublicKey(this.pageAddPublicKey);
        this.pageAddSecretPhraseHasHiddenChars = this.hasWhitespace.test(this.pageAddSecretPhrase);
        this.bip44Compatible = this.lightwalletService.validSeed(this.pageAddSecretPhrase);
        this.$scope.$evalAsync(function () {
            _this.pageAddCalculatedAccountId = _this.pageAddAccount;
        });
    };
    LoginComponent.prototype.pageAddAddSecretPhrase = function () {
        var _this = this;
        var key = {
            account: this.pageAddAccount,
            secretPhrase: this.pageAddSecretPhrase,
            pincode: this.pageAddPincode,
            name: ''
        };
        this.localKeyStore.put(key);
        this.user.unlock(this.pageAddSecretPhrase, key, this.lightwalletService.validSeed(this.pageAddSecretPhrase)).then(function () {
            _this.$location.path("explorer-account/".concat(_this.user.account, "/transactions"));
        });
    };
    LoginComponent.prototype.pageAddFileInputChange = function (files) {
        var _this = this;
        if (files && files[0]) {
            var reader_1 = new FileReader();
            reader_1.onload = function () {
                _this.$scope.$evalAsync(function () {
                    _this.pageAddWalletInvalid = true;
                    var fileContents = reader_1.result;
                    if (typeof fileContents === "string") {
                        var data = _this.walletFile.parseJSON(fileContents);
                        if (data && data["heatwallet-raw-data"]) {
                            var resultMessage = _this.walletFile.importRawData(data);
                            _this.$mdToast.show(_this.$mdToast.simple().textContent(resultMessage + ".   The app will now restart...").hideDelay(7000));
                            setTimeout(function () { return window.location.reload(); }, 3000);
                        }
                        else {
                            _this.pageAddWallet = _this.walletFile.createFromText(data);
                        }
                    }
                    if (_this.pageAddWallet) {
                        _this.pageAddWalletInvalid = false;
                    }
                });
            };
            reader_1.readAsText(files[0]);
        }
    };
    LoginComponent.prototype.pageAddWalletImportContinue = function () {
        var _this = this;
        var addedKeys = this.localKeyStore.import(this.pageAddWallet);
        this.initLocalKeys();
        var message = "Imported ".concat(addedKeys.length, " keys into this device");
        this.$mdToast.show(this.$mdToast.simple().textContent(message).hideDelay(5000));
        this.$scope.$evalAsync(function () {
            _this.page = '';
        });
    };
    LoginComponent.prototype.pageSinginLogin = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pageSigninWrongPincode = false;
            var key = _this.localKeyStore.load(_this.pageSigninAccount, _this.pageSigninPincode);
            if (key) {
                _this.user.unlock(key.secretPhrase, key, _this.lightwalletService.validSeed(key.secretPhrase)).then(function () {
                    _this.$location.path("explorer-account/".concat(_this.user.account, "/transactions"));
                });
            }
            else {
                _this.pageSigninWrongPincode = true;
            }
        });
    };
    LoginComponent.prototype.createAccount = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pageCreateLoading = true;
            _this.pageCreateError = null;
        });
        var isprivate = this.pageCreateNameType != 'public';
        var fullNameUTF8 = this.pageCreateUserName.trim();
        var nameHashStr = heat.crypto.fullNameToHash(fullNameUTF8);
        var publicKey = this.pageCreatePublicKey;
        var input = isprivate ?
            converters.stringToHexString(nameHashStr + this.pageCreateAccount) :
            converters.stringToHexString(fullNameUTF8 + nameHashStr + this.pageCreateAccount);
        heat.crypto.SHA256.init();
        heat.crypto.SHA256.update(converters.hexStringToByteArray(input));
        var message = converters.byteArrayToHexString(heat.crypto.SHA256.getBytes());
        var signatureArg = heat.crypto.signBytes(message, converters.stringToHexString(this.pageCreateSecretPhrase));
        if (!heat.crypto.verifyBytes(signatureArg, message, publicKey)) {
            throw new Error("Cant verify own signature");
        }
        this.heat.api.registerAccountName(this.pageCreatePublicKey, this.pageCreateRecaptchaResponse, fullNameUTF8, isprivate, signatureArg).then(function (transaction) {
            _this.$scope.$evalAsync(function () {
                _this.pageCreateLoading = false;
                _this.page = 'createSuccess';
            });
        }, function (error) {
            _this.$scope.$evalAsync(function () {
                _this.pageCreateLoading = false;
                _this.pageCreateError = error.description;
            });
        });
    };
    LoginComponent.prototype.isValidPincode = function (pincode) {
        if (!pincode || pincode.trim().length == 0)
            return false;
        return /^[a-zA-Z0-9_.-]{4,15}$/.test(pincode);
    };
    LoginComponent.prototype.generateNewSecretPhrase = function () {
        var _this = this;
        this.secretGenerator.generate('en').then(function (secretPhrase) {
            _this.$scope.$evalAsync(function () {
                _this.pageCreateSecretPhrase = secretPhrase;
                _this.pageCreatePublicKey = heat.crypto.secretPhraseToPublicKey(secretPhrase);
                _this.pageCreateAccount = heat.crypto.getAccountIdFromPublicKey(_this.pageCreatePublicKey);
                _this.bip44Compatible = _this.lightwalletService.validSeed(secretPhrase);
            });
        });
    };
    LoginComponent.prototype.printPassphrase = function () {
        var html = '<html><head>' +
            '<style type="text/css">html{font-family:GillSans,Calibri,Trebuchet,sans-serif;}</style>' +
            '</head><body>' + this.templateHTML() + '</body></html>';
        var popup = window.open("data:text/html;base64,".concat(btoa(html)), '_blank', 'toolbar=0,location=0,menubar=0');
        popup.print();
        popup.close();
    };
    LoginComponent.prototype.savePassphrase = function () {
        var blob = new Blob([this.templateText()], { type: "text/plain;charset=utf-8" });
        saveAs(blob, "heatledger-".concat(this.pageCreateUserName, "-").concat(this.pageCreateAccount, ".txt"));
    };
    LoginComponent.prototype.showPassphrase = function () {
        this.panel.show("\n      <div layout=\"column\" flex class=\"toolbar-copy-passphrase\">\n        <md-input-container flex>\n          <textarea rows=\"3\" flex ng-bind=\"vm.secretPhrase\" readonly ng-trim=\"false\"></textarea>\n          <div>Public key:</div>\n          <div>{{vm.publicKey}}</div>\n        </md-input-container>\n      </div>\n    ", {
            secretPhrase: this.pageCreateSecretPhrase,
            publicKey: this.pageCreatePublicKey
        });
    };
    LoginComponent.prototype.templateText = function () {
        return [
            'When stored the passphrase in this document will forever give you access to your HEAT funds.',
            '',
            "Account: ".concat(this.pageCreateUserName, " (").concat(this.pageCreateAccount, ")"),
            '',
            'Passphrase:',
            this.pageCreateSecretPhrase,
            '',
            "Publickey:",
            this.pageCreatePublicKey,
            '',
            'https://heatwallet.com'
        ].join('\r\n');
    };
    LoginComponent.prototype.templateHTML = function () {
        return [
            '<h1>HEAT Paper Wallet</h1>',
            '',
            'When stored the passphrase in this document will forever give you access to your HEAT funds.',
            '',
            "Paper wallet for <b>".concat(this.pageCreateUserName, "</b> (").concat(this.pageCreateAccount, ")"),
            '',
            'Passphrase:',
            "<u>".concat(this.pageCreateSecretPhrase, "</u>"),
            '',
            "Publickey:",
            this.pageCreatePublicKey,
            '',
            '<a href="https://heatwallet.com" target="_blank" rel="noopener noreferrer">https://heatwallet.com</a>'
        ].join('<br>');
    };
    LoginComponent.prototype.createLocalAccount = function () {
        var _this = this;
        var key = {
            account: this.pageCreateAccount,
            secretPhrase: this.pageCreateSecretPhrase,
            pincode: this.pageCreatePincode,
            name: this.pageCreateUserName
        };
        this.localKeyStore.put(key);
        this.user.unlock(this.pageCreateSecretPhrase, key, this.lightwalletService.validSeed(this.pageCreateSecretPhrase)).then(function () {
            _this.$location.path('new');
        });
    };
    LoginComponent.prototype.doChallenge = function () {
        var _this = this;
        this.showChallenge().then(function (response) {
            _this.$scope.$evalAsync(function () {
                _this.pageCreateRecaptchaResponse = response;
            });
        });
    };
    LoginComponent.prototype.showChallenge = function () {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.pageCreateRecaptchaWindow)) {
            this.pageCreateRecaptchaWindow.close();
            this.pageCreateRecaptchaWindow = null;
        }
        var url = this.settings.get(SettingsService.CAPTCHA_POPUP);
        this.pageCreateRecaptchaWindow = window.open(url, "New Window", "width=600,height=600,resizable=1,modal=1");
        var resolved = false;
        window.addEventListener("message", function (event) {
            try {
                var data = JSON.parse(event.data);
                switch (data.messageType) {
                    case "token": {
                        if (angular.isString(data.message.response)) {
                            resolved = true;
                            deferred.resolve(data.message.response);
                            _this.pageCreateRecaptchaWindow.close();
                        }
                        break;
                    }
                    case "beforeunload": {
                        if (!resolved) {
                            resolved = true;
                            deferred.resolve(null);
                        }
                    }
                }
            }
            catch (e) {
                console.log('Postmessage parse error', e);
            }
        }, false);
        return deferred.promise;
    };
    LoginComponent = __decorate([
        RouteConfig('/login'),
        Component({
            selector: 'login',
            template: "\n    <div layout=\"column\" flex layout-align=\"start center\">\n      <div layout=\"column\" layout-padding class=\"outer-container\">\n        <div layout=\"column\" layout-align=\"start center\" layout-padding>\n          <img src=\"assets/heatwallet.png\" class=\"wallet\">\n        </div>\n        <div layout=\"column\" flex>\n\n          <!-- SIGNIN, CREATE & ADD buttons -->\n          <div layout=\"column\" flex ng-if=\"!vm.page\">\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='signin'\" aria-label=\"Sign in\" ng-show=\"vm.localKeys.length\">\n                <md-tooltip md-direction=\"bottom\">Sign in with your Password (or Pin Code)</md-tooltip>\n                Sign in\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='create';vm.generateNewSecretPhrase()\" aria-label=\"Create\">\n                <md-tooltip md-direction=\"bottom\">Create a new account</md-tooltip>\n                Create\n              </md-button>\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.page='add'\" aria-label=\"Add\">\n                <md-tooltip md-direction=\"bottom\">Add existing account</md-tooltip>\n                Add\n              </md-button>\n            </div>\n          </div>\n\n          <!-- SIGNIN page (dropdown shows keys in wallet, must enter pin) -->\n          <div layout=\"column\" flex ng-if=\"vm.page=='signin'\">\n            <div layout=\"column\" flex>\n              <md-input-container>\n                <label>Account</label>\n                <md-select ng-model=\"vm.pageSigninAccount\" ng-change=\"vm.pageSigninPincode=null;\">\n                  <md-option ng-repeat=\"key in vm.localKeys\" value=\"{{key.account}}\">{{key.name||key.account}}</md-option>\n                </md-select>\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-input-container flex ng-show=\"vm.pageSigninAccount\">\n                <label>Password (or Pin Code)</label>\n                <input type=\"password\" ng-model=\"vm.pageSigninPincode\" required name=\"pincode\" maxlength=\"64\">\n              </md-input-container>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\" ng-show=\"vm.pageSigninWrongPincode\">\n              <b>sorry, buts that the wrong pincode</b>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page=''\" aria-label=\"Back\">Options</md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.pageSinginLogin()\"\n                ng-disabled=\"!vm.pageSigninPincode||!vm.pageSigninAccount\" aria-label=\"Continue in\">Sign in</md-button>\n            </div>\n          </div>\n\n          <!-- CREATE page (0) -->\n          <div layout=\"column\" flex ng-if=\"vm.page=='create'\">\n            <div layout=\"row\" flex layout-align=\"center center\">\n              <md-input-container flex>\n                <label>User name</label>\n                <input ng-model=\"vm.pageCreateUserName\" required name=\"username\" maxlength=\"100\" input-append=\"@heatwallet.com\">\n              </md-input-container>\n              <md-input-container flex style=\"max-width:120px !important\">\n                <md-icon md-font-set=\"regular-font\">@heatwallet.com</md-icon>\n                <input style=\"visibility: hidden;\">\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <label>Secret phrase</label>\n                <textarea rows=\"2\" flex ng-model=\"vm.pageCreateSecretPhrase\" readonly ng-trim=\"false\" id=\"create-new-textarea\"></textarea>\n                <!--copy to clipboard using clipboard.js, see https://www.npmjs.com/package/clipboard-->\n                <md-icon id=\"copy-secret\" data-clipboard-target=\"#create-new-textarea\" md-font-library=\"material-icons\" class=\"clickable-icon\">\n                  <md-tooltip md-direction=\"right\">Copy to clipboard</md-tooltip>content_copy\n                </md-icon>\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <label>Password (or Pin Code) (required min length 4)</label>\n                <input type=\"password\" ng-model=\"vm.pageCreatePincode\" required name=\"pincode\" maxlength=\"64\"\n                    ng-pattern=\"/^[a-zA-Z0-9_.-]{4,15}$/\">\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-radio-group ng-model=\"vm.pageCreateNameType\">\n                <md-radio-button value=\"public\" class=\"md-primary\">\n                  Publicly searchable email account id\n                </md-radio-button>\n                <md-radio-button value=\"private\" class=\"md-primary\">\n                  Private email account id (sender must know it)\n                </md-radio-button>\n              </md-radio-group>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page=''\" aria-label=\"Back\">Options</md-button>\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.generateNewSecretPhrase()\" aria-label=\"Other\">\n                Renew pass\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='create1'\"\n                ng-disabled=\"!vm.pageCreateUserName || !vm.pageCreateSecretPhrase || !vm.isValidPincode(vm.pageCreatePincode)\"\n                aria-label=\"Continue\">Continue</md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <br>\n              <span class=\"account-preview\">{{vm.pageCreateAccount}}</span>\n              <br>\n              Public key\n              <br>\n              <span class=\"account-preview\">{{vm.pageCreatePublicKey}}</span>\n              <br>\n              <span>BIP44 compatible = <b>{{vm.bip44Compatible?'TRUE':'FALSE'}}</b></span>\n            </div>\n          </div>\n\n          <!-- CREATE page (1) -->\n          <div layout=\"column\" flex ng-if=\"vm.page.indexOf('create')!=-1\" ng-show=\"vm.page=='create1'\" layout-padding>\n            <div layout=\"column\" flex>\n              <p>Although we have absolutely nothing against robots, we still would like to know if you are one.</p>\n            </div>\n            <div layout=\"row\" flex layout-align=\"center center\">\n              <no-captcha ng-if=\"!vm.useExternalCaptcha\" g-recaptcha-response=\"vm.pageCreateRecaptchaResponse\" expired-callback=\"vm.recaptchaExpired()\"></no-captcha>\n              <md-button ng-if=\"vm.useExternalCaptcha\" ng-click=\"vm.doChallenge()\" class=\"md-raised md-primary\" ng-disabled=\"vm.pageCreateRecaptchaResponse\">Click here</md-button>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='create'\" aria-label=\"Back\">Back</md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.createAccount();vm.page='create2'\" ng-disabled=\"!vm.pageCreateRecaptchaResponse\"\n                aria-label=\"Continue\">Create Account</md-button>\n            </div>\n          </div>\n\n          <!-- CREATE page (2) -->\n          <div layout=\"column\" flex ng-if=\"vm.page.indexOf('create')!=-1\" ng-show=\"vm.page=='create2'\">\n            <div layout=\"column\" flex layout-padding ng-show=\"vm.pageCreateLoading\">\n              <div layout=\"row\" layout-align=\"space-around\">\n                <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n              </div>\n              <span>Creating your account, making it extra special for you.</span>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\" ng-show=\"vm.pageCreateError\">\n              <span>Something went wrong it seems</span>\n              <span>This is what we got back from our blockchain minions:</span>\n              <span><b>{{vm.pageCreateError}}</b></span>\n              <md-button class=\"md-raised md-primary\" ng-click=\"vm.page='create'\" aria-label=\"Back\">Try again</md-button>\n            </div>\n          </div>\n\n          <!-- CREATE page (3 - success page) -->\n          <div layout=\"column\" flex ng-show=\"vm.page=='createSuccess'\">\n            <div layout=\"column\" flex layout-align=\"start center\">\n              <h2>Congratulations, it worked!</h2>\n              <div>We advise you print or write down your HEAT secret passprase, if lost you will loose access to your HEAT.<br>\n              Please pick one or more methods to back up your passphrase listed below.</div>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button ng-click=\"vm.printPassphrase()\">\n                <md-icon md-font-library=\"material-icons\">print</md-icon>\n                &nbsp;Print\n              </md-button>\n              <md-button ng-click=\"vm.savePassphrase()\" ng-if=\"vm.isFileSaverSupported\">\n                <md-icon md-font-library=\"material-icons\">save</md-icon>\n                &nbsp;Save\n              </md-button>\n              <md-button ng-click=\"vm.showPassphrase()\">\n                <md-icon md-font-library=\"material-icons\">content_copy</md-icon>\n                &nbsp;Show\n              </md-button>\n              <md-button ng-click=\"vm.visiblePassphrase = !vm.visiblePassphrase\">\n                <md-icon md-font-library=\"material-icons\">arrow_drop_down_circle</md-icon>\n                &nbsp;{{vm.visiblePassphrase ? 'Hide' : 'Reveal'}}\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\" ng-show=\"vm.visiblePassphrase\">\n              <p>Passphrase for {{vm.pageCreateUserName}} ({{vm.pageCreateAccount}}):</p>\n              <p><code id=\"claim2-passphrase\">{{vm.pageCreateSecretPhrase}}</code></p>\n              <p>Public key:<br><code id=\"claim2-pubkey\">{{vm.pageCreatePublicKey}}</code></p>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-checkbox ng-model=\"vm.passphraseBackedUp\" aria-label=\"I have backed up my passphrase\">\n              I have safely backed up my passphrase\n              </md-checkbox>\n              <md-button class=\"md-raised md-primary\" ng-click=\"vm.createLocalAccount($event)\" ng-disabled=\"!vm.passphraseBackedUp\">Continue</md-button>\n            </div>\n          </div>\n\n          <!-- ADD page (choose add secret phrase or open wallet file) -->\n          <div layout=\"column\" flex ng-show=\"vm.page=='add'\">\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.page=''\" aria-label=\"Back\">\n                <md-tooltip md-direction=\"bottom\">Go back one page</md-tooltip>\n                Back\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='addSecret'\" aria-label=\"Add secret phrase\">\n                <md-tooltip md-direction=\"bottom\">Add single key through secret phrase</md-tooltip>\n                Secret Phrase\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='addWallet'\" aria-label=\"Open wallet file\">\n                <md-tooltip md-direction=\"bottom\">Load wallet file</md-tooltip>\n                Wallet File\n              </md-button>\n            </div>\n          </div>\n\n          <!-- ADD page (adds single secret phrase) -->\n          <div layout=\"column\" flex ng-show=\"vm.page=='addSecret'\">\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <label>Secret phrase</label>\n                <textarea rows=\"2\" flex ng-model=\"vm.pageAddSecretPhrase\" ng-trim=\"false\" ng-change=\"vm.pageAddSecretPhraseChanged()\"></textarea>\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <label>Password (or Pin Code) (required)</label>\n                <input type=\"password\" ng-model=\"vm.pageAddPincode\" required name=\"pincode\" maxlength=\"64\">\n              </md-input-container>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.page='add'\" aria-label=\"Back\">\n                <md-tooltip md-direction=\"bottom\">Go back one page</md-tooltip>\n                Back\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.pageAddAddSecretPhrase()\" ng-disabled=\"!vm.pageAddSecretPhrase||!vm.pageAddPincode\" aria-label=\"Add\">\n                <md-tooltip md-direction=\"bottom\">Add and encrypt this secretphrase to your device</md-tooltip>\n                Add\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.pageAddLogin()\" ng-disabled=\"!vm.pageAddSecretPhrase\" aria-label=\"Sign in\">\n                <md-tooltip md-direction=\"bottom\">Sign in without storing your secretphrase</md-tooltip>\n                Sign in\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <br>\n              <span class=\"account-preview\">{{vm.pageAddCalculatedAccountId}}</span>\n              <span ng-show=\"vm.pageAddSecretPhraseHasHiddenChars\" class=\"account-preview\">\n                Secret phrase has hidden characters!&nbsp;<a href=\"#\" ng-click=\"vm.pageAddRemoveSecretPhraseHiddenChars()\">remove</a>\n              </span>\n              <br>\n              <span>BIP44 compatible = <b>{{vm.bip44Compatible?'TRUE':'FALSE'}}</b></span>\n            </div>\n          </div>\n\n          <!-- ADD page (opens wallet file) -->\n          <div layout=\"column\" flex ng-show=\"vm.page=='addWallet'\">\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <input type=\"file\" onchange=\"angular.element(this).scope().vm.pageAddFileInputChange(this.files)\">\n              </md-input-container>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\" ng-show=\"vm.pageAddWalletInvalid\">\n              <p><b>Invalid wallet file</b></p>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.page='add'\" aria-label=\"Back\">\n                <md-tooltip md-direction=\"bottom\">Go back one page</md-tooltip>\n                Back\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.pageAddWalletImportContinue()\" ng-disabled=\"!vm.pageAddWallet\" aria-label=\"Continue\">\n                <md-tooltip md-direction=\"bottom\">Click to open wallet explorer</md-tooltip>\n                Continue\n              </md-button>\n            </div>\n          </div>\n\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'user', '$location', 'heat', 'localKeyStore', 'secretGenerator', 'clipboard', '$mdToast', 'env', 'settings', 'walletFile', 'panel', 'lightwalletService'),
        __metadata("design:paramtypes", [Object, Function, UserService, Object, HeatService,
            LocalKeyStoreService,
            SecretGeneratorService,
            ClipboardService, Object, EnvService,
            SettingsService,
            WalletFileService,
            PanelService,
            LightwalletService])
    ], LoginComponent);
    return LoginComponent;
}());
var NewComponent = (function () {
    function NewComponent($scope, $q, heat, user, $timeout) {
        this.$scope = $scope;
        this.$q = $q;
        this.heat = heat;
        this.user = user;
        this.$timeout = $timeout;
        this.activated = false;
        this.checkAgain();
    }
    NewComponent.prototype.isExistingAccount = function () {
        var deferred = this.$q.defer();
        this.heat.api.getAccountBalance(this.user.account, "0").then(function () {
            deferred.resolve(true);
        }).catch(function (error) {
            deferred.resolve(false);
        });
        return deferred.promise;
    };
    NewComponent.prototype.checkAgain = function () {
        var _this = this;
        this.isExistingAccount().then(function (activated) {
            if (activated) {
                _this.$scope.$evalAsync(function () {
                    _this.activated = true;
                });
            }
            else {
                _this.$timeout(2000, false).then(function () {
                    _this.checkAgain();
                });
            }
        });
    };
    NewComponent = __decorate([
        RouteConfig('/new'),
        Component({
            selector: 'new',
            styles: ["\n    new h2 {\n      font-size: 26px !important;\n    }\n    new .outer-container {\n      width: 100%;\n      max-width: 380px;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-align=\"start center\">\n      <div layout=\"column\" layout-padding class=\"outer-container\">\n        <div layout=\"column\" flex layout-align=\"start center\">\n          <h2>Howdy new user</h2>\n          <p>To see your new account, please click on the home button on the horizontal menu bar above. Your payments section is empty until you receive new payments.</p>\n        </div>\n        <div layout=\"column\" flex layout-align=\"start center\" ng-show=\"!vm.activated\">\n          <p>Your account gets activated (and messages become visible) once your account is registered on the blockchain,\n  this will happen in the next block which is to be expected in the next 30 seconds.</p>\n          <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n          <p><b>Registering account on blockchain, please wait</b></p>\n        </div>\n        <div layout=\"column\" layout-align=\"space-around\" ng-show=\"vm.activated\">\n          <p><b>Your account is activated.</b></p>\n          <p>Check out your messages by clicking the messages button in the toolbar, there might be a message for you.</p>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'user', '$timeout'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            UserService, Function])
    ], NewComponent);
    return NewComponent;
}());
var heat;
(function (heat) {
    var bundle;
    (function (bundle_1) {
        var MAGIC = 2147483647;
        var KEY_STORE_SEED = MAGIC - 1;
        var ASSET_PROPERTIES_SEED = MAGIC - 2;
        function createKeyStore(bundle) {
            var buffer = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, true);
            buffer.writeInt32(KEY_STORE_SEED);
            var nameBytes = converters.stringToByteArray(bundle.name);
            buffer.writeShort(nameBytes.length);
            nameBytes.forEach(function (b) { buffer.writeByte(b); });
            var valueBytes = converters.stringToByteArray(bundle.value);
            valueBytes.forEach(function (b) { buffer.writeByte(b); });
            buffer.flip();
            return buffer.toHex();
        }
        bundle_1.createKeyStore = createKeyStore;
        function createAssetProperties(bundle) {
            var buffer = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, true);
            buffer.writeInt32(ASSET_PROPERTIES_SEED);
            buffer.writeInt64(Long.fromString(bundle.asset, true));
            buffer.writeInt32(bundle.protocol);
            var valueBytes = converters.stringToByteArray(bundle.value);
            buffer.writeShort(valueBytes.length);
            valueBytes.forEach(function (b) { buffer.writeByte(b); });
            buffer.flip();
            return buffer.toHex();
        }
        bundle_1.createAssetProperties = createAssetProperties;
    })(bundle = heat.bundle || (heat.bundle = {}));
})(heat || (heat = {}));
var HeatAPI = (function () {
    function HeatAPI(heat, user, $q) {
        this.heat = heat;
        this.user = user;
        this.$q = $q;
    }
    HeatAPI.prototype.registerAccountName = function (publicKey, captcha, name, isprivate, signature) {
        return this.heat.get("/register/now/".concat(publicKey, "/").concat(captcha, "/").concat(name, "/").concat(isprivate, "/").concat(signature), 'value');
    };
    HeatAPI.prototype.getBlockchainStatus = function () {
        return this.heat.get('/blockchain/status');
    };
    HeatAPI.prototype.getServerHealth = function (host, port) {
        if (!host)
            return this.heat.get('/tools/telemetry/health');
        return this.heat.getRaw(host, port, '/tools/telemetry/health', null, false);
    };
    HeatAPI.prototype.getBlocks = function (from, to) {
        return this.heat.get("/blockchain/blocks/".concat(from, "/").concat(to, "/null"));
    };
    HeatAPI.prototype.getBlock = function (numericId, includeTransactions) {
        if (includeTransactions === void 0) { includeTransactions = true; }
        return this.heat.get("/blockchain/block/".concat(numericId, "/").concat(includeTransactions));
    };
    HeatAPI.prototype.getBlockAtHeight = function (height, includeTransactions) {
        return this.heat.get("/blockchain/block/height/".concat(height, "/").concat(includeTransactions));
    };
    HeatAPI.prototype.getAccountBlocks = function (account, from, to) {
        return this.heat.get("/blockchain/blocks/account/".concat(account, "/").concat(from, "/").concat(to, "/null"));
    };
    HeatAPI.prototype.getAccountBlocksCount = function (account) {
        return this.heat.get("/blockchain/blocks/account/count/".concat(account), "count");
    };
    HeatAPI.prototype.getPublicKey = function (account, ignoreErrorResponse) {
        var deferred = this.$q.defer();
        this.heat.get("/account/publickey/".concat(account), "value", ignoreErrorResponse).then(function (publicKey) {
            if (!publicKey) {
                deferred.resolve(null);
                return;
            }
            var test = heat.crypto.getAccountIdFromPublicKey(publicKey);
            if (test != account) {
                console.log("Public key returned from server does not match account");
                deferred.reject();
            }
            else {
                deferred.resolve(publicKey);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    HeatAPI.prototype.getPublicKeyOrEmptyString = function (account) {
        var deferred = this.$q.defer();
        this.heat.get("/account/publickey/".concat(account), "value").then(function (publicKey) {
            var test = heat.crypto.getAccountIdFromPublicKey(publicKey);
            if (test != account) {
                console.log("Public key returned from server does not match account");
                deferred.reject();
            }
            else {
                deferred.resolve(publicKey);
            }
        }, function (error) {
            if ((error.errorDescription || "").toLowerCase() == "unknown publickey") {
                deferred.resolve("");
            }
            else {
                deferred.reject();
            }
        });
        return deferred.promise;
    };
    HeatAPI.prototype.createTransaction = function (input) {
        console.log("CreateTransaction", input);
        var arg = { value: JSON.stringify(input) };
        return this.heat.post('/tx/create', arg);
    };
    HeatAPI.prototype.broadcast = function (param) {
        var arg = {};
        if (angular.isDefined(param.transactionJSON)) {
            arg['transactionJSON'] = JSON.stringify(param.transactionJSON);
        }
        if (angular.isDefined(param.transactionBytes)) {
            arg['transactionBytes'] = param.transactionBytes;
        }
        return this.heat.post('/tx/broadcast', arg);
    };
    HeatAPI.prototype.getAllAssetProtocol1 = function (from, to) {
        return this.heat.get("/exchange/assets/protocol1/".concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAssetProtocol1 = function (symbol) {
        return this.heat.get("/exchange/asset/protocol1/".concat(symbol));
    };
    HeatAPI.prototype.getAsset = function (asset, propertiesAccount, propertiesProtocol) {
        return this.heat.get("/exchange/asset/properties/".concat(asset, "/").concat(propertiesAccount, "/").concat(propertiesProtocol));
    };
    HeatAPI.prototype.getAssetCertification = function (asset, certifierAccount) {
        return this.heat.get("/exchange/asset/certification/".concat(asset, "/").concat(certifierAccount));
    };
    HeatAPI.prototype.getAssets = function (propertiesAccount, propertiesProtocol, from, to) {
        return this.heat.get("/assets/".concat(propertiesAccount, "/").concat(propertiesProtocol, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAssetProperties = function (asset, propertiesAccount, propertiesProtocol) {
        return this.heat.get("/exchange/asset/properties/".concat(asset, "/").concat(propertiesAccount, "/").concat(propertiesProtocol));
    };
    HeatAPI.prototype.getAccountPairOrders = function (account, currency, asset, from, to) {
        return this.heat.get("/order/account/pair/".concat(account, "/").concat(currency, "/").concat(asset, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAccountPairOrdersCount = function (account, currency, asset) {
        return this.heat.get("/order/account/pair/count/".concat(account, "/").concat(currency, "/").concat(asset), "count");
    };
    HeatAPI.prototype.getAccountAllOrders = function (account, from, to) {
        return this.heat.get("/order/account/all/".concat(account, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAccountAllOrdersCount = function (account) {
        return this.heat.get("/order/account/all/count/".concat(account), "count");
    };
    HeatAPI.prototype.getAskOrders = function (currency, asset, from, to) {
        return this.heat.get("/order/pair/asks/".concat(currency, "/").concat(asset, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAskOrdersCount = function (currency, asset) {
        return this.heat.get("/order/pair/asks/count/".concat(currency, "/").concat(asset), "count");
    };
    HeatAPI.prototype.getBidOrders = function (currency, asset, from, to) {
        return this.heat.get("/order/pair/bids/".concat(currency, "/").concat(asset, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getBidOrdersCount = function (currency, asset) {
        return this.heat.get("/order/pair/bids/count/".concat(currency, "/").concat(asset), "count");
    };
    HeatAPI.prototype.getAllAskOrders = function (from, to) {
        return this.heat.get("/order/asks/".concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAllBidOrders = function (from, to) {
        return this.heat.get("/order/bids/".concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAccountAskOrders = function (account, currency, asset, from, to) {
        return this.heat.get("/order/account/pair/asks/".concat(account, "/").concat(currency, "/").concat(asset, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAccountBidOrders = function (account, currency, asset, from, to) {
        return this.heat.get("/order/account/pair/bids/".concat(account, "/").concat(currency, "/").concat(asset, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getTrades = function (currency, asset, from, to) {
        return this.heat.get("/trade/".concat(currency, "/").concat(asset, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getTradesCount = function (currency, asset) {
        return this.heat.get("/trade/count/".concat(currency, "/").concat(asset), "count");
    };
    HeatAPI.prototype.getAllTrades = function (from, to) {
        return this.heat.get("/trade/all/".concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAllAccountTrades = function (account, propertiesAccount, propertiesProtocol, from, to) {
        return this.heat.get("/trade/account/".concat(account, "/").concat(propertiesAccount, "/").concat(propertiesProtocol, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAllAccountTradesCount = function (account) {
        return this.heat.get("/trade/account/count/".concat(account), "count");
    };
    HeatAPI.prototype.getAccountTrades = function (account, currency, asset, from, to) {
        return this.heat.get("/trade/account/pair/".concat(account, "/").concat(currency, "/").concat(asset, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getAccountTradesCount = function (account, currency, asset) {
        return this.heat.get("/trade/account/pair/count/".concat(account, "/").concat(currency, "/").concat(asset), "count");
    };
    HeatAPI.prototype.getAccountBalance = function (account, asset) {
        return this.heat.get("/account/balance/".concat(account, "/").concat(asset));
    };
    HeatAPI.prototype.getAccountBalanceVirtual = function (account, asset, propertiesAccount, propertiesProtocol) {
        return this.heat.get("/account/balance/virtual/".concat(account, "/").concat(asset, "/").concat(propertiesAccount, "/").concat(propertiesProtocol));
    };
    HeatAPI.prototype.getMarketsAll = function (sort, asc, propertiesAccountId, propertiesProtocol, from, to) {
        return this.heat.get("/exchange/markets/all/".concat(sort, "/").concat(asc, "/").concat(propertiesAccountId, "/").concat(propertiesProtocol, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getMarkets = function (currency, sort, asc, propertiesAccountId, propertiesProtocol, from, to) {
        return this.heat.get("/exchange/markets/".concat(currency, "/").concat(sort, "/").concat(asc, "/").concat(propertiesAccountId, "/").concat(propertiesProtocol, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getMarket = function (currency, asset, propertiesAccountId, propertiesProtocol) {
        return this.heat.get("/exchange/market/".concat(currency, "/").concat(asset, "/").concat(propertiesAccountId, "/").concat(propertiesProtocol));
    };
    HeatAPI.prototype.getAccountBalances = function (account, propertiesAccount, propertiesProtocol, from, to) {
        return this.heat.get("/account/balances/".concat(account, "/").concat(propertiesAccount, "/").concat(propertiesProtocol, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getPayments = function (account, currency, sort, asc, from, to) {
        return this.heat.get("/account/payments/".concat(account, "/").concat(currency, "/").concat(sort, "/").concat(asc, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getPaymentsCount = function (account, currency) {
        return this.heat.get("/account/payments/count/".concat(account, "/").concat(currency), "count");
    };
    HeatAPI.prototype.getMessagingContactMessagesCount = function (accountA, accountB) {
        return this.heat.get("/messages/contact/count/".concat(accountA, "/").concat(accountB), "count");
    };
    HeatAPI.prototype.getMessagingContactMessages = function (accountA, accountB, from, to) {
        return this.heat.get("/messages/contact/".concat(accountA, "/").concat(accountB, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getMessagingContactMessagesByTimestampRange = function (accountA, accountB, fromTimestamp, toTimestamp) {
        return this.heat.get("/messages/contacttimestamprange/".concat(accountA, "/").concat(accountB, "/").concat(fromTimestamp, "/").concat(toTimestamp));
    };
    HeatAPI.prototype.getMessagingContacts = function (account, from, to) {
        return this.heat.get("/messages/latest/".concat(account, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getOHLCChartData = function (currency, asset, window) {
        return this.heat.get("/exchange/chartdata/".concat(currency, "/").concat(asset, "/").concat(window));
    };
    HeatAPI.prototype.getMiningInfo = function (secretPhrase) {
        return this.heat.post('/mining/info?api_key=secret', { secretPhrase: secretPhrase }, false, null, true);
    };
    HeatAPI.prototype.startMining = function (secretPhrase) {
        return this.heat.post('/mining/start?api_key=secret', { secretPhrase: secretPhrase }, false, null, true);
    };
    HeatAPI.prototype.stopMining = function (secretPhrase) {
        return this.heat.post('/mining/stop?api_key=secret', { secretPhrase: secretPhrase }, false, null, true);
    };
    HeatAPI.prototype.getAccountByNumericId = function (numericId, ignoreErrorResponse) {
        return this.heat.get("/account/find/".concat(numericId), null, ignoreErrorResponse);
    };
    HeatAPI.prototype.findAccountByName = function (name, ignoreErrorResponse) {
        return this.heat.get("/account/find/name/".concat(name), null, ignoreErrorResponse);
    };
    HeatAPI.prototype.getTransaction = function (transaction) {
        return this.heat.get("/blockchain/transaction/".concat(transaction));
    };
    HeatAPI.prototype.getTransactionsForAccount = function (account, from, to) {
        return this.heat.get("/blockchain/transactions/account/".concat(account, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getTransactionsForAccountCount = function (account) {
        return this.heat.get("/blockchain/transactions/account/count/".concat(account), "count");
    };
    HeatAPI.prototype.getTransactionsForBlock = function (block, from, to) {
        return this.heat.get("/blockchain/transactions/block/".concat(block, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getTransactionsForBlockCount = function (block) {
        return this.heat.get("/blockchain/transactions/block/count/".concat(block), "count");
    };
    HeatAPI.prototype.getTransactionsFromTo = function (sender, recipient, from, to) {
        return this.heat.get("/blockchain/transactions/list/".concat(sender, "/").concat(recipient, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getTransactionsForAll = function (from, to) {
        return this.heat.get("/blockchain/transactions/all/".concat(from, "/").concat(to));
    };
    HeatAPI.prototype.getTransactionsForAllCount = function () {
        return this.heat.get("/blockchain/transactions/all/count", "count");
    };
    HeatAPI.prototype.searchAccounts = function (query, from, to) {
        return this.heat.get("/search/accounts/".concat(query, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.searchAccountsCount = function (query) {
        return this.heat.get("/search/accounts/count/".concat(query), "count");
    };
    HeatAPI.prototype.searchPublicNames = function (query, from, to, ignoreErrorResponse) {
        return this.heat.get("/account/search/0/".concat(query, "/").concat(from, "/").concat(to), null, ignoreErrorResponse);
    };
    HeatAPI.prototype.rewardsAccount = function (account) {
        return this.heat.get("/mining/rewards/account/".concat(account));
    };
    HeatAPI.prototype.rewardsList = function (from, to) {
        return this.heat.get("/mining/rewards/list/".concat(from, "/").concat(to));
    };
    HeatAPI.prototype.rewardsListCount = function () {
        return this.heat.get('/mining/rewards/list/count', 'count');
    };
    HeatAPI.prototype.getKeystoreEntryCountByAccount = function (account) {
        return this.heat.get("/keystore/count/".concat(account), 'count');
    };
    HeatAPI.prototype.getKeystoreAccountEntry = function (account, key) {
        return this.heat.get("/keystore/get/".concat(account, "/").concat(key));
    };
    HeatAPI.prototype.getKeystoreAccountEntryExt = function (account, keys) {
        return this.heat.get("/keystore/getExt/".concat(account, "/").concat(keys));
    };
    HeatAPI.prototype.listKeystoreAccountEntries = function (account, from, to) {
        return this.heat.get("/keystore/list/".concat(account, "/").concat(from, "/").concat(to));
    };
    HeatAPI.prototype.saveKeystoreEntry = function (key, value, secretPhrase) {
        return this.heat.post("/keystore/put", { key: key, value: value, fee: 1000000, deadline: 1440, secretPhrase: secretPhrase });
    };
    HeatAPI.prototype.listMasternodes = function () {
        return this.heat.get("/account/internetaddress/list");
    };
    HeatAPI.prototype.baseTimestamp = function () {
        return this.heat.get('/blockchain/basetimestamp');
    };
    HeatAPI.prototype.uploadFile = function (fileName, arrayBuffer) {
        return this.heat.post('/messaging/file/upload', {
            fileName: fileName,
            arrayBuffer: arrayBuffer
        }, undefined, undefined, undefined, true, this.heat.settings.get(SettingsService.HEAT_MESSAGING));
    };
    HeatAPI.prototype.downloadFile = function (fileName) {
        return this.heat.get("/messaging/file/download/".concat(fileName), undefined, undefined, true, this.heat.settings.get(SettingsService.HEAT_MESSAGING));
    };
    HeatAPI.fee = {
        standard: utils.convertToQNT('0.01'),
        assetIssue: utils.convertToQNT('500.00'),
        assetIssueMore: utils.convertToQNT('0.01'),
        whitelistAssetAccount: utils.convertToQNT('100.00'),
        assetAssignFee: utils.convertToQNT('0.1'),
        assetAssignExpiration: utils.convertToQNT('0.01'),
        whitelistMarket: utils.convertToQNT('10.00'),
        registerInternetAddressFee: utils.convertToQNT('100.00'),
        supervisoryAccountFee: utils.convertToQNT('0.01'),
        accountAssetLimitFee: utils.convertToQNT('0.01')
    };
    return HeatAPI;
}());
var ServerEngineError = (function () {
    function ServerEngineError(data) {
        this.data = data;
        if (angular.isObject(data)) {
            this.description = data['errorDescription'] || data['error'];
            this.code = data['errorCode'] || -1;
        }
        else {
            this.description = 'misc error';
            this.code = 99;
        }
    }
    return ServerEngineError;
}());
var InternalServerTimeoutError = (function (_super) {
    __extends(InternalServerTimeoutError, _super);
    function InternalServerTimeoutError() {
        return _super.call(this, { error: 'Internal timeout' }) || this;
    }
    return InternalServerTimeoutError;
}(ServerEngineError));
var HeatService = (function () {
    function HeatService($q, $http, settings, user, $timeout, $interval, env, $rootScope) {
        var _this = this;
        this.$q = $q;
        this.$http = $http;
        this.settings = settings;
        this.user = user;
        this.$timeout = $timeout;
        this.$interval = $interval;
        this.env = env;
        this.$rootScope = $rootScope;
        this.api = new HeatAPI(this, this.user, this.$q);
        this.subscriber = this.createSubscriber(this.settings.get(SettingsService.HEAT_WEBSOCKET));
        var initBaseTime = function () { return _this.api.baseTimestamp().then(function (basetimestamp) {
            utils.setBaseTimestamp(parseInt(basetimestamp));
        }); };
        this.settings.initialized.then(function (v) { return initBaseTime(); })
            .catch(function (reason) { return console.error(reason); });
        $rootScope.$on('HEAT_SERVER_LOCATION', function (event, nothing) {
            initBaseTime().catch(function (reason) { return console.error(reason); });
        });
        var refreshInterval = $interval(function () {
            if (utils.isBaseDate()) {
                $interval.cancel(refreshInterval);
            }
            else {
                initBaseTime().catch(function (reason) { return console.error(reason); });
            }
        }, 3 * 1000, 0, false);
    }
    HeatService.prototype.createSubscriber = function (url) {
        return new HeatSubscriber(url, this.$q, this.$timeout);
    };
    HeatService.prototype.resetSubscriber = function () {
        this.subscriber.reset(this.settings.get(SettingsService.HEAT_WEBSOCKET));
    };
    HeatService.prototype.switchToServer = function (connectionWay, serverDescriptor) {
        if (connectionWay)
            this.settings.setConnectionWay(connectionWay);
        if (serverDescriptor)
            this.settings.setCurrentServer(serverDescriptor);
        this.resetSubscriber();
        this.$rootScope.$emit('HEAT_SERVER_LOCATION', "nothing");
    };
    HeatService.prototype.getAuthData = function () {
        var timestamp = Date.now();
        var baseMessage = this.user.account + timestamp;
        var message = converters.stringToHexString(baseMessage);
        var secret = converters.stringToHexString(this.user.secretPhrase);
        var signature = heat.crypto.signBytes(message, secret);
        return {
            auth: {
                accountRS: this.user.account,
                timestamp: timestamp,
                signature: signature,
                publicKey: this.user.publicKey
            }
        };
    };
    HeatService.prototype.get = function (route, returns, ignoreErrorResponse, isFile, hostPort) {
        if (ignoreErrorResponse === void 0) { ignoreErrorResponse = false; }
        return this.getRaw(hostPort ? hostPort.host : this.settings.get(SettingsService.HEAT_HOST), hostPort ? hostPort.port : this.settings.get(SettingsService.HEAT_PORT), route, returns, ignoreErrorResponse, isFile);
    };
    HeatService.prototype.getRaw = function (host, port, route, returns, ignoreErrorResponse, isFile) {
        var _this = this;
        route = "api/v1" + route;
        var deferred = this.$q.defer();
        if (this.env.type == EnvType.BROWSER) {
            var portStr = port ? ":".concat(port) : "";
            var config = void 0;
            if (isFile) {
                config = {
                    headers: { 'Content-Type': undefined },
                    transformResponse: [
                        function (data) {
                            return data;
                        }
                    ],
                    responseType: "arraybuffer"
                };
            }
            else {
                config = {
                    headers: { 'Content-Type': 'application/json' }
                };
            }
            this.browserHttpGet([host, portStr, '/', route].join(''), config, function (response) {
                _this.logResponse(route, null, response);
                var data = angular.isString(returns) ? response.data[returns] : response.data;
                deferred.resolve(data);
            }, function (response) {
                if (ignoreErrorResponse) {
                    deferred.resolve();
                }
                else {
                    _this.logErrorResponse(route, null, response);
                    deferred.reject(new ServerEngineError(isFile ? response : response.data));
                }
            });
        }
        else if (this.env.type == EnvType.NODEJS) {
            var isHttps = host.indexOf('https://') == 0;
            this.nodeHttpGet(isHttps, host.replace(/^(\w+:\/\/)/, ''), port, '/' + route, function (response) {
                _this.logResponse(route, null, response);
                var data = angular.isString(returns) ? response[returns] : response;
                deferred.resolve(data);
            }, function (response) {
                if (ignoreErrorResponse) {
                    deferred.resolve();
                }
                else {
                    _this.logErrorResponse(route, null, response);
                    var data = Object.assign(response, { host: host, port: port, route: route, response: response });
                    deferred.reject(new ServerEngineError(data));
                }
            }, isFile);
        }
        return deferred.promise;
    };
    HeatService.prototype.browserHttpGet = function (url, config, onSuccess, onFailure) {
        this.$http.get(url, config).then(function (response) {
            if (angular.isDefined(response.data.errorDescription)) {
                onFailure(response);
            }
            else {
                onSuccess(response);
            }
        }, function (response) { onFailure(response); });
    };
    HeatService.prototype.nodeHttpGet = function (isHttps, hostname, port, path, onSuccess, onFailure, isFile) {
        var options = {
            hostname: hostname, port: port, path: path, method: 'GET',
            headers: {
                'Content-Type': isFile ? 'multipart/form-data' : 'application/json'
            }
        };
        var http = require(isHttps ? 'https' : 'http');
        var req = http.request(options, function (res) {
            if (isFile) {
                if (res.statusCode == 200) {
                    var chunkArray_1 = [];
                    res.on('data', function (chunk) { return chunkArray_1.push(chunk); });
                    res.on('end', function () {
                        onSuccess(Buffer.concat(chunkArray_1));
                    });
                }
                else {
                    onFailure(res.statusMessage || res);
                }
            }
            else {
                res.setEncoding('utf8');
                var body_1 = [];
                res.on('data', function (chunk) { body_1.push(chunk); });
                res.on('end', function () {
                    var response;
                    var content = body_1.join('');
                    try {
                        response = JSON.parse(content);
                        if (angular.isDefined(response.errorDescription)) {
                            onFailure(response);
                        }
                        else {
                            onSuccess(response);
                        }
                    }
                    catch (e) {
                        console.error("response in not JSON parseable: \n" + content);
                        onFailure(content);
                    }
                });
            }
        });
        req.on('error', function (e) { onFailure(e); });
        req.end();
    };
    HeatService.prototype.post = function (route, request, withAuth, returns, localHostOnly, isFile, hostPort) {
        var host;
        var port;
        if (hostPort) {
            host = hostPort.host;
            port = hostPort.port;
        }
        else {
            host = localHostOnly ? this.settings.get(SettingsService.HEAT_HOST_LOCAL) : this.settings.get(SettingsService.HEAT_HOST);
            port = localHostOnly ? this.settings.get(SettingsService.HEAT_PORT_LOCAL) : this.settings.get(SettingsService.HEAT_PORT);
        }
        return this.postRaw(host, port, route, request, withAuth, returns, localHostOnly, isFile);
    };
    HeatService.prototype.postRaw = function (host, port, route, request, withAuth, returns, localHostOnly, isFile) {
        var _this = this;
        route = "api/v1" + route;
        var deferred = this.$q.defer();
        var req = request || {};
        if (withAuth) {
            req = angular.extend(req, this.getAuthData());
        }
        if (this.env.isBrowser()) {
            var portStr = port ? ":".concat(port) : "";
            var address = [host, portStr, '/', route].join('');
            if (localHostOnly) {
                if (address.indexOf('http://localhost') != 0) {
                    deferred.reject(new ServerEngineError({
                        errorDescription: "Operation allowed to localhost only! ".concat(address, " is not allowed"),
                        errorCode: 10
                    }));
                }
            }
            this.browserHttpPost(address, req, function (response) {
                _this.logResponse(route, request, response);
                var data = angular.isString(response)
                    ? response
                    : (angular.isString(returns) ? response.data[returns] : response.data);
                deferred.resolve(data);
            }, function (response) {
                _this.logErrorResponse(route, request, response);
                deferred.reject(new ServerEngineError(response.data));
            }, isFile);
        }
        else if (this.env.type == EnvType.NODEJS) {
            var address = host.replace(/^(\w+:\/\/)/, '');
            if (localHostOnly) {
                if (address.indexOf('localhost') != 0) {
                    deferred.reject(new ServerEngineError({
                        errorDescription: "Operation allowed to localhost only ".concat(address, " is not allowed"),
                        errorCode: 10
                    }));
                }
            }
            var isHttps = host.indexOf('https://') == 0;
            this.nodeHttpPost(isHttps, address, port, '/' + route, req, function (response) {
                _this.logResponse(route, request, response);
                var data = angular.isString(response)
                    ? response
                    : (angular.isString(returns) ? response.data[returns] : response.data);
                deferred.resolve(data);
            }, function (response) {
                _this.logErrorResponse(route, request, response);
                deferred.reject(new ServerEngineError(response.data));
            }, isFile);
        }
        return deferred.promise;
    };
    HeatService.prototype.browserHttpPost = function (url, request, onSuccess, onFailure, isFile) {
        var config;
        if (isFile) {
            var formData = new FormData();
            formData.append("fileName", request.fileName);
            formData.append("file", new Blob([request.arrayBuffer]));
            config = {
                method: 'POST',
                url: url,
                headers: { 'Content-Type': undefined },
                data: formData
            };
        }
        else {
            config = {
                method: 'POST',
                url: url,
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                data: request,
                transformRequest: function (obj) {
                    var str = [];
                    for (var p in obj) {
                        str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                    }
                    return str.join("&");
                }
            };
        }
        this.$http(config).then(function (response) {
            if (angular.isDefined(response.data.errorDescription)) {
                onFailure(response);
            }
            else {
                onSuccess(response);
            }
        }, function (response) { onFailure(response); });
    };
    HeatService.prototype.nodeHttpPost = function (isHttps, hostname, port, path, request, onSuccess, onFailure, isFile) {
        var http = require(isHttps ? 'https' : 'http');
        if (isFile) {
            var FormData_1 = require("form-data");
            var form = new FormData_1();
            form.append('fileName', request.fileName);
            form.append('file', Buffer.from(request.arrayBuffer));
            var req = http.request({
                hostname: hostname, port: port, path: path, method: 'POST',
                headers: form.getHeaders(),
            }, function (response) {
                if ((response === null || response === void 0 ? void 0 : response.statusCode) == 200) {
                    onSuccess(response.statusMessage);
                }
                else {
                    onFailure(response);
                }
            });
            req.on('error', function (e) { onFailure(e); });
            form.pipe(req);
        }
        else {
            var querystring = require('querystring');
            var body = querystring.stringify(request);
            var options = {
                hostname: hostname, port: port, path: path, method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    "Content-Length": body.length
                }
            };
            var req = http.request(options, function (res) {
                res.setEncoding('utf8');
                var respBody = [];
                res.on('data', function (chunk) { respBody.push(chunk); });
                res.on('end', function () {
                    var responseBody;
                    try {
                        responseBody = JSON.parse(respBody.join(''));
                    }
                    catch (e) {
                        console.error(e);
                        onFailure(res);
                    }
                    var response = { data: responseBody };
                    if (angular.isDefined(response.data.errorDescription)) {
                        onFailure(response);
                    }
                    else {
                        onSuccess(response);
                    }
                });
            });
            req.on('error', function (e) { onFailure(e); });
            req.write(body);
            req.end();
        }
    };
    HeatService.prototype.logResponse = function (route, request, response) {
        if (this.settings.get(SettingsService.LOG_HEAT_ALL)) {
            console.log("HEAT [".concat(route, "]"), {
                request: request,
                response: response
            });
        }
    };
    HeatService.prototype.logErrorResponse = function (route, request, response) {
        if (this.settings.get(SettingsService.LOG_HEAT_ERRORS)) {
            console.error("HEAT [".concat(route, "]"), {
                request: request,
                response: response
            });
        }
    };
    HeatService.prototype.mock = function (data) {
        var deferred = this.$q.defer();
        deferred.resolve(data);
        return deferred.promise;
    };
    HeatService.prototype.getHeatMessageContents = function (message) {
        try {
            if (message.messageIsEncrypted || message.messageIsEncryptedToSelf) {
                var byteArray = converters.hexStringToByteArray(message.messageBytes);
                var nonce = converters.byteArrayToHexString(byteArray.slice(0, 32));
                var data = converters.byteArrayToHexString(byteArray.slice(32));
                if (message.recipient == this.user.account || (message.recipient == '0' && message.sender == this.user.account)) {
                    return heat.crypto.decryptMessage(data, nonce, message.senderPublicKey, this.user.secretPhrase);
                }
                else if (message.sender == this.user.account) {
                    return heat.crypto.decryptMessage(data, nonce, message.recipientPublicKey, this.user.secretPhrase);
                }
            }
            else if (message.messageIsText) {
                return converters.hexStringToString(message.messageBytes);
            }
            else {
                return message.messageBytes ? '[BINARY] ' + message.messageBytes : '';
            }
        }
        catch (e) {
            console.log('Message parse exception', message, e);
            return '** could not parse message bytes **';
        }
    };
    HeatService = __decorate([
        Service('heat'),
        Inject('$q', '$http', 'settings', 'user', '$timeout', '$interval', 'env', '$rootScope'),
        __metadata("design:paramtypes", [Function, Function, SettingsService,
            UserService, Function, Function, EnvService, Object])
    ], HeatService);
    return HeatService;
}());
var HeatSubscriber = (function () {
    function HeatSubscriber(url, $q, $timeout) {
        this.url = url;
        this.$q = $q;
        this.$timeout = $timeout;
        this.RETRY_SYNC_DELAY = 2.5 * 1000;
        this.errRetryDelayCoef = 1;
        this.BLOCK_PUSHED = "1";
        this.BLOCK_POPPED = "2";
        this.BALANCE_CHANGED = "3";
        this.ORDER = "4";
        this.TRADE = "5";
        this.MESSAGE = "6";
        this.UNCONFIRMED_TRANSACTION = "7";
        this.MICROSERVICE = "8";
        this.PEER = "9";
        this.connectedSocketPromise = null;
        this.subscribeTopics = [];
        this.unsubscribeTopics = [];
        this.needReset = false;
    }
    HeatSubscriber.prototype.blockPushed = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.BLOCK_PUSHED, filter), callback, $scope);
    };
    HeatSubscriber.prototype.blockPopped = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.BLOCK_POPPED, filter), callback, $scope);
    };
    HeatSubscriber.prototype.balanceChanged = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.BALANCE_CHANGED, filter), callback, $scope);
    };
    HeatSubscriber.prototype.order = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.ORDER, filter), callback, $scope);
    };
    HeatSubscriber.prototype.trade = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.TRADE, filter), callback, $scope);
    };
    HeatSubscriber.prototype.message = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.MESSAGE, filter), callback, $scope);
    };
    HeatSubscriber.prototype.unconfirmedTransaction = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.UNCONFIRMED_TRANSACTION, filter), callback, $scope);
    };
    HeatSubscriber.prototype.microservice = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.MICROSERVICE, filter), callback, $scope);
    };
    HeatSubscriber.prototype.peer = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.PEER, filter), callback, $scope);
    };
    HeatSubscriber.prototype.reset = function (url) {
        this.url = url;
        this.needReset = true;
    };
    HeatSubscriber.prototype.subscribe = function (newTopic, callback, $scope) {
        var topic = this.findExistingOrAddNewTopic(newTopic);
        topic.addListener(callback);
        var unsubscribe = this.createUnsubscribeFunction(topic, callback);
        if (angular.isDefined($scope)) {
            $scope.$on('$destroy', function () { unsubscribe(); });
        }
        this.syncTopicSubscriptions();
        return unsubscribe;
    };
    HeatSubscriber.prototype.findExistingOrAddNewTopic = function (topic) {
        for (var i = 0; i < this.subscribeTopics.length; i++) {
            if (this.subscribeTopics[i].equals(topic)) {
                return this.subscribeTopics[i];
            }
        }
        this.subscribeTopics.push(topic);
        return topic;
    };
    HeatSubscriber.prototype.createUnsubscribeFunction = function (topic, callback) {
        var _this = this;
        return function () {
            topic.removeListener(callback);
            if (topic.isEmpty()) {
                _this.unsubscribeTopic(topic);
            }
        };
    };
    HeatSubscriber.prototype.unsubscribeTopic = function (topic) {
        this.subscribeTopics = this.subscribeTopics.filter(function (t) { return t !== topic; });
        this.unsubscribeTopics.push(topic);
        this.syncTopicSubscriptions();
    };
    HeatSubscriber.prototype.syncTopicSubscriptions = function () {
        var _this = this;
        this.getConnectedSocket().then(function (websocket) {
            _this.errRetryDelayCoef = 1;
            if (_this.needReset) {
                websocket.close(3001, "Heat subscribes reseted");
                _this.needReset = false;
                return;
            }
            _this.unsubscribeTopics.forEach(function (topic) {
                if (topic.isSubscribed()) {
                    _this.sendUnsubscribe(websocket, topic);
                }
            });
            _this.unsubscribeTopics = _this.unsubscribeTopics.filter(function (topic) { return !topic.isSubscribed(); });
            _this.subscribeTopics.forEach(function (topic) {
                if (!topic.isSubscribed()) {
                    _this.sendSubscribe(websocket, topic);
                }
            });
            if (_this.subscribeTopics.find(function (topic) { return !topic.isSubscribed(); })) {
                _this.$timeout(_this.RETRY_SYNC_DELAY).then(function () {
                    _this.syncTopicSubscriptions();
                });
            }
        }, function () {
            _this.errRetryDelayCoef = Math.min(10, ++_this.errRetryDelayCoef);
            _this.$timeout(_this.errRetryDelayCoef * _this.RETRY_SYNC_DELAY).then(function () {
                _this.syncTopicSubscriptions();
            });
        });
    };
    HeatSubscriber.prototype.getConnectedSocket = function () {
        if (this.connectedSocketPromise) {
            return this.connectedSocketPromise;
        }
        var deferred = this.$q.defer();
        var websocket = new WebSocket(this.url);
        this.hookupWebsocketEventListeners(websocket, deferred);
        return this.connectedSocketPromise = deferred.promise;
    };
    HeatSubscriber.prototype.hookupWebsocketEventListeners = function (websocket, deferred) {
        var _this = this;
        var onclose = function (event) {
            deferred.reject();
            _this.connectedSocketPromise = null;
            websocket.onclose = null;
            websocket.onopen = null;
            websocket.onerror = null;
            websocket.onmessage = null;
            _this.subscribeTopics.forEach(function (topic) { topic.setSubscribed(false); });
        };
        var onerror = onclose;
        var onopen = function (event) {
            deferred.resolve(websocket);
        };
        var onmessage = function (event) {
            try {
                _this.onMessageReceived(JSON.parse(event.data));
            }
            catch (e) {
                console.log("Websocket parse error", e);
            }
        };
        websocket.onclose = onclose;
        websocket.onopen = onopen;
        websocket.onerror = onerror;
        websocket.onmessage = onmessage;
    };
    HeatSubscriber.prototype.sendUnsubscribe = function (websocket, topic) {
        if (websocket.readyState == 1) {
            websocket.send(JSON.stringify(["unsubscribe", [[topic.topicId, topic.params]]]));
            topic.setSubscribed(false);
        }
    };
    HeatSubscriber.prototype.sendSubscribe = function (websocket, topic) {
        if (websocket.readyState == 1) {
            websocket.send(JSON.stringify(["subscribe", [[topic.topicId, topic.params]]]));
            topic.setSubscribed(true);
        }
    };
    HeatSubscriber.prototype.onMessageReceived = function (messageJson) {
        var _this = this;
        if (!angular.isArray(messageJson) || messageJson.length != 3) {
            console.log("Websocket invalid message", messageJson);
            return;
        }
        var topicAsStr = messageJson[0], details = messageJson[1], contents = messageJson[2];
        if (!angular.isString(topicAsStr) || !angular.isObject(details)) {
            console.log("Websocket invalid field", messageJson);
            return;
        }
        this.subscribeTopics.forEach(function (topic) {
            if (topic.topicId == topicAsStr && _this.topicMatchesDetails(topic, details)) {
                _this.invokeListeners(topic, contents);
            }
        });
    };
    HeatSubscriber.prototype.topicMatchesDetails = function (topic, details) {
        var filterKeys = Object.getOwnPropertyNames(topic.params);
        for (var i = 0, key = filterKeys[i]; i < filterKeys.length; i++) {
            if (topic.params[key] != details[key])
                return false;
        }
        return true;
    };
    HeatSubscriber.prototype.invokeListeners = function (topic, contents) {
        topic.listeners.forEach(function (listener) {
            try {
                listener(contents);
            }
            catch (e) {
                console.error(e);
            }
        });
    };
    return HeatSubscriber;
}());
var HeatSubscriberTopic = (function () {
    function HeatSubscriberTopic(topicId, params) {
        this.topicId = topicId;
        this.params = params;
        this.listeners = [];
        this.subscribed = false;
        if (!angular.isString(topicId))
            throw new Error("Topic must be a string");
        if (!angular.isObject(params))
            throw new Error("Params must be an object");
        var names = Object.getOwnPropertyNames(params);
        names.forEach(function (key) {
            if (!angular.isString(params[key]))
                throw new Error("Params property ".concat(key, " is not a string"));
        });
    }
    HeatSubscriberTopic.prototype.setSubscribed = function (subscribed) {
        this.subscribed = subscribed;
    };
    HeatSubscriberTopic.prototype.isSubscribed = function () {
        return this.subscribed;
    };
    HeatSubscriberTopic.prototype.addListener = function (callback) {
        if (this.listeners.find(function (cb) { return cb === callback; }))
            throw new Error("Duplicate listener");
        this.listeners.push(callback);
    };
    HeatSubscriberTopic.prototype.removeListener = function (callback) {
        this.listeners = this.listeners.filter(function (c) { return c !== callback; });
    };
    HeatSubscriberTopic.prototype.isEmpty = function () {
        return this.listeners.length == 0;
    };
    HeatSubscriberTopic.prototype.equals = function (other) {
        if (this.topicId != other.topicId)
            return false;
        return this.objectEquals(this.params, other.params);
    };
    HeatSubscriberTopic.prototype.objectEquals = function (a, b) {
        var namesA = Object.getOwnPropertyNames(a);
        var namesB = Object.getOwnPropertyNames(b);
        if (namesA.length != namesB.length)
            return false;
        for (var i = 0; i < namesA.length; i++) {
            var key = namesA[i];
            if (a[key] != b[key])
                return false;
        }
        return true;
    };
    return HeatSubscriberTopic;
}());
var ARDRCurrency = (function () {
    function ARDRCurrency(masterSecretPhrase, secretPhrase, address) {
        this.masterSecretPhrase = masterSecretPhrase;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'ARDR';
        this.homePath = "/ardor-account/".concat(this.address);
        this.pendingTransactions = heat.$inject.get('ardorPendingTransactions');
        this.ardorBlockExplorerService = heat.$inject.get('ardorBlockExplorerService');
        this.$rootScope = heat.$inject.get('$rootScope');
        this.$q = heat.$inject.get('$q');
    }
    ARDRCurrency.prototype.getBalance = function () {
        var deferred = this.$q.defer();
        this.ardorBlockExplorerService.getBalance(this.address).then(function (data) {
            deferred.resolve(new Big(utils.convertToQNTf(data)).toFixed(8));
        }, function (err) {
            deferred.reject();
        });
        return deferred.promise;
    };
    ARDRCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return;
    };
    ARDRCurrency.prototype.notifyBalanceChanged = function () {
    };
    ARDRCurrency.prototype.invokeSendDialog = function ($event) {
        var _this = this;
        this.sendArdr($event).then(function (data) {
            if (!data)
                return;
            var address = _this.address;
            var timestamp = new Date().getTime();
            _this.pendingTransactions.add(address, data.txId, timestamp, data.fullHash);
        }, function (err) {
            if (err) {
                dialogs.alert($event, 'Send ARDR Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
            }
        });
    };
    ARDRCurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    ARDRCurrency.prototype.sendArdr = function ($event) {
        function DialogController2($scope, $mdDialog) {
            this.cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            this.okButtonClick = function ($event) {
                var user = heat.$inject.get('user');
                var ardorBlockExplorerService = heat.$inject.get('ardorBlockExplorerService');
                var to = $scope['vm'].data.recipient;
                var amountNQT = utils.convertToNQT(String($scope['vm'].data.amountNQT));
                var feeNQT = utils.convertToNQT(String($scope['vm'].data.feeNQT));
                var recipientPublicKey;
                var requestParams;
                if ($scope['vm'].data.recipientPublicKey) {
                    recipientPublicKey = converters.hexStringToByteArray($scope['vm'].data.recipientPublicKey);
                }
                var userMessage = $scope['vm'].data.message;
                if (userMessage && userMessage != '' && recipientPublicKey) {
                    var options = {
                        "publicKey": recipientPublicKey
                    };
                    var encryptedNote = heat.crypto.encryptNote(userMessage, options, user.currency.secretPhrase);
                    requestParams = "requestType=sendMoney&secretPhrase=".concat(user.currency.secretPhrase, "&recipient=").concat(to, "&amountNQT=").concat(amountNQT, "&feeNQT=").concat(feeNQT, "&deadline=60&encryptedMessageData=").concat(encryptedNote.message, "&encryptedMessageNonce=").concat(encryptedNote.nonce, "&messageToEncryptIsText=true&encryptedMessageIsPrunable=true&chain=1");
                }
                else {
                    requestParams = "requestType=sendMoney&secretPhrase=".concat(user.currency.secretPhrase, "&recipient=").concat(to, "&amountNQT=").concat(amountNQT, "&feeNQT=").concat(feeNQT, "&deadline=60&chain=1");
                }
                $scope['vm'].disableOKBtn = true;
                ardorBlockExplorerService.sendTransactionWithSecret(requestParams).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        dialogs.alert(event, 'Success', "TxId: ".concat(data.txId));
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err);
                    });
                });
            };
            this.disableOKBtn = false;
            var defaultFee = '1.0';
            this.data = {
                amountNQT: '',
                recipient: '',
                recipientInfo: '',
                feeNQT: defaultFee,
                message: ''
            };
            var lookup = utils.debounce(function () {
                var ardorBlockExplorerService = heat.$inject.get('ardorBlockExplorerService');
                ardorBlockExplorerService.getBalance($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = new Big(utils.convertToQNTf(info)).toFixed(8);
                        $scope['vm'].data.recipientInfo = "Balance: ".concat(balance, " ARDR");
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
                ardorBlockExplorerService.getPublicKeyFromAddress($scope['vm'].data.recipient).then(function (publicKey) {
                    $scope['vm'].data.recipientPublicKey = publicKey;
                });
            }, 1000, false);
            this.recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                lookup();
            };
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send ARDR</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in ARDR</label>\n                  <input ng-model=\"vm.data.amountNQT\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Message</label>\n                  <input ng-model=\"vm.data.message\" name=\"message\">\n                </md-input-container>\n\n                <md-input-container flex>\n                  <label>Fee in ARDR</label>\n                  <input ng-model=\"vm.data.feeNQT\" required name=\"fee\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amountNQT || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"Send now\">Send now</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return ARDRCurrency;
}());
var BCHCurrency = (function () {
    function BCHCurrency(masterSecretPhrase, secretPhrase, address) {
        var _this = this;
        this.masterSecretPhrase = masterSecretPhrase;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'BCH';
        this.invokeSendDialog = function ($event) {
            _this.sendBch($event).then(function (data) {
                var timestamp = new Date().getTime();
                _this.pendingTransactions.add(_this.address, data.txId, timestamp);
            }, function (err) {
                if (err) {
                    dialogs.alert($event, 'Send BCH Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
                }
            });
        };
        this.bchBlockExplorerService = heat.$inject.get('bchBlockExplorerService');
        this.user = heat.$inject.get('user');
        this.homePath = "/bitcoin-cash-account/".concat(this.address);
        this.pendingTransactions = heat.$inject.get('bchPendingTransactions');
    }
    BCHCurrency.prototype.getBalance = function () {
        return this.bchBlockExplorerService.getBalance(this.address).then(function (balance) {
            var balanceUnconfirmed = parseFloat(balance) / 100000000;
            return utils.commaFormat(new Big(balanceUnconfirmed + "").toFixed(8));
        });
    };
    BCHCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return function () { };
    };
    BCHCurrency.prototype.notifyBalanceChanged = function () {
    };
    BCHCurrency.prototype.invokeSendToken = function ($event) {
    };
    BCHCurrency.prototype.sendBch = function ($event) {
        function DialogController2($scope, $mdDialog) {
            this.cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            var createTx = function (isForFeeEstimation) {
                if (isForFeeEstimation === void 0) { isForFeeEstimation = false; }
                var user = heat.$inject.get('user');
                var addressPrivateKeyPair = { address: user.currency.address, privateKey: user.currency.secretPhrase };
                var amountInSatoshi = $scope['vm'].data.amount * 100000000 === 0 ? 10000 : parseInt(($scope['vm'].data.amount * 100000000).toFixed(0));
                var feeInSatoshi = $scope['vm'].data.fee * 100000000 === 0 ? 1000 : parseInt(($scope['vm'].data.fee * 100000000).toFixed(0));
                var to = $scope['vm'].data.recipient;
                var txObject = {
                    from: addressPrivateKeyPair.address,
                    to: to,
                    amount: amountInSatoshi,
                    fee: feeInSatoshi,
                    changeAddress: addressPrivateKeyPair.address,
                    privateKey: addressPrivateKeyPair.privateKey
                };
                return txObject;
            };
            this.okButtonClick = function ($event) {
                var bchCryptoService = heat.$inject.get('bchCryptoService');
                $scope['vm'].disableOKBtn = true;
                bchCryptoService.sendBitcoinCash(createTx()).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        dialogs.alert(event, 'Success', "TxId: ".concat(data.txId));
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err.message);
                    });
                });
            };
            this.disableOKBtn = false;
            this.data = {
                amount: '',
                recipient: '',
                recipientInfo: '',
                fee: '0.00001'
            };
            var lookup = utils.debounce(function () {
                var bchBlockExplorerService = heat.$inject.get('bchBlockExplorerService');
                bchBlockExplorerService.getBalance($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = (parseFloat(info) / 100000000).toFixed(8);
                        $scope['vm'].data.recipientInfo = "Balance: ".concat(balance, " BCH");
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
            }, 1000, false);
            this.recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                lookup();
            };
            this.amountChanged = function () {
                var bchCryptoService = heat.$inject.get('bchCryptoService');
                $scope['vm'].data.txBytes = [];
                bchCryptoService.signTransaction(createTx(true), true).then(function (rawTx) {
                    $scope['vm'].data.txBytes = converters.hexStringToByteArray(rawTx);
                    $scope['vm'].data.fee = $scope['vm'].data.txBytes.length * $scope['vm'].data.estimatedFee / 100000000;
                });
            };
            function getEstimatedFee() {
                var bchBlockExplorerService = heat.$inject.get('bchBlockExplorerService');
                bchBlockExplorerService.getEstimatedFee().then(function (fee) {
                    $scope['vm'].data.fee = fee || $scope['vm'].data.fee;
                });
            }
            getEstimatedFee();
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send BCH</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in BCH</label>\n                  <input ng-model=\"vm.data.amount\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex>\n                  <label>Fee in BCH</label>\n                  <input ng-model=\"vm.data.fee\" required name=\"fee\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <md-button ng-click=\"0\" ng-disabled=\"true\" class=\"fee\" style=\"max-width:140px !important\">Fee {{vm.data.fee}} BCH</md-button>\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amount || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"Send now\">Send now</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return BCHCurrency;
}());
var BTCCurrency = (function () {
    function BTCCurrency(masterSecretPhrase, secretPhrase, address) {
        var _this = this;
        this.masterSecretPhrase = masterSecretPhrase;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'BTC';
        this.invokeSendDialog = function ($event) {
            var heatService = heat.$inject.get('heat');
            _this.sendBtc($event)
                .then(function (data) {
                if (data && data.txId) {
                    var encryptedMessage = heat.crypto.encryptMessage(data.message, _this.user.publicKey, _this.user.secretPhrase);
                    var timestamp = new Date().getTime();
                    _this.pendingTransactions.add(_this.address, data.txId, timestamp);
                    _this.bitcoinMessagesService.add(_this.address, data.txId, "".concat(encryptedMessage.data, ":").concat(encryptedMessage.nonce));
                    return wlt.getHeatUnavailableReason(heatService, _this.user.account)
                        .then(function (heatUnavailableReason) { return wlt.paymentMemoDialog(data.txId, heatUnavailableReason); })
                        .catch(function (reason) {
                        if (reason)
                            console.error(reason);
                    });
                }
            }, function (err) {
                if (err) {
                    dialogs.alert($event, 'Send BTC Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
                }
            });
        };
        this.btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
        this.homePath = "/bitcoin-account/".concat(this.address);
        this.pendingTransactions = heat.$inject.get('bitcoinPendingTransactions');
        this.bitcoinMessagesService = heat.$inject.get('bitcoinMessagesService');
        this.user = heat.$inject.get('user');
    }
    BTCCurrency.prototype.getBalance = function () {
        var self = this;
        self.recentBalance = wlt.getSavedCurrencyBalance(self.address, self.symbol);
        return this.btcBlockExplorerService.getBalance(this.address).then(function (balance) {
            self.recentBalance = wlt.getSavedCurrencyBalance(self.address, self.symbol, String(balance));
            return utils.commaFormat(new Big(self.recentBalance.confirmed).div(wlt.SATOSHI_PER_BTC).toFixed(8));
        }).catch(function (reason) {
            return utils.commaFormat(new Big(self.recentBalance.confirmed).div(wlt.SATOSHI_PER_BTC).toFixed(8));
        });
    };
    BTCCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return function () { };
    };
    BTCCurrency.prototype.notifyBalanceChanged = function () {
    };
    BTCCurrency.prototype.invokeSendToken = function ($event) {
    };
    BTCCurrency.prototype.sendBtc = function ($event) {
        var FeeList = (function () {
            function FeeList() {
                this.satByteFee = {};
                this.btcKByteFee = {};
            }
            FeeList.prototype.update = function (satByteFeesPerBlocks) {
                this.fill(satByteFeesPerBlocks, 1);
                this.fill(satByteFeesPerBlocks, 3);
                this.fill(satByteFeesPerBlocks, 6);
                this.fill(satByteFeesPerBlocks, 12);
            };
            FeeList.prototype.fill = function (satByteFeesPerBlocks, blocks) {
                var field = blocks.toFixed(0);
                if (satByteFeesPerBlocks[field]) {
                    this.satByteFee[field] = satByteFeesPerBlocks[field];
                    this.btcKByteFee[field] = this.satByteFee[field] / 100000000 * 1024;
                }
            };
            return FeeList;
        }());
        var feeList = new FeeList();
        var self = this;
        function DialogController2($scope, $mdDialog) {
            var vm = this;
            vm.disableOKBtn = false;
            vm.data = {
                amount: '',
                recipient: '',
                recipientInfo: '',
                fee: '0.00004540',
                message: '',
                satByteFee: 0
            };
            this.cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            var createTx = function (isForFeeEstimation) {
                if (isForFeeEstimation === void 0) { isForFeeEstimation = false; }
                var user = heat.$inject.get('user');
                var feeInSatoshi;
                var amountInSatoshi;
                var to;
                var addressPrivateKeyPair = { address: user.currency.address, privateKey: user.currency.secretPhrase };
                if (isForFeeEstimation) {
                    feeInSatoshi = vm.data.fee ? (vm.data.fee * 100000000).toFixed(0) : 0;
                    amountInSatoshi = vm.data.amount ? (vm.data.amount * 100000000).toFixed(0) : "0.0001";
                    to = vm.data.recipient ? vm.data.recipient : addressPrivateKeyPair.address;
                }
                else {
                    if (!vm.data.fee || !vm.data.amount || !vm.data.recipient) {
                        return null;
                    }
                    feeInSatoshi = (vm.data.fee * 100000000).toFixed(0);
                    amountInSatoshi = (vm.data.amount * 100000000).toFixed(0);
                    to = vm.data.recipient;
                }
                var txObject = {
                    from: addressPrivateKeyPair.address,
                    to: to,
                    amount: parseInt(amountInSatoshi),
                    fee: Math.ceil(feeInSatoshi),
                    changeAddress: addressPrivateKeyPair.address,
                    privateKey: addressPrivateKeyPair.privateKey
                };
                return txObject;
            };
            var updateUnconfirmedBalance = function (value, fees) {
                if (!self.recentBalance)
                    return;
                var txTotal = new Big(value).plus(new Big(fees));
                var unconfirmedBalance = new Big(self.recentBalance.confirmed).minus(txTotal);
                wlt.saveCurrencyBalance(self.address, self.symbol, self.recentBalance.confirmed, unconfirmedBalance.toString());
            };
            this.okButtonClick = function ($event) {
                var bitcoreService = heat.$inject.get('bitcoreService');
                vm.disableOKBtn = true;
                bitcoreService.sendBitcoins(createTx()).then(function (data) {
                    var sendingResult = Object.assign(data, { paymentMessageMethod: vm.paymentMessageMethod });
                    updateUnconfirmedBalance(vm.data.amount, vm.data.fee);
                    $mdDialog.hide(sendingResult).then(function () {
                        data.message = vm.data.message;
                        dialogs.alert(event, 'Success', "TxId: ".concat(data.txId));
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        var errMessage;
                        if (angular.isString(err)) {
                            errMessage = err;
                        }
                        else if (angular.isObject(err) && err != null) {
                            errMessage = err.message || err.error || JSON.stringify(err);
                        }
                        else {
                            errMessage = 'Unknown reason';
                        }
                        errMessage = err && err.name ? (err.name + ": " + errMessage) : errMessage;
                        dialogs.alert(event, 'Send BTC Error', 'There was an error sending this transaction: ' + errMessage);
                    });
                });
            };
            var lookup = utils.debounce(function () {
                var btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
                btcBlockExplorerService.getBalance(vm.data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance;
                        if (info) {
                            balance = (info / 100000000).toFixed(8);
                            vm.data.recipientInfo = "Destination balance ".concat(balance, " BTC");
                        }
                        vm.data.recipientInfo = balance ? "Destination balance ".concat(balance, " BTC") : '';
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        vm.data.recipientInfo = (error || {}).message || 'Invalid';
                    });
                });
            }, 1000, false);
            var calculateRawTx = function () {
                var bitcoreService = heat.$inject.get('bitcoreService');
                var errorCallback = function (reason) { return console.log("error on generation transaction bytes: " + reason); };
                vm.data.txBytes = [];
                var result = bitcoreService.signTransaction(createTx(true), true).then(function (rawTx) {
                    vm.data.txBytes = converters.hexStringToByteArray(rawTx);
                }).catch(errorCallback);
                vm.data.rawTx = '';
                var tx;
                try {
                    tx = createTx(false);
                }
                catch (e) {
                }
                if (tx) {
                    bitcoreService.signTransaction(tx).then(function (rawTx) {
                        vm.data.rawTx = rawTx;
                    }).catch(errorCallback);
                }
                return result;
            };
            var calculateRawTxDebounced = utils.debounce(calculateRawTx, 1000);
            this.recipientChanged = function () {
                vm.data.recipientInfo = '';
                lookup();
                calculateRawTxDebounced();
            };
            this.selectedItemChange = function (item) {
                vm.value = vm.selectedItem ? vm.selectedItem.id : '';
                vm.data.recipient = item.cryptoAddresses ? item.cryptoAddresses.find(function (i) { return i.name === 'BTC'; }).address : '';
                if (vm.data.recipient && vm.data.recipient !== '') {
                    vm.recipientChanged();
                }
            };
            this.search = function () {
                var p = heat.$inject.get('contactService');
                return p.lookupContact(vm.searchText.trim());
            };
            this.searchTextChange = function () {
                vm.value = vm.searchText;
                vm.data.recipient = vm.searchText;
                vm.recipientChanged();
            };
            this.amountChanged = function () {
                calculateRawTx();
            };
            var btcFeeService = heat.$inject.get('btcFeeService');
            var loadInternetFee = function () {
                return btcFeeService.getSatByteFee().then(function (satByteFeesPerBlocks) {
                    $scope.$evalAsync(function () {
                        vm.feeList = feeList;
                        feeList.update(satByteFeesPerBlocks);
                        if (!vm.data.satByteFee) {
                            vm.data.satByteFee = feeList.satByteFee['1'];
                            vm.data.fee = vm.data.satByteFee / 100000000 * 1024;
                        }
                    });
                });
            };
            this.feeChanged = function (event) {
                calculateRawTx().then(function () {
                    $scope.$evalAsync(function () {
                        if (vm.data.fee) {
                            vm.data.satByteFee = vm.data.fee * 100000000 / 1024;
                            if (vm.data.txBytes) {
                                vm.data.txnFee = (vm.data.satByteFee * vm.data.txBytes.length / 100000000);
                            }
                        }
                        else {
                            vm.data.satByteFee = '';
                        }
                    });
                });
            };
            this.clearFeeByteDerived = function () {
                $scope.$evalAsync(function () {
                    vm.data.fee = '';
                    vm.data.txnFee = '';
                    vm.data.txnFee = '';
                    vm.data.rawTx = '';
                });
            };
            this.feeByteChanged = function () {
                calculateRawTx().then(function () {
                    $scope.$evalAsync(function () {
                        if (vm.data.satByteFee) {
                            vm.data.fee = vm.data.satByteFee / 100000000 * 1024;
                            if (vm.data.txBytes) {
                                vm.data.txnFee = (vm.data.satByteFee * vm.data.txBytes.length / 100000000);
                            }
                        }
                        else {
                            vm.data.fee = '';
                        }
                    });
                });
            };
            this.fillFeeField = function (blocks) {
                vm.data.satByteFee = feeList.satByteFee['' + blocks];
                vm.feeByteChanged();
            };
            loadInternetFee().then(function (value) { return vm.feeChanged(); });
            var $interval = heat.$inject.get('$interval');
            var seconds = 0;
            var interval = $interval(function () {
                seconds++;
                if (vm.seconds % 60 == 0) {
                    loadInternetFee().then(function (value) { return seconds = 0; });
                }
                vm.seconds = seconds;
            }, 1000, 0, false);
            $scope.$on('$destroy', function () { return $interval.cancel(interval); });
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <ng-form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send BTC</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n            <div flex layout=\"column\">\n                <md-autocomplete\n                  ng-required=\"true\"\n                  ng-readonly=\"false\"\n                  md-input-name=\"recipientBtcAddress\"\n                  md-floating-label=\"Recipient\"\n                  md-min-length=\"1\"\n                  md-items=\"item in vm.search(vm.searchText)\"\n                  md-item-text=\"item.publicName||item.id\"\n                  md-search-text=\"vm.searchText\"\n                  md-selected-item-change=\"vm.selectedItemChange(item)\"\n                  md-search-text-change=\"vm.searchTextChange()\"\n                  md-selected-item=\"vm.selectedItem\">\n                    <md-item-template>\n                      <div layout=\"row\" flex class=\"monospace-font\">\n                        <span>{{item.publicName||''}}</span>\n                        <span flex></span>\n                        <span>{{item.id}}</span>\n                      </div>\n                    </md-item-template>\n                </md-autocomplete>\n                <div style=\"margin-top: -20px; margin-bottom: 20px\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </div>\n\n                <md-input-container flex >\n                  <label>Amount in BTC</label>\n                  <input ng-model=\"vm.data.amount\" ng-change=\"vm.amountChanged()\" required name=\"amount\">\n                </md-input-container>\n\n              <md-input-container>\n              <div style=\"margin-bottom: 12px\">\n                Network fee in Sat/Byte &nbsp;&nbsp; (updated {{vm.seconds}}s ago) <br>\n                <a ng-click=\"vm.fillFeeField(1)\">1 block: <b>{{vm.feeList.satByteFee['1']}}</b></a>\n                &nbsp;&nbsp;<a ng-click=\"vm.fillFeeField(3)\">3 blocks: <b>{{vm.feeList.satByteFee['3']}}</b></a> \n                &nbsp;&nbsp;<a ng-click=\"vm.fillFeeField(6)\">6 blocks: <b>{{vm.feeList.satByteFee['6']}}</b></a> \n                &nbsp;&nbsp;<a ng-click=\"vm.fillFeeField(12)\">12 blocks: <b>{{vm.feeList.satByteFee['12']}}</b></a>\n              </div>\n              </md-input-container>\n\n              <md-input-container flex>\n                <label>Fee in Sat/Byte</label>\n                <input ng-model=\"vm.data.satByteFee\" ng-change=\"vm.feeByteChanged($event)\" required name=\"feeByte\">\n              </md-input-container>\n\n              <md-input-container flex>\n                <label>Fee in BTC/kByte</label>\n                <input ng-model=\"vm.data.fee\" ng-change=\"vm.feeChanged($event)\" required name=\"fee\">\n              </md-input-container>\n\n              <md-input-container flex ng-if=\"vm.data.rawTx\">\n                <label>Transaction bytes</label>\n                <textarea ng-model=\"vm.data.rawTx\" readonly rows=\"3\"  wrap=\"soft\"\n                      style=\"overflow-y: scroll;max-height: 50px;line-height: normal;\"></textarea>\n              </md-input-container>\n\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n\n              <div ng-if=\"vm.data.txnFee\" class=\"fee\" style=\"max-width:250px !important\">\n                Transaction fee <b>&nbsp;{{vm.data.txnFee || '?'}}&nbsp;</b> BTC\n              </div>\n\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amount || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"Send now\">Send now</md-button>\n            </md-dialog-actions>\n          </ng-form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return BTCCurrency;
}());
var wlt;
(function (wlt) {
    var messageStore;
    var heatService;
    var userService;
    function paymentMemoDialog(txId, heatUnavailableReason) {
        var locals = {
            txId: txId,
            v: {
                text: "",
                paymentMessageMethod: undefined,
                heatUnavailableReason: heatUnavailableReason
            }
        };
        return dialogs.dialog({
            id: 'paymentMemo',
            title: "Payment Memo",
            okButton: true,
            cancelButton: true,
            locals: locals,
            template: "\n              <p flex>\n                  <label>Transaction</label>\n                  <span>&nbsp;&nbsp;{{vm.txId}}</span>\n              </p>\n              <md-input-container flex style=\"margin-bottom: 16px;\">\n                  <p>Store message on:</p>\n                  <md-radio-group ng-model=\"vm.v.paymentMessageMethod\" layout=\"row\">\n                    <md-radio-button value=0 >This device</md-radio-button>\n                    <md-radio-button value=1 ng-disabled=\"vm.v.heatUnavailableReason\">Heat blockchain</md-radio-button>\n                    <span ng-if=\"vm.v.heatUnavailableReason\" style=\"color: grey\"> &nbsp;&nbsp;({{vm.v.heatUnavailableReason}})</span>\n                  </md-radio-group>\n              </md-input-container>\n              <md-input-container flex>\n                  <label>Payment message / memo (encrypted)</label>\n                  <input required ng-model=\"vm.v.text\" name=\"message\" ng-maxlength=\"500\" ng-disabled=\"!vm.v.paymentMessageMethod\">\n              </md-input-container>\n            "
        }).then(function (value) {
            return storePaymentMessage(txId, locals.v.text, locals.v.paymentMessageMethod);
        });
    }
    wlt.paymentMemoDialog = paymentMemoDialog;
    function storePaymentMessage(txId, message, paymentMessageMethod, recipientPubKey) {
        var user = getUserService();
        recipientPubKey = recipientPubKey || user.publicKey;
        var encryptedMessage = heat.crypto.encryptMessage(message, recipientPubKey, user.secretPhrase);
        var messageId = createMessageId(txId, recipientPubKey);
        var sendHeatPaymentMessage = function (resolve, reject) {
            var errorCallback = function (reason) { return reject("linked message error: " + JSON.stringify(reason)); };
            var createKeystoreTransaction = function (transactionArgs) {
                return getHeatService().post("/keystore/put", Object.assign(transactionArgs, { key: messageId, value: JSON.stringify(encryptedMessage) })).then(function (value) {
                    transactionArgs.message = false;
                    return value;
                });
            };
            var builder = new TransactionBuilder(new (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                class_1.prototype.verify = function (transaction, attachment, data) {
                    return transaction.type === 1 && transaction.subtype === 0;
                };
                return class_1;
            }(AbstractTransaction)));
            builder.secretPhrase(user.secretPhrase)
                .feeNQT(HeatAPI.fee.standard)
                .attachment('ArbitraryMessage', {})
                .recipient(user.account);
            builder.create(createKeystoreTransaction)
                .then(function (value) { return builder.sign(); }, errorCallback)
                .then(function (value) { return builder.broadcast(); }, errorCallback)
                .then(function (value) {
                if (value.success) {
                    resolve(true);
                }
                else {
                    errorCallback.bind(null, value.internalError || value.serverError);
                }
            }, errorCallback)
                .catch(errorCallback);
        };
        return new Promise(function (resolve, reject) {
            if (message) {
                if (paymentMessageMethod == 0) {
                    getPaymentMessageStore().put(messageId, encryptedMessage);
                    resolve(true);
                }
                else if (paymentMessageMethod == 1) {
                    sendHeatPaymentMessage(resolve, reject);
                }
                else {
                    resolve(false);
                }
            }
            else {
                resolve(false);
            }
        });
    }
    wlt.storePaymentMessage = storePaymentMessage;
    function getHeatUnavailableReason(heatService, account) {
        return heatService.api.getAccountBalance(account, '0')
            .then(function (balance) {
            try {
                var avail = new Big(balance.unconfirmedBalance);
                return avail.gte(new Big(HeatAPI.fee.standard)) > 0 ? "" : "insufficient HEAT balance";
            }
            catch (e) {
                return "Unknown HEAT balance: " + (e === null || e === void 0 ? void 0 : e.toString());
            }
        })
            .catch(function (reason) {
            console.error(reason);
            return "Cannot recognise the state of HEAT account: " + (reason === null || reason === void 0 ? void 0 : reason.description) || JSON.stringify(reason);
        });
    }
    wlt.getHeatUnavailableReason = getHeatUnavailableReason;
    var apiGetKeystoreValueFunc;
    function loadPaymentMessage(txId) {
        var store = getPaymentMessageStore();
        var user = getUserService();
        var messageId = createMessageId(txId, user.publicKey);
        var decrypt = function (encrypted) {
            try {
                return heat.crypto.decryptMessage(encrypted.data, encrypted.nonce, user.publicKey, user.secretPhrase);
            }
            catch (e) { }
            return null;
        };
        return new Promise(function (resolve, reject) {
            var encryptedMessage = store.get(messageId);
            var messageText = encryptedMessage ? decrypt(encryptedMessage) : null;
            if (messageText) {
                resolve({ method: 0, text: messageText });
                return;
            }
            if (!apiGetKeystoreValueFunc) {
                apiGetKeystoreValueFunc = function (account, messageIds) { return getHeatService().api.getKeystoreAccountEntryExt(account, messageIds); };
            }
            apiGetKeystoreValueFunc(user.account, messageId).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.errorDescription) {
                    reject(parsed.errorDescription);
                }
                else {
                    var entry = parsed.entries ? parsed.entries[0] : parsed;
                    var message = void 0;
                    if (entry) {
                        encryptedMessage = JSON.parse(entry.value);
                        message = decrypt(encryptedMessage);
                    }
                    resolve(message ? { method: 1, text: message } : null);
                }
            }, function (reason) {
                if (reason.code == -1) {
                    apiGetKeystoreValueFunc = function (account, messageId) { return getHeatService().api.getKeystoreAccountEntry(account, messageId); };
                }
                if (reason.description == "Unknown key") {
                    resolve(null);
                }
                else {
                    reject(reason);
                }
            });
        });
    }
    wlt.loadPaymentMessage = loadPaymentMessage;
    function exportPaymentMessages() {
        var store = getPaymentMessageStore();
        return store.keys().map(function (k) { return ({ id: k, content: store.get(k) }); });
    }
    wlt.exportPaymentMessages = exportPaymentMessages;
    function importPaymentMessages(items) {
        if (!items)
            return 0;
        var store = getPaymentMessageStore();
        var n = 0;
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            store.put(item.id, item.content);
            n++;
        }
        return n;
    }
    wlt.importPaymentMessages = importPaymentMessages;
    function createMessageId(txId, recipientPubKey) {
        var userPrivateKeyBytes = converters.hexStringToByteArray(heat.crypto.getPrivateKey(getUserService().secretPhrase));
        var recipientPubKeyBytes = converters.hexStringToByteArray(recipientPubKey);
        var sharedSecret = heat.crypto.getSharedKey(userPrivateKeyBytes, recipientPubKeyBytes);
        return heat.crypto.calculateStringHash(txId + sharedSecret);
    }
    function getPaymentMessageStore() {
        if (!messageStore) {
            var storage = heat.$inject.get('storage');
            var $rootScope = heat.$inject.get('$rootScope');
            messageStore = storage.namespace("pmt-msg", $rootScope, true);
        }
        return messageStore;
    }
    function getHeatService() {
        if (!heatService) {
            heatService = heat.$inject.get('heat');
        }
        return heatService;
    }
    function getUserService() {
        if (!userService) {
            userService = heat.$inject.get('user');
        }
        return userService;
    }
})(wlt || (wlt = {}));
var GWEI_SCALE = 1000000000;
var ETHCurrency = (function () {
    function ETHCurrency(masterSecretPhrase, secretPhrase, address) {
        this.masterSecretPhrase = masterSecretPhrase;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'ETH';
        this.ethBlockExplorerService = heat.$inject.get('ethBlockExplorerService');
        this.user = heat.$inject.get('user');
        this.homePath = "/ethereum-account/".concat(this.address);
        this.pendingService = heat.$inject.get('ethereumPendingTransactions');
    }
    ETHCurrency.prototype.getBalance = function () {
        var self = this;
        self.recentBalance = wlt.getSavedCurrencyBalance(self.address, "ETH");
        return this.ethBlockExplorerService.getBalance(this.address).then(function (balance) {
            var _a;
            self.recentBalance = wlt.getSavedCurrencyBalance(self.address, "ETH", balance);
            return utils.commaFormat(new Big(((_a = self.recentBalance) === null || _a === void 0 ? void 0 : _a.confirmed) || "0").toFixed(18));
        }).catch(function (reason) {
            var _a;
            return utils.commaFormat(new Big(((_a = self.recentBalance) === null || _a === void 0 ? void 0 : _a.confirmed) || "0").toFixed(18));
        });
    };
    ETHCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return function () { };
    };
    ETHCurrency.prototype.notifyBalanceChanged = function () {
    };
    ETHCurrency.prototype.invokeSendDialog = function ($event) {
        var _this = this;
        var heatService = heat.$inject.get('heat');
        this.sendEther($event)
            .then(function (data) {
            if (data && data.txId) {
                var address = _this.user.currency.address;
                var timestamp = new Date().getTime();
                _this.pendingService.add(address, data.txId, timestamp);
                return wlt.getHeatUnavailableReason(heatService, _this.user.account)
                    .then(function (heatUnavailableReason) { return wlt.paymentMemoDialog(data.txId, heatUnavailableReason); })
                    .catch(function (reason) {
                    if (reason)
                        console.error(reason);
                });
            }
        });
    };
    ETHCurrency.prototype.invokeSendToken = function ($event) {
    };
    ETHCurrency.prototype.sendEther = function ($event) {
        var self = this;
        var web3 = heat.$inject.get('web3');
        function DialogController2($scope, $mdDialog) {
            var _this = this;
            this.paymentMessageMethod = null;
            this.cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            var updateUnconfirmedBalance = function (value, fees) {
                var txTotal = new Big(web3.web3.fromWei(new Big(value).plus(new Big(fees)), 'ether'));
                if (self.recentBalance) {
                    var unconfirmedBalance = self.recentBalance.confirmed
                        ? new Big(self.recentBalance.confirmed).minus(txTotal).toString() : undefined;
                    wlt.saveCurrencyBalance(self.address, self.symbol, self.recentBalance.confirmed, unconfirmedBalance);
                }
            };
            this.okButtonClick = function ($event) {
                var data = $scope['vm'].data;
                var user = heat.$inject.get('user');
                var web3 = heat.$inject.get('web3');
                var ethBlockExplorerService = heat.$inject.get('ethBlockExplorerService');
                var amountInWei = web3.web3.toWei(data.amount.replace(',', ''), 'ether');
                var from = { privateKey: user.currency.secretPhrase, address: user.currency.address };
                $scope['vm'].disableOKBtn = true;
                web3.createRawTx2(from, data.recipient, amountInWei, data.gasPrice * GWEI_SCALE, data.gasLimit).then(function (rawTx) {
                    ethBlockExplorerService.broadcast(rawTx).then(function (result) {
                        if (result.txId) {
                            result.message = $scope['vm'].data.message;
                            var sendingResult = Object.assign(result, { paymentMessageMethod: $scope['vm'].paymentMessageMethod });
                            updateUnconfirmedBalance(amountInWei, web3.web3.toWei(data.fee, 'ether'));
                            $mdDialog.hide(sendingResult).then(function () {
                                dialogs.alert(event, 'Success', "TxHash: ".concat(result.txId));
                            });
                        }
                        else {
                            dialogs.alert(event, 'Not success result', "Result: ".concat(JSON.stringify(result)));
                        }
                    }, function (err) {
                        $mdDialog.hide(null).then(function () {
                            dialogs.alert(event, 'Error', err ? (err.message || err.error || err) : "Error, see details in the console output");
                        });
                    });
                }).catch(function (reason) {
                    dialogs.alert($event, 'ETH transaction creation error', reason);
                });
            };
            this.displaySignedBytesClick = function ($event) {
                var data = $scope['vm'].data;
                var user = heat.$inject.get('user');
                var web3 = heat.$inject.get('web3');
                var amountInWei = web3.web3.toWei(data.amount.replace(',', ''), 'ether');
                var from = { privateKey: user.currency.secretPhrase, address: user.currency.address };
                var getAddressNonce = function (address) { return web3.getAddressNonce(address)
                    .catch(function (reason) {
                    return dialogs.simplePrompt(null, 'Enter ETH address nonce', "The nonce is not resolved. Nonce is the transaction count from that address (outgoing transactions)", [{ label: "Nonce", value: undefined }]);
                })
                    .then(function (nonce) {
                    return nonce[0];
                }); };
                web3.createRawTx2(from, data.recipient, amountInWei, data.gasPrice * GWEI_SCALE, data.gasLimit, getAddressNonce)
                    .then(function (rawTx) {
                    var clipboardService = heat.$inject.get('clipboard');
                    clipboardService.showTxnBytes("" + rawTx);
                })
                    .catch(function (reason) {
                    dialogs.alert($event, 'ETH transaction creation error', reason);
                });
            };
            this.disableOKBtn = false;
            this.data = {
                amount: '',
                gasPrice: '',
                gasLimit: '',
                recipient: '',
                recipientInfo: '',
                fee: '0.000420',
                message: ''
            };
            var lookup = utils.debounce(function () {
                var ethBlockExplorerService = heat.$inject.get('ethBlockExplorerService');
                ethBlockExplorerService.getBalance($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = Number.parseFloat(info).toFixed(18);
                        $scope['vm'].data.recipientInfo = "Balance: ".concat(balance, " ETH");
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error ? (error.message || error) : 'Invalid';
                    });
                });
            }, 1000, false);
            var settingsService = heat.$inject.get('settings');
            this.recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                lookup();
            };
            this.gasChanged = function () {
                $scope.$evalAsync(function () {
                    _this.data.fee = web3.web3.fromWei((_this.data.gasPrice * GWEI_SCALE) * _this.data.gasLimit, 'ether');
                });
            };
            web3.getGasPrice().then(function (gasprice) {
                var data = $scope['vm'].data;
                data.gasPrice = gasprice / GWEI_SCALE;
                data.gasLimit = settingsService.get(SettingsService.ETH_TX_GAS_REQUIRED);
                data.fee = web3.web3.fromWei(gasprice * data.gasLimit, 'ether');
            });
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send Ether</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in ETH</label>\n                  <input ng-model=\"vm.data.amount\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Gas price (in GWei)</label>\n                  <input ng-model=\"vm.data.gasPrice\" ng-change=\"vm.gasChanged()\" required name=\"gasPrice\">\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Gas limit</label>\n                  <input ng-model=\"vm.data.gasLimit\" ng-change=\"vm.gasChanged()\" required name=\"gasLimit\">\n                </md-input-container>\n\n                <p>Fee: {{vm.data.fee}} ETH</p>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amount || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.displaySignedBytesClick()\" aria-label=\"Signed bytes\">Signed transaction bytes</md-button>\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amount || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"Send now\">Send now</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return ETHCurrency;
}());
var FIMKCurrency = (function () {
    function FIMKCurrency(masterSecretPhrase, secretPhrase, address) {
        this.masterSecretPhrase = masterSecretPhrase;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'FIM';
        this.mofoSocketService = heat.$inject.get('mofoSocketService');
        this.user = heat.$inject.get('user');
        this.homePath = "/fimk-account/".concat(this.address);
        this.pendingTransactions = heat.$inject.get('fimkPendingTransactions');
        this.$rootScope = heat.$inject.get('$rootScope');
        this.$q = heat.$inject.get('$q');
    }
    FIMKCurrency.prototype.getBalance = function () {
        var deferred = this.$q.defer();
        this.mofoSocketService.getAccount(this.address).then(function (info) {
            var balance = info.unconfirmedBalanceNQT ? parseInt(info.unconfirmedBalanceNQT) / 100000000 : 0;
            var formattedBalance = new Big(balance + "");
            deferred.resolve(new Big(formattedBalance).toFixed(8));
        }, function (err) {
            deferred.reject();
        });
        return deferred.promise;
    };
    FIMKCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return;
    };
    FIMKCurrency.prototype.notifyBalanceChanged = function () {
    };
    FIMKCurrency.prototype.invokeSendDialog = function ($event) {
        var _this = this;
        this.sendFim($event).then(function (data) {
            var address = _this.user.currency.address;
            var timestamp = new Date().getTime();
            _this.pendingTransactions.add(address, data.txId, timestamp);
        }, function (err) {
            if (err) {
                dialogs.alert($event, 'Send FIM Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
            }
        });
    };
    FIMKCurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    FIMKCurrency.prototype.sendFim = function ($event) {
        function DialogController2($scope, $mdDialog) {
            this.cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            this.okButtonClick = function ($event) {
                var user = heat.$inject.get('user');
                var mofoSocketService = heat.$inject.get('mofoSocketService');
                var to = $scope['vm'].data.recipient;
                var recipientPublicKey;
                if ($scope['vm'].data.recipientPublicKey) {
                    recipientPublicKey = converters.hexStringToByteArray($scope['vm'].data.recipientPublicKey);
                }
                var userMessage = $scope['vm'].data.message;
                var txObject;
                if (userMessage && userMessage != '' && recipientPublicKey) {
                    var options = {
                        "publicKey": recipientPublicKey
                    };
                    var encryptedNote = heat.crypto.encryptNote(userMessage, options, user.currency.secretPhrase);
                    txObject = {
                        recipient: to,
                        amountNQT: utils.convertToNQT(String($scope['vm'].data.amountNQT)),
                        feeNQT: utils.convertToNQT(String($scope['vm'].data.feeNQT)),
                        publicKey: user.publicKey,
                        deadline: '1440',
                        requestType: 'sendMoney',
                        encryptedMessageData: encryptedNote.message,
                        encryptedMessageNonce: encryptedNote.nonce,
                        messageToEncryptIsText: 'true'
                    };
                }
                else {
                    txObject = {
                        recipient: to,
                        amountNQT: utils.convertToNQT(String($scope['vm'].data.amountNQT)),
                        feeNQT: utils.convertToNQT(String($scope['vm'].data.feeNQT)),
                        publicKey: user.publicKey,
                        deadline: '1440',
                        requestType: 'sendMoney'
                    };
                }
                $scope['vm'].disableOKBtn = true;
                mofoSocketService.sendFim(txObject).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        dialogs.alert(event, 'Success', "TxId: ".concat(data.txId));
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err);
                    });
                });
            };
            this.disableOKBtn = false;
            var defaultFee = '0.1';
            this.data = {
                amountNQT: '',
                recipient: '',
                recipientInfo: '',
                feeNQT: defaultFee,
                message: ''
            };
            var lookup = utils.debounce(function () {
                var mofoSocketService = heat.$inject.get('mofoSocketService');
                var heatService = heat.$inject.get('heat');
                mofoSocketService.getAccount($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var unconfirmedBalanceNQT = parseInt(info.unconfirmedBalanceNQT) / 100000000;
                        var formattedBalance = new Big(unconfirmedBalanceNQT + "");
                        var balance = new Big(formattedBalance).toFixed(8);
                        $scope['vm'].data.recipientInfo = "Balance: ".concat(balance, " FIM");
                        $scope['vm'].data.recipientPublicKey = info.publicKey;
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
            }, 1000, false);
            this.recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                $scope['vm'].data.recipientPublicKey = '';
                lookup();
            };
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send FIM</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in FIM</label>\n                  <input ng-model=\"vm.data.amountNQT\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Message</label>\n                  <input ng-model=\"vm.data.message\" name=\"message\">\n                </md-input-container>\n\n                <md-input-container flex>\n                  <label>Fee in FIM</label>\n                  <input ng-model=\"vm.data.feeNQT\" required name=\"fee\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amountNQT || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"Send now\">Send now</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return FIMKCurrency;
}());
var HEATCurrency = (function () {
    function HEATCurrency(masterSecretPhrase, secretPhrase, address) {
        this.masterSecretPhrase = masterSecretPhrase;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'HEAT';
        this.heat = heat.$inject.get('heat');
        this.sendmoney = heat.$inject.get('sendmoney');
        this.homePath = "/explorer-account/".concat(this.address, "/transactions");
    }
    HEATCurrency.prototype.getBalance = function () {
        return this.heat.api.getAccountBalanceVirtual(this.address, "0", "0", 1).then(function (balance) {
            var formatted = utils.formatQNT(balance.virtualBalance, 8);
            return formatted;
        });
    };
    HEATCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return this.heat.subscriber.balanceChanged({ account: this.address }, handler);
    };
    HEATCurrency.prototype.notifyBalanceChanged = function () {
    };
    HEATCurrency.prototype.invokeSendDialog = function ($event) {
        this.sendmoney.dialog($event).show();
    };
    HEATCurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    return HEATCurrency;
}());
var IOTACurrency = (function () {
    function IOTACurrency(masterSecretPhrase, secretPhrase, address) {
        this.masterSecretPhrase = masterSecretPhrase;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'IOTA';
        this.iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
        this.user = heat.$inject.get('user');
        this.homePath = "/iota-account/".concat(this.address);
        this.pendingTransactions = heat.$inject.get('iotaPendingTransactions');
        this.$q = heat.$inject.get('$q');
    }
    IOTACurrency.prototype.getBalance = function () {
        var deferred = this.$q.defer();
        this.iotaBlockExplorerService.getAccountInfo(this.secretPhrase).then(function (info) {
            deferred.resolve(info.accountData.balance.toString());
        }, function (err) {
            deferred.reject();
        });
        return deferred.promise;
    };
    IOTACurrency.prototype.subscribeBalanceChanged = function (handler) {
        return;
    };
    IOTACurrency.prototype.notifyBalanceChanged = function () {
    };
    IOTACurrency.prototype.invokeSendDialog = function ($event) {
        this.sendIota($event).then(function (data) {
        }, function (err) {
            if (err) {
                dialogs.alert($event, 'Send IOTA Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
            }
        });
    };
    IOTACurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    IOTACurrency.prototype.sendIota = function ($event) {
        function DialogController2($scope, $mdDialog) {
            this.cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            this.okButtonClick = function ($event) {
                var iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
                var user = heat.$inject.get('user');
                $scope['vm'].disableOKBtn = true;
                var transfers = [{
                        address: $scope['vm'].data.recipient.length === 90 ? $scope['vm'].data.recipient.slice(0, 81) : $scope['vm'].data.recipient,
                        value: parseInt($scope['vm'].data.value)
                    }];
                iotaBlockExplorerService.sendIota(user.currency.secretPhrase, transfers).then(function (data) {
                    dialogs.alert(event, 'Success', "Bundle: ".concat(data[0].hash));
                    var address = user.currency.address;
                    var timestamp = new Date().getTime();
                    var pendingTransactions = heat.$inject.get('iotaPendingTransactions');
                    pendingTransactions.add(address, data[0].hash, timestamp);
                }, function (err) {
                    dialogs.alert(event, 'Error', err);
                });
                $mdDialog.hide(null);
                var $mdToast = heat.$inject.get('$mdToast');
                $mdToast.show($mdToast.simple().textContent("Send transaction is in process.\n" +
                    "Please wait for the dialog to view transaction id").hideDelay(5000));
            };
            this.disableOKBtn = false;
            this.data = {
                value: '',
                recipient: '',
                recipientInfo: '',
                addressReuse: true
            };
            var lookup = utils.debounce(function () {
                var iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
                iotaBlockExplorerService.getBalance($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = new Big(info).toFixed(0);
                        $scope['vm'].data.recipientInfo = "Balance: ".concat(balance, " IOTA");
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
            }, 1000, false);
            var checkAddressValidity = function (address) {
                var iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
                iotaBlockExplorerService.checkAddressReuse(address).then(function (reuse) { return $scope['vm'].data.addressReuse = reuse; });
            };
            this.recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                lookup();
                checkAddressValidity($scope['vm'].data.recipient);
            };
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send IOTA</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in IOTA</label>\n                  <input ng-model=\"vm.data.value\" required name=\"amount\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.value || vm.disableOKBtn || vm.data.addressReuse\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"Send now\">Send now</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return IOTACurrency;
}());
var LTCCurrency = (function () {
    function LTCCurrency(masterSecretPhrase, secretPhrase, address) {
        var _this = this;
        this.masterSecretPhrase = masterSecretPhrase;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'LTC';
        this.invokeSendDialog = function ($event) {
            _this.sendLtc($event).then(function (data) {
                var timestamp = new Date().getTime();
                _this.pendingTransactions.add(_this.address, data.result, timestamp);
            }, function (err) {
                if (err) {
                    dialogs.alert($event, 'Send LTC Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
                }
            });
        };
        this.ltcBlockExplorerService = heat.$inject.get('ltcBlockExplorerService');
        this.user = heat.$inject.get('user');
        this.homePath = "/ltc-account/".concat(this.address);
        this.pendingTransactions = heat.$inject.get('ltcPendingTransactions');
    }
    LTCCurrency.prototype.getBalance = function () {
        return this.ltcBlockExplorerService.getBalance(this.address).then(function (balance) {
            var balanceUnconfirmed = parseFloat(balance) / 100000000;
            return utils.commaFormat(new Big(balanceUnconfirmed + "").toFixed(8));
        });
    };
    LTCCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return function () { };
    };
    LTCCurrency.prototype.notifyBalanceChanged = function () {
    };
    LTCCurrency.prototype.invokeSendToken = function ($event) {
    };
    LTCCurrency.prototype.sendLtc = function ($event) {
        function DialogController2($scope, $mdDialog) {
            this.cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            var createTx = function (isForFeeEstimation) {
                if (isForFeeEstimation === void 0) { isForFeeEstimation = false; }
                var user = heat.$inject.get('user');
                var addressPrivateKeyPair = { address: user.currency.address, privateKey: user.currency.secretPhrase };
                var amountInSatoshi = $scope['vm'].data.amount * 100000000 === 0 ? 10000 : $scope['vm'].data.amount * 100000000;
                var feeInSatoshi = $scope['vm'].data.fee * 100000000 === 0 ? 10000 : $scope['vm'].data.fee * 100000000;
                var to = $scope['vm'].data.recipient;
                var txObject = {
                    privateKey: addressPrivateKeyPair.privateKey,
                    fee: feeInSatoshi,
                    sender: addressPrivateKeyPair.address,
                    recipient: to,
                    value: amountInSatoshi
                };
                return txObject;
            };
            this.okButtonClick = function ($event) {
                var ltcBlockExplorerService = heat.$inject.get('ltcBlockExplorerService');
                $scope['vm'].disableOKBtn = true;
                var txObject = createTx(false);
                var ltcCryptoService = heat.$inject.get('ltcCryptoService');
                ltcCryptoService.signTransaction(txObject).then(function (signedTx) {
                    ltcBlockExplorerService.broadcast(signedTx).then(function (data) {
                        $mdDialog.hide(data).then(function () {
                            dialogs.alert(event, 'Success', "TxId: ".concat(data.result));
                        });
                    }, function (err) {
                        $mdDialog.hide(null).then(function () {
                            dialogs.alert(event, 'Error', err.message);
                            console.log('Error in broadcast: ', err);
                        });
                    });
                }, function (error) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', error.message);
                    });
                });
            };
            this.disableOKBtn = false;
            this.data = {
                amount: '',
                recipient: '',
                recipientInfo: '',
                fee: '0.0001',
                estimatedFee: '0.0001'
            };
            var lookup = utils.debounce(function () {
                var ltcBlockExplorerService = heat.$inject.get('ltcBlockExplorerService');
                ltcBlockExplorerService.getAddressInfo($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = (info.balance / 100000000).toFixed(8);
                        $scope['vm'].data.recipientInfo = "Balance: ".concat(balance, " LTC");
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
            }, 1000, false);
            this.recipientChanged = function () {
                var ltcCryptoService = heat.$inject.get('ltcCryptoService');
                $scope['vm'].data.recipientInfo = '';
                lookup();
            };
            this.amountChanged = function () {
                var ltcCryptoService = heat.$inject.get('ltcCryptoService');
                $scope['vm'].data.txBytes = [];
                ltcCryptoService.signTransaction(createTx(true), true).then(function (rawTx) {
                    $scope['vm'].data.txBytes = converters.hexStringToByteArray(rawTx);
                    $scope['vm'].data.fee = $scope['vm'].data.txBytes.length * $scope['vm'].data.estimatedFee / 100000000;
                });
            };
            function getEstimatedFee() {
                var ltcBlockExplorerService = heat.$inject.get('ltcBlockExplorerService');
                ltcBlockExplorerService.getEstimatedFee().then(function (data) {
                    if (data != -1)
                        $scope['vm'].data.estimatedFee = data / 1000;
                });
            }
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send Ltc</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in Ltc</label>\n                  <input ng-model=\"vm.data.amount\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex>\n                  <label>Fee in Ltc</label>\n                  <input ng-model=\"vm.data.fee\" required name=\"fee\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <md-button ng-click=\"0\" ng-disabled=\"true\" class=\"fee\" style=\"max-width:140px !important\">Fee {{vm.data.fee}} LTC</md-button>\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amount || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"Send now\">Send now</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return LTCCurrency;
}());
var NXTCurrency = (function () {
    function NXTCurrency(masterSecretPhrase, secretPhrase, address) {
        this.masterSecretPhrase = masterSecretPhrase;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'NXT';
        this.user = heat.$inject.get('user');
        this.homePath = "/nxt-account/".concat(this.address);
        this.pendingTransactions = heat.$inject.get('nxtPendingTransactions');
        this.nxtBlockExplorerService = heat.$inject.get('nxtBlockExplorerService');
        this.$rootScope = heat.$inject.get('$rootScope');
        this.$q = heat.$inject.get('$q');
    }
    NXTCurrency.prototype.getBalance = function () {
        var deferred = this.$q.defer();
        this.nxtBlockExplorerService.getAccount(this.address).then(function (data) {
            deferred.resolve(new Big(utils.convertToQNTf(data.balanceNQT)).toFixed(8));
        }, function (err) {
            deferred.reject(err);
        });
        return deferred.promise;
    };
    NXTCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return;
    };
    NXTCurrency.prototype.notifyBalanceChanged = function () {
    };
    NXTCurrency.prototype.invokeSendDialog = function ($event) {
        var _this = this;
        this.sendNxt($event).then(function (data) {
            var address = _this.user.currency.address;
            var timestamp = new Date().getTime();
            _this.pendingTransactions.add(address, data.txId, timestamp);
        }, function (err) {
            if (err) {
                dialogs.alert($event, 'Send NXT Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
            }
        });
    };
    NXTCurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    NXTCurrency.prototype.sendNxt = function ($event) {
        function DialogController2($scope, $mdDialog) {
            this.cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            this.okButtonClick = function ($event) {
                var user = heat.$inject.get('user');
                var nxtBlockExplorerService = heat.$inject.get('nxtBlockExplorerService');
                var to = $scope['vm'].data.recipient;
                var amountNQT = utils.convertToNQT(String($scope['vm'].data.amountNQT));
                var feeNQT = utils.convertToNQT(String($scope['vm'].data.feeNQT));
                var recipientPublicKey;
                var txObject;
                if ($scope['vm'].data.recipientPublicKey) {
                    recipientPublicKey = converters.hexStringToByteArray($scope['vm'].data.recipientPublicKey);
                }
                var userMessage = $scope['vm'].data.message;
                if (userMessage && userMessage != '' && recipientPublicKey) {
                    var options = {
                        "publicKey": recipientPublicKey
                    };
                    var encryptedNote = heat.crypto.encryptNote(userMessage, options, user.currency.secretPhrase);
                    txObject = "nxt?requestType=sendMoney&publicKey=".concat(user.publicKey, "&recipient=").concat(to, "&amountNQT=").concat(amountNQT, "&feeNQT=").concat(feeNQT, "&deadline=60&encryptedMessageData=").concat(encryptedNote.message, "&encryptedMessageNonce=").concat(encryptedNote.nonce, "&messageToEncryptIsText=true");
                }
                else {
                    txObject = "nxt?requestType=sendMoney&publicKey=".concat(user.publicKey, "&recipient=").concat(to, "&amountNQT=").concat(amountNQT, "&feeNQT=").concat(feeNQT, "&deadline=60");
                }
                $scope['vm'].disableOKBtn = true;
                nxtBlockExplorerService.sendNxt(txObject).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        dialogs.alert(event, 'Success', "TxId: ".concat(data.txId));
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err);
                    });
                });
            };
            this.disableOKBtn = false;
            var defaultFee = '1.0';
            this.data = {
                amountNQT: '',
                recipient: '',
                recipientInfo: '',
                feeNQT: defaultFee,
                message: ''
            };
            var lookup = utils.debounce(function () {
                var nxtBlockExplorerService = heat.$inject.get('nxtBlockExplorerService');
                nxtBlockExplorerService.getBalance($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = new Big(utils.convertToQNTf(info)).toFixed(8);
                        $scope['vm'].data.recipientInfo = "Balance: ".concat(balance, " NXT");
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
                nxtBlockExplorerService.getPublicKeyFromAddress($scope['vm'].data.recipient).then(function (publicKey) {
                    $scope['vm'].data.recipientPublicKey = publicKey;
                });
            }, 1000, false);
            this.recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                lookup();
            };
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send NXT</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in NXT</label>\n                  <input ng-model=\"vm.data.amountNQT\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Message</label>\n                  <input ng-model=\"vm.data.message\" name=\"message\">\n                </md-input-container>\n\n                <md-input-container flex>\n                  <label>Fee in NXT</label>\n                  <input ng-model=\"vm.data.feeNQT\" required name=\"fee\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amountNQT || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"Send now\">Send now</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return NXTCurrency;
}());
var ControlCharRenderService = (function () {
    function ControlCharRenderService() {
    }
    ControlCharRenderService.prototype.toHtml = function (rawText) {
        return this.nl2br(rawText, '<br />');
    };
    ControlCharRenderService.prototype.nl2br = function (str, breakTag) {
        return (str + '').replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1' + breakTag + '$2');
    };
    ControlCharRenderService = __decorate([
        Service('controlCharRender')
    ], ControlCharRenderService);
    return ControlCharRenderService;
}());
var EmojiiRenderService = (function () {
    function EmojiiRenderService() {
    }
    EmojiiRenderService.prototype.toHtml = function (rawText) {
        return rawText;
    };
    EmojiiRenderService = __decorate([
        Service('emojiiRender')
    ], EmojiiRenderService);
    return EmojiiRenderService;
}());
var p2p;
(function (p2p) {
    var BaseProtocol = (function () {
        function BaseProtocol() {
            var _this = this;
            this.baseHandlers = {
                PONG: function (roomName, msg) {
                },
                ERROR: function (msg) {
                    _this.connector.processError(msg ? msg.reason : "error");
                }
            };
            this.handlers = this.baseHandlers;
        }
        Object.defineProperty(BaseProtocol.prototype, "name", {
            get: function () {
                return "";
            },
            enumerable: false,
            configurable: true
        });
        BaseProtocol.prototype.handle = function (messageType, roomName, msg) {
            var f = this.handlers[messageType];
            if (f)
                return f(roomName, msg);
            throw new Error("Handler for message type \"".concat(messageType, "\" in protocol \"").concat(this.name, "\" is not found"));
        };
        return BaseProtocol;
    }());
    p2p.BaseProtocol = BaseProtocol;
})(p2p || (p2p = {}));
var p2p;
(function (p2p) {
    var CallDialog = (function (_super) {
        __extends(CallDialog, _super);
        function CallDialog($event, heatService, user, recipient, recipientPublicKey, messageText, p2pmessaging) {
            var _this = _super.call(this, $event) || this;
            _this.heatService = heatService;
            _this.user = user;
            _this.recipient = recipient;
            _this.recipientPublicKey = recipientPublicKey;
            _this.messageText = messageText;
            _this.p2pmessaging = p2pmessaging;
            _this.doCall = function (publicKey) {
                var room = _this.p2pmessaging.getOneToOneRoom(publicKey);
                if (_this.p2pmessaging.isPeerConnected(publicKey)) {
                    _this.okBtn['mdDialog'].hide(room);
                    return;
                }
                var recipientAccount = heat.crypto.getAccountIdFromPublicKey(publicKey);
                var contactService = heat.$inject.get('contactService');
                var saveContactResult = contactService.saveContact(recipientAccount, publicKey, null, -Date.now());
                if (saveContactResult) {
                    room = _this.p2pmessaging.requestNewContact(publicKey, _this.fields['messageText'].value);
                    _this.close(room);
                }
                else {
                    var $mdToast = heat.$inject.get('$mdToast');
                    $mdToast.show($mdToast.simple().textContent("Cannot save contact. Message is not sent").hideDelay(4000));
                }
            };
            _this.dialogTitle = 'Send offchain message to the new contact';
            _this.dialogDescription = 'Send offchain message to the new contact';
            _this.okBtnTitle = 'Send';
            _this.customFeeTitle = 'NO FEE';
            _this.okBtn['disabled'] = !recipient;
            return _this;
        }
        CallDialog.prototype.getFields = function ($scope) {
            var _this = this;
            var builder = new DialogFieldBuilder($scope);
            return [
                builder
                    .account('recipient', this.recipient)
                    .label('Counterparty HEAT account id')
                    .required()
                    .onchange(function (newValue) { return _this.onChangeRecipient($scope, newValue); }),
                builder.text('messageText', this.messageText)
                    .rows(2)
                    .required(false)
                    .label('Message'),
                builder.hidden('recipientPublicKey', this.recipientPublicKey)
            ];
        };
        CallDialog.prototype.getTransactionBuilder = function () {
            return undefined;
        };
        CallDialog.prototype.okBtn = function () {
            var _this = this;
            this.heatService.api.getPublicKey(this.fields['recipient'].value).then(function (publicKey) {
                _this.doCall(publicKey);
            }, function (reason) {
                if (reason.description) {
                    var $mdToast = heat.$inject.get('$mdToast');
                    $mdToast.show($mdToast.simple().textContent("Error: \n" + reason.description).hideDelay(5000));
                }
                else {
                    console.error(reason);
                }
            });
        };
        CallDialog.prototype.onChangeRecipient = function ($scope, newRecipient) {
            var _this = this;
            $scope.$evalAsync(function () {
                _this.okBtn['disabled'] = _this.user.account == newRecipient;
            });
        };
        CallDialog.prototype.close = function (room) {
            this.okBtn['mdDialog'].hide(room);
        };
        return CallDialog;
    }(GenericDialog));
    p2p.CallDialog = CallDialog;
})(p2p || (p2p = {}));
var ContactService = (function () {
    function ContactService(storage, heat, $q, user) {
        this.storage = storage;
        this.heat = heat;
        this.$q = $q;
        this.user = user;
        this.p2pContactStore = storage.namespace('p2pContacts');
        this.latestTimestampStore = storage.namespace('contacts.latestTimestamp');
    }
    ContactService_1 = ContactService;
    ContactService.prototype.getContacts = function (selectedContactPublicKey) {
        var _this = this;
        var localContacts = [];
        this.p2pContactStore.forEach(function (key, p2pContact) { return localContacts.push(p2pContact); });
        return this.heat.api.getMessagingContacts(this.user.account, 0, 100).then(function (contacts) {
            localContacts.forEach(function (p2pContact) {
                var existingHeatContact = contacts.find(function (contact) { return !p2pContact.publicKey || contact.publicKey == p2pContact.publicKey; });
                if (existingHeatContact) {
                    existingHeatContact.activityTimestamp = p2pContact.activityTimestamp;
                }
                else {
                    p2pContact.isP2POnlyContact = true;
                    contacts.push(p2pContact);
                }
            });
            contacts = contacts
                .filter(function (contact) { return contact.publicKey && contact.account != _this.user.account; })
                .map(function (contact) {
                if (selectedContactPublicKey != contact.publicKey) {
                    contact['hasUnreadMessage'] = !contact.isP2POnlyContact && _this.contactHasUnreadMessage(contact);
                    contact['hasUnreadP2PMessage'] = _this.contactHasUnreadP2PMessage(contact);
                }
                return contact;
            })
                .sort(function (c1, c2) {
                return (c2.activityTimestamp ? Math.abs(c2.activityTimestamp) : 0) - (c1.activityTimestamp ? Math.abs(c1.activityTimestamp) : 0);
            });
            return contacts;
        }).catch(function (reason) {
            var _a;
            console.error("Error on getting messaging contacts from server: " + (reason.description || ((_a = reason.data) === null || _a === void 0 ? void 0 : _a.errorDescription)));
            return localContacts;
        });
    };
    ContactService.prototype.saveContact = function (account, publicKey, publicName, calledTimestamp, newIncomingContact) {
        var _this = this;
        if (!publicKey)
            return;
        var save = function (publicName) {
            var contact = _this.p2pContactStore.get(account);
            if (contact && calledTimestamp && calledTimestamp != contact.activityTimestamp) {
                contact.activityTimestamp = calledTimestamp;
                _this.p2pContactStore.put(account, contact);
            }
            if (!contact) {
                contact = {
                    account: account,
                    privateName: '',
                    publicKey: publicKey,
                    publicName: publicName,
                    timestamp: 0,
                    activityTimestamp: calledTimestamp,
                    newIncomingContact: newIncomingContact
                };
                _this.p2pContactStore.put(account, contact);
            }
        };
        try {
            if (publicName) {
                save(publicName);
            }
            else {
                this.heat.api.searchPublicNames(account, 0, 100).then(function (accounts) {
                    var expectedAccount = accounts.find(function (v) { return v.publicKey == publicKey; });
                    save(expectedAccount ? expectedAccount.publicName : null);
                });
            }
            return true;
        }
        catch (e) {
            console.log("Save contact error " + e);
            if (['QuotaExceededError', 'NS_ERROR_DOM_QUOTA_REACHED'].indexOf(e.name) >= 0) {
                var p2pMessaging = heat.$inject.get('P2PMessaging');
                var room = p2pMessaging.getOneToOneRoom(publicKey, true);
                if (room) {
                    if (room.getMessageHistory().shrink(5, function () { return save(publicName); }))
                        return true;
                }
            }
        }
        return false;
    };
    ContactService.prototype.updateContactCurrencyAddress = function (account, currency, address, publicKey, publicName, calledTimeStamp) {
        if (!publicKey)
            return;
        var contact = this.p2pContactStore.get(account);
        if (!contact)
            this.saveContact(account, publicKey, publicName, calledTimeStamp);
        var currencyAddressMap = {
            name: currency,
            address: address
        };
        if (!contact.cryptoAddresses) {
            contact.cryptoAddresses = [currencyAddressMap];
        }
        else if (contact.cryptoAddresses.findIndex(function (map) { return map.name === currency; }) === -1) {
            contact.cryptoAddresses.push(currencyAddressMap);
        }
        else {
            contact.cryptoAddresses[contact.cryptoAddresses.findIndex(function (map) { return map.name === currency; })] = currencyAddressMap;
        }
        this.p2pContactStore.put(account, contact);
    };
    ContactService.prototype.lookupContact = function (query) {
        var deferred = this.$q.defer();
        var isNumbersOnly = ContactService_1.numbersOnly.test(query);
        if (isNumbersOnly) {
            deferred.resolve(this.searchContactByNumericId(query));
        }
        else {
            deferred.resolve(this.searchContactByPublicName(query));
        }
        return deferred.promise;
    };
    ContactService.prototype.searchContactByNumericId = function (query) {
        var _this = this;
        var contacts = [];
        var keys = this.p2pContactStore.keys().filter(function (key) { return key.startsWith(query); });
        keys.forEach(function (key) { return contacts.push(_this.p2pContactStore.get(key)); });
        return contacts;
    };
    ContactService.prototype.searchContactByPublicName = function (query) {
        var _this = this;
        var contacts = [];
        var keys = this.p2pContactStore.keys();
        keys.forEach(function (key) {
            var contact = _this.p2pContactStore.get(key);
            if (contact.publicName.indexOf(query) > -1) {
                contacts.push(contact);
            }
        });
        return contacts;
    };
    ContactService.prototype.shareCryptoAddress = function (contact, currency, value) {
        var _this = this;
        var validatedCurrency = currency.toLocaleLowerCase();
        this.heat.api.getKeystoreAccountEntry(this.user.account, "".concat(contact.account, "-").concat(validatedCurrency)).then(function (response) {
            var parsed = utils.parseResponse(response);
            if (parsed.errorDescription === 'Unknown key') {
                var encrypted = heat.crypto.encryptMessage(value, contact.publicKey, _this.user.secretPhrase);
                _this.heat.api.saveKeystoreEntry("".concat(contact.account, "-").concat(validatedCurrency), "".concat(encrypted.data, "-").concat(encrypted.nonce), _this.user.secretPhrase);
            }
            else {
                var split = parsed.value.split("-");
                var decrypted = heat.crypto.decryptMessage(split[0], split[1], contact.publicKey, _this.user.secretPhrase);
                if (decrypted == value) {
                    return;
                }
                else {
                    var encrypted = heat.crypto.encryptMessage(value, contact.publicKey, _this.user.secretPhrase);
                    _this.heat.api.saveKeystoreEntry("".concat(contact.account, "-").concat(validatedCurrency), "".concat(encrypted.data, "-").concat(encrypted.nonce), _this.user.secretPhrase);
                }
            }
        }).catch(function (e) {
            var parsed = utils.parseResponse(e);
            if (parsed.description === 'Unknown key') {
                var encrypted = heat.crypto.encryptMessage(value, contact.publicKey, _this.user.secretPhrase);
                _this.heat.api.saveKeystoreEntry("".concat(contact.account, "-").concat(validatedCurrency), "".concat(encrypted.data, "-").concat(encrypted.nonce), _this.user.secretPhrase);
            }
        });
    };
    ContactService.prototype.fetchCryptoAddress = function (contact, currency) {
        var _this = this;
        var validatedCurrency = currency.toLocaleLowerCase();
        this.heat.api.getKeystoreAccountEntry(contact.account, "".concat(this.user.account, "-").concat(validatedCurrency)).then(function (response) {
            var parsed = utils.parseResponse(response);
            var split = parsed.value.split("-");
            var decrypted = heat.crypto.decryptMessage(split[0], split[1], contact.publicKey, _this.user.secretPhrase);
            console.log('decrypted value: ' + decrypted);
            _this.updateContactCurrencyAddress(contact.account, currency, decrypted, contact.publicKey, contact.publicName);
        }).catch(function (e) {
            console.log("Error getting keystore value of contact ".concat(contact.account, "-").concat(validatedCurrency), e);
        });
    };
    ContactService.prototype.contactHasUnreadMessage = function (contact) {
        console.log(contact.account + " " + contact.publicName + " " + contact.timestamp + " " + this.latestTimestampStore.getNumber(contact.account, 0));
        return contact.timestamp > this.latestTimestampStore.getNumber(contact.account, 0);
    };
    ContactService.prototype.contactHasUnreadP2PMessage = function (contact) {
        var p2pMessaging = heat.$inject.get('P2PMessaging');
        var room = p2pMessaging.getOneToOneRoom(contact.publicKey, true);
        if (room) {
            return p2pMessaging.roomHasUnreadMessage(room);
        }
        return false;
    };
    var ContactService_1;
    ContactService.numbersOnly = /^[0-9]+$/;
    ContactService = ContactService_1 = __decorate([
        Service('contactService'),
        Inject('storage', 'heat', '$q', 'user'),
        __metadata("design:paramtypes", [StorageService,
            HeatService, Function, UserService])
    ], ContactService);
    return ContactService;
}());
var p2p;
(function (p2p) {
    var DEFAULT_STORAGE_SPACE_LIMIT = 5 * 1024 * 1024;
    var DO_CHECK_SPACE_THRESHOLD = 0.79;
    var CLEAR_SPACE_THRESHOLD = 0.8;
    var checkStorageSpaceEconomizer = {
        lastOccupiedShare: 0,
        skipCounter: 0,
        reset: function (occupiedShare) {
            if (occupiedShare < DO_CHECK_SPACE_THRESHOLD) {
                this.skipCounter = Math.min(33, 4 + DO_CHECK_SPACE_THRESHOLD / occupiedShare).toFixed(0);
                this.lastOccupiedShare = occupiedShare;
            }
        },
        isToSkip: function () {
            if (this.skipCounter > 0) {
                this.skipCounter--;
                return true;
            }
            return false;
        }
    };
    var MessageHistory = (function () {
        function MessageHistory(room, storage, user) {
            this.room = room;
            this.storage = storage;
            this.user = user;
            this.enabled = true;
            this.store = storage.namespace('p2p-messages.' + this.room.name);
            this.extraStore = storage.namespace('extra-p2p-messages.' + this.room.name);
            this.init();
        }
        MessageHistory.prototype.init = function () {
            this.pages = this.store.keys()
                .map(function (key) {
                var ss = key.split('.');
                return [
                    parseInt(ss[0]),
                    (ss.length > 1 ? parseInt(ss[1]) : -1),
                    (ss.length > 2 ? parseInt(ss[2]) : -1)
                ];
            })
                .sort(function (a, b) { return a[0] - b[0]; });
            for (var i = 0; i < this.pages.length; i++) {
                if (this.pages[i][1] == -1 || this.pages[i][2] == -1) {
                    var items = this.getPageMessages(i);
                    this.savePage(i, items);
                }
            }
            if (this.pages.length == 0) {
                this.pageStorageNum = 0;
                this.pages.push([0, 0]);
                this.pageContent = [];
            }
            else {
                this.pageStorageNum = this.pages[this.pages.length - 1][0];
                this.pageContent = this.getItems(this.pages.length - 1);
            }
            if (!this.pageContent) {
                this.pageContent = [];
            }
        };
        MessageHistory.prototype.getPageCount = function () {
            return this.pages.length;
        };
        MessageHistory.prototype.getPageIndexes = function () {
            return Array.from(Array(this.pages.length).keys());
        };
        MessageHistory.prototype.getItemCount = function () {
            return this.pages.map(function (v) { return v[1]; }).reduce(function (previousValue, currentValue) { return previousValue + currentValue; });
        };
        MessageHistory.prototype.getItemsScrollable = function (start, end) {
            var n = 0;
            var result = [];
            if (end <= 0) {
                return result;
            }
            start = Math.max(0, start);
            var needingLength = end - start;
            for (var i = 0; i < this.pages.length; i++) {
                var page = this.pages[i];
                n = n + page[1];
                if (n > start) {
                    var pageItems = this.getItems(i);
                    var pageStartIndex = Math.max(0, result.length > 0 ? 0 : start - (n - page[1]));
                    result = result.concat(pageItems.slice(pageStartIndex, pageStartIndex + (needingLength - result.length)));
                }
                if (result.length == needingLength) {
                    return result;
                }
            }
            return result;
        };
        MessageHistory.prototype.getItems = function (pageIndex) {
            if (pageIndex >= 0 && pageIndex < this.pages.length) {
                return this.getPageMessages(pageIndex);
            }
            return [];
        };
        MessageHistory.prototype.getItemsAll = function () {
            var result = [];
            for (var i = 0; i < this.pages.length; i++) {
                var items = this.getPageMessages(i);
                if ((items === null || items === void 0 ? void 0 : items.length) > 0) {
                    result = result.concat(items);
                }
            }
            return result;
        };
        MessageHistory.prototype.getPageMessages = function (pageIndex, page) {
            var _this = this;
            var encryptedPage = page ? page : this.store.get(this.pageKey(pageIndex));
            if (encryptedPage) {
                try {
                    var pageObject = typeof encryptedPage === "string" ? JSON.parse(encryptedPage) : encryptedPage;
                    var encrypted = pageObject.encrypted ? pageObject.encrypted : pageObject;
                    var pageContentStr = heat.crypto.decryptMessage(encrypted.data, encrypted.nonce, this.user.publicKey, this.user.secretPhrase);
                    var items = JSON.parse(pageContentStr);
                    items.forEach(function (v) { return v.extraInfo = _this.getExtraInfo(v.msgId); });
                    return items;
                }
                catch (e) {
                    console.log("Error on parse/decrypt message history page");
                }
            }
            return [];
        };
        MessageHistory.prototype.isExistingId = function (msgId) {
            return !!this.extraStore.get(msgId);
        };
        MessageHistory.prototype.put = function (item) {
            this.pageContent.push(item);
            this.savePage(this.pages.length - 1, this.pageContent);
            this.putExtraInfo(item.msgId, null);
            if (this.pageContent.length >= MessageHistory.MAX_PAGE_LENGTH) {
                this.pageContent = [];
                this.pageStorageNum++;
                this.pages.push([this.pageStorageNum, 0]);
            }
            if (this.pages.length > MessageHistory.MAX_PAGES_COUNT) {
                console.log("Remove page " + this.pageKey(0));
                this.store.remove(this.pageKey(0));
                this.pages.splice(0, 1);
            }
        };
        MessageHistory.prototype.putExtraInfo = function (msgId, data) {
            var _this = this;
            try {
                this.extraStore.put(msgId, data);
                var $rootScope = heat.$inject.get('$rootScope');
                $rootScope.$emit('OFFCHAIN_MESSAGE_EXTRA_INFO', msgId, data);
            }
            catch (e) {
                console.error("Error on saving data to the local storage " + e);
                if (['QuotaExceededError', 'NS_ERROR_DOM_QUOTA_REACHED'].indexOf(e.name) >= 0) {
                    this.shrink(5, function () { return _this.extraStore.put(msgId, data); });
                }
            }
        };
        MessageHistory.prototype.getExtraInfo = function (msgId) {
            return this.extraStore.get(msgId);
        };
        MessageHistory.prototype.remove = function (timestamp) {
            var _this = this;
            for (var i = this.pages.length - 1; i >= 0; i--) {
                var items = this.getItems(i);
                items.filter(function (item) { return item.timestamp == timestamp; }).forEach(function (m) { return _this.extraStore.remove(m.msgId); });
                var newItems = items.filter(function (item) { return item.timestamp != timestamp; });
                if (items.length != newItems.length) {
                    this.pageContent = this.pageContent.filter(function (item) { return item.timestamp != timestamp; });
                    this.savePage(i, newItems);
                    return items.length - newItems.length;
                }
            }
            return 0;
        };
        MessageHistory.prototype.clear = function () {
            this.store.clear();
            this.extraStore.clear();
            this.init();
        };
        MessageHistory.prototype.shrink = function (attempts, putData) {
            var n = attempts;
            while (n > 0) {
                try {
                    console.log("Trying to remove old messages history, attempt №" + (attempts + 1 - n));
                    this.shrinkPageStore(attempts + 1 - n);
                    if (putData)
                        putData();
                    n = 0;
                    return true;
                }
                catch (e) {
                    console.log("Error while shrinking message history " + e);
                }
                n--;
            }
            return false;
        };
        MessageHistory.prototype.savePage = function (pageIndex, pageContent) {
            var _this = this;
            var occupiedSpaceBefore = this.checkStorageSpace(true, false);
            var occupiedSpaceAfter = occupiedSpaceBefore ? this.checkStorageSpace(false, true) : null;
            if (occupiedSpaceAfter && occupiedSpaceAfter != occupiedSpaceBefore) {
                console.log("Removed data length ".concat(occupiedSpaceBefore - occupiedSpaceAfter, ", storage occupied space ").concat(occupiedSpaceAfter));
            }
            var encrypted = heat.crypto.encryptMessage(JSON.stringify(pageContent), this.user.publicKey, this.user.secretPhrase, false);
            var page = this.pages[pageIndex];
            try {
                this.store.remove(this.pageKey(pageIndex));
                page[1] = pageContent.length;
                page[2] = pageContent.length > 0 ? pageContent[pageContent.length - 1].timestamp : 0;
                this.store.put(this.pageKey(pageIndex), { encrypted: encrypted, ids: pageContent.map(function (v) { return v.msgId; }) });
            }
            catch (domException) {
                console.log("Save page error " + domException);
                if (['QuotaExceededError', 'NS_ERROR_DOM_QUOTA_REACHED'].indexOf(domException.name) >= 0) {
                    this.shrink(5, function () { return _this.store.put(_this.pageKey(pageIndex), encrypted); });
                }
            }
        };
        MessageHistory.prototype.shrinkPageStore = function (pageToRemoveNumber, allRooms) {
            var _this = this;
            if (allRooms === void 0) { allRooms = true; }
            var roomStore = allRooms ? this.storage.namespace('p2p-messages') : this.store;
            var keysByTime = roomStore.keys()
                .map(function (key) {
                var ss = key.split('.');
                return { original: key, timestamp: parseInt(ss[ss.length - 1]) };
            })
                .sort(function (a, b) { return a.timestamp - b.timestamp; });
            for (var _i = 0, keysByTime_1 = keysByTime; _i < keysByTime_1.length; _i++) {
                var k = keysByTime_1[_i];
                var key = k.original;
                var page = roomStore.get(key);
                if (page) {
                    if (page.ids) {
                        page.ids.forEach(function (id) { return _this.extraStore.remove(id); });
                    }
                    roomStore.remove(key);
                    console.log("removed page ".concat(key, " length ").concat(page.ids ? page.ids.length : "?", " in the message history"));
                }
                if ((--pageToRemoveNumber) <= 0)
                    break;
            }
        };
        MessageHistory.prototype.pageKey = function (pageIndex) {
            var page = this.pages[pageIndex];
            return page[0] + (page[1] == -1 ? "" : "." + page[1]) + (page[2] == -1 ? "" : "." + page[2]);
        };
        MessageHistory.prototype.checkStorageSpace = function (shrink, resetChecking) {
            if (shrink === void 0) { shrink = true; }
            if (resetChecking === void 0) { resetChecking = false; }
            if (checkStorageSpaceEconomizer.isToSkip())
                return null;
            var totalAmount = 0;
            var n = 0;
            for (var x in localStorage) {
                var amount = localStorage[x].length * 2;
                if (!isNaN(amount) && localStorage.hasOwnProperty(x)) {
                    totalAmount += amount;
                    n++;
                }
            }
            var occupiedShare = totalAmount / DEFAULT_STORAGE_SPACE_LIMIT;
            if (resetChecking)
                checkStorageSpaceEconomizer.reset(occupiedShare);
            if (shrink && occupiedShare > CLEAR_SPACE_THRESHOLD) {
                console.warn("Estimated occupied storage space ".concat((totalAmount / 1024 / 1024).toFixed(2), "  Entries count ").concat(n));
                this.shrink(7);
            }
            return totalAmount;
        };
        MessageHistory.MAX_PAGES_COUNT = 100;
        MessageHistory.MAX_PAGE_LENGTH = 100;
        return MessageHistory;
    }());
    p2p.MessageHistory = MessageHistory;
})(p2p || (p2p = {}));
var p2p;
(function (p2p) {
    var P2PConnector = (function () {
        function P2PConnector($interval, messenger, settings, accountPublicKey, createRoom, processIncomingCall, processError, sign, encrypt, decrypt, protocols) {
            var _this = this;
            this.$interval = $interval;
            this.messenger = messenger;
            this.settings = settings;
            this.accountPublicKey = accountPublicKey;
            this.createRoom = createRoom;
            this.processIncomingCall = processIncomingCall;
            this.processError = processError;
            this.sign = sign;
            this.encrypt = encrypt;
            this.decrypt = decrypt;
            this.protocolsMap = {};
            this.rooms = new Map();
            this.signalingMessageAwaitings = [];
            this.notAcceptedResponse = "notAcceptedResponse_@)(%$#&#&";
            this.pendingRooms = [];
            this._onlineStatus = "offline";
            this.signalingReady = null;
            this.config = {
                iceServers: [
                    {
                        urls: ["stun:stun.optdyn.com:3478",
                            "stun:stun.vavadating.com:3478",
                            "stun:stun.meowsbox.com:3478",
                            "stun:stun.voip.aebc.com:3478",
                            "stun:stun.galeriemagnet.at:3478",
                            "stun:stun.lovense.com:3478",
                            "stun:stun.verbo.be:3478",
                            "stun:stun.sipnet.ru:3478",
                            "stun:stun.eol.co.nz:3478"
                        ]
                    },
                    {
                        urls: ["stun:stun.l.google.com:19302",
                            "stun:stun1.l.google.com:19302",
                            "stun:stun2.l.google.com:19302",
                            "stun:stun3.l.google.com:19302",
                            "stun:stun4.l.google.com:19302",
                            "stun:stun.ekiga.net",
                            "stun:stun.ideasip.com",
                            "stun:stun.rixtelecom.se",
                            "stun:stun.schlund.de",
                            "stun:stun.stunprotocol.org:3478",
                            "stun:stun.voiparound.com",
                            "stun:stun.voipbuster.com",
                            "stun:stun.voipstunt.com",
                            "stun:stun.voxgratia.org"]
                    }
                ],
            };
            protocols.forEach(function (p) {
                p.connector = _this;
                _this.protocolsMap[p.name] = p;
            });
        }
        P2PConnector.prototype.setOnlineStatus = function (status) {
            var _this = this;
            var sendOnlineStatus = function () {
                _this.sendWebsocketMessage("signaling", [{ type: "SET_ONLINE_STATUS", status: status }]);
                if (status == "online") {
                    _this.rooms.forEach(function (room) {
                        if (room.state.entered == "entered") {
                            room.enter(true);
                        }
                    });
                }
            };
            if (this.identity) {
                sendOnlineStatus();
            }
            else {
                this.sendWebsocketMessage("signaling", [{ type: "WANT_PROVE_IDENTITY" }]);
                this.pendingOnlineStatus = sendOnlineStatus;
            }
            if (status == "offline") {
                this.identity = null;
                this.close();
            }
            this._onlineStatus = status;
        };
        Object.defineProperty(P2PConnector.prototype, "onlineStatus", {
            get: function () {
                return this._onlineStatus;
            },
            enumerable: false,
            configurable: true
        });
        P2PConnector.prototype.getPeerOnlineStatus = function (peerId) {
            var _this = this;
            return this.request(function () { return _this.sendWebsocketMessage("signaling", [{ type: "GET_ONLINE_STATUS", peerId: peerId }]); }, function (msg) {
                if (msg.type === "ONLINE_STATUS" && msg.peerId == peerId)
                    return msg.status;
                return _this.notAcceptedResponse;
            });
        };
        P2PConnector.prototype.call = function (toPeerId, caller, room) {
            this.sendWebsocketMessage("signaling", [{ type: "CALL", toPeerId: toPeerId, caller: caller, room: room.name }]);
        };
        P2PConnector.prototype.getTmp = function (roomName) {
            var _this = this;
            return this.request(function () { return _this.sendWebsocketMessage("signaling", [{ type: "WHO_ONLINE" }]); }, function (msg) {
                if (msg.type === "WHO_ONLINE")
                    return msg.remotePeerIds;
                return _this.notAcceptedResponse;
            });
        };
        P2PConnector.prototype.enter = function (room, enforce) {
            var _this = this;
            var existingRoom = this.rooms.get(room.name);
            if (existingRoom && existingRoom.state.entered == "entered") {
                if (enforce) {
                    existingRoom.state.entered = "not";
                }
                else {
                    return;
                }
            }
            var requestEnterRoom = function () {
                room.state.approved = true;
                if (room.state.entered == "not") {
                    room.state.entered = "entering";
                    setTimeout(function () {
                        if (room.state.entered != "entered") {
                            room.state.entered = "not";
                        }
                    }, 4000);
                    _this.sendWebsocketMessage("signaling", [{ type: "ROOM", room: room.name }]);
                }
            };
            this.rooms.set(room.name, room);
            if (this.identity) {
                requestEnterRoom();
            }
            else {
                this.pendingRooms.push(requestEnterRoom);
                this.sendWebsocketMessage("signaling", [{ type: "WANT_PROVE_IDENTITY" }]);
                return;
            }
        };
        P2PConnector.prototype.getWebSocket = function () {
            var _this = this;
            if (!this.webSocketPromise || this.signalingReady === false) {
                this.webSocketPromise = new Promise(function (resolve, reject) {
                    var url = _this.settings.get(SettingsService.HEAT_MESSAGING).websocket;
                    var socket = new WebSocket(url);
                    socket.onopen = function () {
                        socket.onmessage = function (msg) { return _this.onWebsocketMessage(msg); };
                        socket.onclose = function () { return _this.onSignalingClosed(); };
                        _this.signalingReady = true;
                        if (_this.pingSignalingInterval) {
                            _this.$interval.cancel(_this.pingSignalingInterval);
                        }
                        _this.pingSignalingInterval = _this.$interval(function () {
                            _this.pingSignalingServer(socket);
                        }, 120 * 1000, 0, false);
                        resolve(socket);
                    };
                    socket.onerror = function (error) {
                        console.error(error);
                        reject(error);
                        _this.webSocketPromise = null;
                    };
                });
            }
            return this.webSocketPromise;
        };
        P2PConnector.prototype.pingSignalingServer = function (socket) {
            if (this.signalingReady) {
                this.sendWebsocketMessage("signaling", [{ type: "PING" }]);
            }
        };
        P2PConnector.prototype.sendWebsocketMessage = function (protocol, data) {
            if (protocol === void 0) { protocol = "signaling"; }
            return this.getWebSocket()
                .then(function (websocket) {
                var sendingData = [protocol].concat(data);
                websocket.send(JSON.stringify(sendingData));
            }, function (reason) { return console.error(reason); })
                .catch(function (reason) {
                console.error("error on get websocket \n" + reason);
            });
        };
        P2PConnector.prototype.onWebsocketMessage = function (messageEvent) {
            if (this._onlineStatus == "offline") {
                return;
            }
            var originalData = JSON.parse(messageEvent.data);
            var protocolName;
            var data;
            if (Array.isArray(originalData)) {
                protocolName = originalData[0];
                data = originalData[1];
            }
            else {
                protocolName = "";
                data = originalData;
            }
            var msg;
            if (data.encrypted) {
                var decrypted = this.decrypt(data.encrypted, data.fromPeer);
                msg = JSON.parse(decrypted);
                msg.fromPeer = data.fromPeer;
                msg.toPeer = data.toPeer;
                msg.room = data.room;
            }
            else {
                msg = data;
            }
            var roomName = msg.room;
            var protocol = this.protocolsMap[protocolName];
            if (protocol) {
                protocol.handle(msg.type, roomName, msg);
            }
            else {
                this.signalingMessageAwaitings.forEach(function (f) { return f(msg); });
            }
        };
        P2PConnector.prototype.onSignalingClosed = function () {
            this.signalingReady = false;
            this.$interval.cancel(this.pingSignalingInterval);
        };
        P2PConnector.prototype.askPeerConnection = function (roomName, peerId) {
            var _this = this;
            var peer = this.rooms.get(roomName).getPeer(peerId);
            var pc = peer.peerConnection;
            if (pc && pc.iceConnectionState != "connected" && pc.iceConnectionState != "completed") {
                pc.close();
                pc = null;
            }
            try {
                pc = new RTCPeerConnection(this.config);
                pc.onicecandidate = function (event) {
                    if (event.candidate) {
                        var data = {
                            type: 'candidate',
                            label: event.candidate.sdpMLineIndex,
                            id: event.candidate.sdpMid,
                            candidate: event.candidate.candidate
                        };
                        var encrypted = _this.encrypt(JSON.stringify(data), peerId);
                        _this.sendWebsocketMessage("signaling", [
                            { room: roomName, toPeerId: peerId },
                            { room: roomName, fromPeer: _this.identity, encrypted: encrypted }
                        ]);
                    }
                };
                pc.ondatachannel = function (event) {
                    var dataChannel = event.channel;
                    _this.initDataChannel(roomName, peerId, dataChannel, true);
                    peer.dataChannel = dataChannel;
                };
                pc.oniceconnectionstatechange = function (event) {
                    if (pc.iceConnectionState == "failed") {
                        console.log("iceConnectionState failed");
                    }
                    if (pc.iceConnectionState == 'disconnected') {
                        if (peer.dataChannel) {
                            peer.dataChannel.close();
                            _this.onCloseDataChannel(roomName, peerId, peer.dataChannel);
                        }
                        console.log('Peer is disconnected');
                    }
                };
                pc.onicecandidateerror = function (event) {
                    console.error("".concat(event.errorCode, "  ").concat(event.hostCandidate, "  ").concat(event.url, "  ").concat(event.errorText));
                };
                peer.peerConnection = pc;
                return pc;
            }
            catch (e) {
                console.error(e);
                pc = null;
                return;
            }
        };
        P2PConnector.prototype.initDataChannel = function (roomName, peerId, dataChannel, sendCheckingMessage) {
            var _this = this;
            dataChannel.onopen = function (event) { return _this.onOpenDataChannel(roomName, peerId, dataChannel, sendCheckingMessage); };
            dataChannel.onclose = function (event) { return _this.onCloseDataChannel(roomName, peerId, dataChannel); };
            dataChannel.onmessage = function (event) { return _this.onMessage(roomName, peerId, dataChannel, event); };
            this.rooms.get(roomName).getPeer(peerId).dataChannel = dataChannel;
        };
        P2PConnector.prototype.onOpenDataChannel = function (roomName, peerId, dataChannel, sendCheckingMessage) {
            if (sendCheckingMessage) {
                var checkChannelMessage = { type: P2PConnector.MSG_TYPE_CHECK_CHANNEL, room: roomName, value: ("" + Math.random()) };
                this.sendWebsocketMessage("signaling", [checkChannelMessage]);
                this.send(roomName, JSON.stringify(checkChannelMessage), dataChannel);
            }
            var room = this.rooms.get(roomName);
            if (room.onOpenDataChannel) {
                room.onOpenDataChannel(peerId);
            }
            room.getPeer(peerId).dataChannel = dataChannel;
            var dataHex = converters.stringToHexString(randomString());
            if (!room["proofData"])
                room["proofData"] = {};
            room["proofData"][peerId] = dataHex;
            var signedData = this.sign(dataHex);
            var proofRequest = { type: P2PConnector.MSG_TYPE_REQUEST_PROOF_IDENTITY,
                signature: signedData.signatureHex, data: signedData.dataHex, publicKey: signedData.publicKeyHex };
            this.send(roomName, JSON.stringify(proofRequest), dataChannel);
        };
        P2PConnector.prototype.onCloseDataChannel = function (roomName, peerId, dataChannel) {
            var room = this.rooms.get(roomName);
            room.getPeer(peerId).dataChannel = null;
            if (room && room.onCloseDataChannel)
                room.onCloseDataChannel(peerId);
        };
        P2PConnector.prototype.createDataChannel = function (room, peerId, peerConnection, role) {
            var dataChannel;
            try {
                dataChannel = peerConnection.createDataChannel(room + ":" + peerId, null);
            }
            catch (e) {
                console.error('error creating data channel ' + e);
                return;
            }
            this.initDataChannel(room, peerId, dataChannel);
        };
        P2PConnector.prototype.onFailure = function (roomName, peerId, e) {
            var room = this.rooms.get(roomName);
            if (room.onFailure)
                room.onFailure(peerId, e);
        };
        P2PConnector.prototype.doOffer = function (roomName, peerId, peerConnection) {
            var _this = this;
            console.log("do offer");
            var peer = this.rooms.get(roomName).getPeer(peerId);
            peer['connectionRole'] = 'offer';
            this.createDataChannel(roomName, peerId, peerConnection, "caller");
            peerConnection.createOffer(function (offer) {
                peerConnection.setLocalDescription(offer, function () {
                    var encrypted = _this.encrypt(JSON.stringify(peerConnection.localDescription), peerId);
                    _this.sendWebsocketMessage("signaling", [
                        { room: roomName, toPeerId: peerId, fromPeer: _this.identity, encrypted: encrypted }
                    ]);
                }, function (e) { return _this.onFailure(roomName, peerId, e); });
            }, function (e) { return _this.onFailure(roomName, peerId, e); }, null);
        };
        P2PConnector.prototype.doAnswer = function (roomName, peerId, peerConnection) {
            var _this = this;
            console.log("do answer");
            var peer = this.rooms.get(roomName).getPeer(peerId);
            peer['connectionRole'] = peer['connectionRole'] ? 'no need' : 'answer';
            peerConnection.createAnswer(function (answer) {
                peerConnection.setLocalDescription(answer, function () {
                    var encrypted = _this.encrypt(JSON.stringify(peerConnection.localDescription), peerId);
                    _this.sendWebsocketMessage("signaling", [
                        { room: roomName, toPeerId: peerId, fromPeer: _this.identity, encrypted: encrypted }
                    ]);
                }, function (e) { return _this.onFailure(roomName, peerId, e); });
            }, function (e) { return _this.onFailure(roomName, peerId, e); });
        };
        P2PConnector.prototype.sendMessage = function (roomName, message) {
            var result = this.send(roomName, message);
            message.transport = result.transport;
            return result;
        };
        P2PConnector.prototype.send = function (roomName, msg, channel) {
            var room = this.rooms.get(roomName);
            var peers = Array.from(room.getAllPeers().values());
            var result = { count: 0, transport: null };
            for (var _i = 0, peers_1 = peers; _i < peers_1.length; _i++) {
                var peer = peers_1[_i];
                if ((channel && peer.dataChannel == channel) || (!channel && peer.dataChannel && peer.dataChannel.readyState == "open")) {
                    var encryptingData = void 0;
                    if (typeof msg === "string") {
                        encryptingData = msg;
                    }
                    else {
                        if (msg.type == "file") {
                            var fileContent = msg.data;
                            msg.data = this.encrypt(msg.data, peer.publicKey);
                        }
                        encryptingData = JSON.stringify(msg);
                    }
                    var encrypted = this.encrypt(encryptingData, peer.publicKey);
                    result.transport = 'p2p';
                    result.count = this.sendRTCChannelMessage(peer.dataChannel, JSON.stringify(encrypted));
                }
                else {
                    var sendingData = void 0;
                    if (typeof msg === "string") {
                        sendingData = this.encrypt(msg, peer.publicKey);
                    }
                    else {
                        var encrypted = this.encrypt(JSON.stringify(msg), peer.publicKey);
                        sendingData = {
                            id: msg.id,
                            type: msg.type,
                            room: room.name,
                            sender: this.identity,
                            recipient: peer.publicKey,
                            payload: JSON.stringify(encrypted),
                        };
                    }
                    result.transport = 'server';
                    this.sendWebsocketMessage("U2U", [sendingData]);
                }
            }
            return result;
        };
        P2PConnector.prototype.sendRTCChannelMessage = function (channel, data) {
            var notSentReason;
            if (channel.readyState == "open") {
                try {
                    channel.send(data);
                    return 1;
                }
                catch (e) {
                    notSentReason = e.toString();
                }
            }
            else {
                notSentReason = "Channel state " + channel.readyState;
            }
            if (notSentReason) {
                console.log("Not sent: " + notSentReason);
            }
            return 0;
        };
        P2PConnector.prototype.onMessage = function (roomName, peerId, dataChannel, event) {
            try {
                var encrypted = JSON.parse(event.data);
                var msg = JSON.parse(this.decrypt(encrypted, peerId));
                msg.transport = "p2p";
                var room = this.rooms.get(roomName);
                if (room) {
                    this.processRoomMessage(msg, room, peerId);
                }
                if (msg.type === P2PConnector.MSG_TYPE_CHECK_CHANNEL) {
                    this.sendWebsocketMessage("signaling", [{ room: roomName }, msg]);
                }
                else if (msg.type === P2PConnector.MSG_TYPE_REQUEST_PROOF_IDENTITY) {
                    var signedData = this.sign(msg.data);
                    var response = { type: P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY,
                        signature: signedData.signatureHex, data: signedData.dataHex, publicKey: signedData.publicKeyHex };
                    this.send(roomName, JSON.stringify(response), dataChannel);
                }
                else if (msg.type === P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY) {
                    if (msg.rejected) {
                        if (room.onRejected) {
                            room.onRejected(peerId, msg.rejected);
                        }
                        console.log("Peer ".concat(peerId, " rejected channel to him"));
                        dataChannel.close();
                        return;
                    }
                    var rejectedReason = void 0;
                    if (room["proofData"][peerId] !== msg.data) {
                        rejectedReason = "Received data does not match the sent data";
                    }
                    else if (msg.publicKey !== peerId) {
                        rejectedReason = "Received public key does not match the peer's public key";
                    }
                    else if (room.memberPublicKeys.indexOf(msg.publicKey) == -1) {
                        rejectedReason = "Received public key is not allowed";
                    }
                    if (rejectedReason) {
                        var response = { type: P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY, rejected: rejectedReason };
                        this.send(roomName, JSON.stringify(response), dataChannel);
                        dataChannel.close();
                        return;
                    }
                    if (heat.crypto.verifyBytes(msg.signature, msg.data, msg.publicKey)) {
                        delete room["proofData"][peerId];
                        console.log("PROOF_IDENTITY ok: \n" + msg.signature + " " + msg.data + " " + msg.publicKey);
                        if (!room.provenPublicKeyAllowed(room, peerId, msg.publicKey)) {
                            var response = { type: P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY, rejected: "Public key owner is not allowed to connect" };
                            this.send(roomName, JSON.stringify(response), dataChannel);
                            dataChannel.close();
                        }
                    }
                    else {
                        var response = { type: P2PConnector.MSG_TYPE_REQUEST_PROOF_IDENTITY, rejected: "Invalid signature" };
                        this.send(roomName, JSON.stringify(response), dataChannel);
                        dataChannel.close();
                    }
                }
            }
            catch (e) {
                console.error(e);
            }
        };
        P2PConnector.prototype.processRoomMessage = function (msg, room, sender) {
            msg.fromPeerId = sender;
            msg.roomName = room.name;
            room.onMessageInternal(msg);
            this.messenger.onMessage(msg, room);
        };
        P2PConnector.prototype.closeRoom = function (room) {
            var dataChannels = room.getDataChannels();
            dataChannels.forEach(function (channel) { return channel.close(); });
        };
        P2PConnector.prototype.close = function (closeWebsocket) {
            var _this = this;
            this.identity = null;
            this.pendingRooms = [];
            this.pendingOnlineStatus = null;
            this.rooms.forEach(function (room) { return _this.closeRoom(room); });
            if ((closeWebsocket === undefined || closeWebsocket) && this.signalingReady) {
                this.getWebSocket().then(function (socket) { return socket.close(); });
            }
        };
        P2PConnector.prototype.request = function (request, handleResponse) {
            var _this = this;
            var p = new Promise(function (resolve, reject) {
                var f = function (msg) {
                    var v = handleResponse(msg);
                    if (v !== _this.notAcceptedResponse) {
                        resolve(v);
                        var i = _this.signalingMessageAwaitings.indexOf(f);
                        if (i !== -1)
                            _this.signalingMessageAwaitings.splice(i, 1);
                    }
                };
                _this.signalingMessageAwaitings.push(f);
                return request();
            });
            return promiseTimeout(3000, p);
        };
        P2PConnector.MSG_TYPE_CHECK_CHANNEL = "CHECK_CHANNEL";
        P2PConnector.MSG_TYPE_REQUEST_PROOF_IDENTITY = "GET_PROOF_IDENTITY";
        P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY = "PROOF_IDENTITY";
        return P2PConnector;
    }());
    p2p.P2PConnector = P2PConnector;
    function promiseTimeout(ms, promise) {
        return new Promise(function (resolve, reject) {
            var timer = setTimeout(function () {
                reject(new Error("promise timeout"));
            }, ms);
            promise
                .then(function (res) {
                clearTimeout(timer);
                resolve(res);
            })
                .catch(function (err) {
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    function randomString() {
        return Math.random().toString(36).substr(2);
    }
})(p2p || (p2p = {}));
var P2PMessaging = (function (_super) {
    __extends(P2PMessaging, _super);
    function P2PMessaging(settings, user, storage, $interval, heat, $mdToast, contactService, env) {
        var _this = _super.call(this) || this;
        _this.settings = settings;
        _this.user = user;
        _this.storage = storage;
        _this.$interval = $interval;
        _this.heat = heat;
        _this.$mdToast = $mdToast;
        _this.contactService = contactService;
        _this.env = env;
        _this.hasUnreadMessage = false;
        _this.onServerMessageExistsCallbacks = new Map();
        _this.roomMessagesAccumulator = [];
        _this.displayNewMessagePopupDebounced = utils.debounce(function (roomMessages, heat) {
            if (roomMessages.length == 1) {
                var msg = roomMessages[0].msg;
                if ((msg.type == "chat" || msg.type == "file") && msg.text) {
                    var account = heat.crypto.getAccountIdFromPublicKey(msg.fromPeerId);
                    var text = msg.text.substring(0, 50);
                    if (msg.text.length > 50) {
                        var lastSpaceIndex = Math.max(text.lastIndexOf(" "), 30);
                        text = text.substring(0, lastSpaceIndex) + " ...";
                    }
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("New message from ".concat(account, ": \"").concat(text, "\"")).hideDelay(6000));
                }
                else if (msg.type == "contactUpdate") {
                    var parsedMessage_1 = JSON.parse(msg.text);
                    var account_1 = heat.crypto.getAccountIdFromPublicKey(msg.fromPeerId);
                    var publicKey_1 = msg.fromPeerId;
                    _this.heat.api.searchPublicNames(account_1, 0, 100).then(function (accounts) {
                        var expectedAccount = accounts.find(function (value) { return value.publicKey == publicKey_1; });
                        if (expectedAccount) {
                            var contactUtils = heat.$inject.get('contactService');
                            contactUtils.updateContactCurrencyAddress(account_1, parsedMessage_1.name, parsedMessage_1.address, publicKey_1, expectedAccount.publicName, -Date.now());
                        }
                    });
                }
            }
            else if (roomMessages.length > 1) {
                _this.$mdToast.show(_this.$mdToast.simple().textContent("".concat(roomMessages.length, " new messages")).hideDelay(6000));
            }
            roomMessages.length = 0;
        }, 1000, false);
        _this.sendKeys = function (room, text) {
            room.sendMessage(new p2p.U2UMessage("contactUpdate", Date.now(), text));
        };
        var closeConnector = function () {
            if (_this.connector) {
                _this.connector.close(true);
                _this.connector = null;
            }
        };
        _this.p2pContactStore = storage.namespace('p2pContacts');
        _this.seenP2PMessageTimestampStore = storage.namespace('contacts.seenP2PMessageTimestamp');
        user.on(UserService.EVENT_UNLOCKED, function () {
            closeConnector();
            var protocols = [
                _this.baseProtocol = new p2p.BaseProtocol(),
                _this.u2uProtocol = new p2p.U2UProtocol(),
                _this.signalingProtocol = new p2p.SignalingProtocol()
            ];
            _this.connector = new p2p.P2PConnector($interval, _this, settings, _this.user.publicKey, function (roomName, peerId) { return _this.createRoomOnIncomingCall(roomName, peerId); }, function (peerId) { return _this.processIncomingCall(peerId); }, function (reason, protocol) { return _this.onError(reason, protocol); }, function (dataHex) { return _this.sign(dataHex); }, function (message, peerPublicKey) { return _this.encrypt(message, peerPublicKey); }, function (message, peerPublicKey) { return _this.decrypt(message, peerPublicKey); }, protocols);
            _this.connector.setOnlineStatus("online");
            _this.enterRoom(_this.user.publicKey);
        });
        user.on(UserService.EVENT_LOCKED, closeConnector);
        return _this;
    }
    P2PMessaging_1 = P2PMessaging;
    P2PMessaging.prototype.encrypt = function (message, recipientPublicKey) {
        if (message instanceof ArrayBuffer) {
            var options = {
                publicKey: converters.hexStringToByteArray(recipientPublicKey),
                privateKey: converters.hexStringToByteArray(heat.crypto.getPrivateKey(this.user.secretPhrase))
            };
            return heat.crypto.encryptBinary(message, options);
        }
        return heat.crypto.encryptMessage(message, recipientPublicKey, this.user.secretPhrase, false);
    };
    P2PMessaging.prototype.decrypt = function (message, peerPublicKey) {
        if (message.isText) {
            return heat.crypto.decryptMessage(message.data, message.nonce, peerPublicKey, this.user.secretPhrase, false);
        }
        return heat.crypto.decryptBinary(message.data, message.nonce, peerPublicKey, this.user.secretPhrase, false);
    };
    P2PMessaging.prototype.onMessage = function (msg, room) {
        var _this = this;
        this.emit(P2PMessaging_1.EVENT_NEW_MESSAGE, msg, room);
        this.seenP2PMessageTimestampStore.put(room.name + "_last-message-time", Date.now());
        this.updateSeenTime(null);
        this.displayNewMessagePopup(msg, room);
        this.contactService.getContacts().then(function (contacts) {
            var c = contacts.find(function (v) { return v.publicKey == msg.fromPeerId; });
            if (!c) {
                var senderAccount = heat.crypto.getAccountIdFromPublicKey(msg.fromPeerId);
                if (senderAccount) {
                    _this.contactService.saveContact(senderAccount, msg.fromPeerId, null, -Date.now(), true);
                }
            }
        }).catch(function (reason) { return console.error(reason); });
    };
    P2PMessaging.prototype.sendFile = function (messageId, file, recipientPublicKey) {
        var _this = this;
        if (this.env.isBrowser()) {
            return file.arrayBuffer().then(function (arrayBuffer) {
                var encrypted = _this.encrypt(arrayBuffer, recipientPublicKey);
                var encryptedBuffer = converters.stringToArrayBuffer(JSON.stringify(encrypted));
                return _this.heat.api.uploadFile(messageId, encryptedBuffer);
            }).catch(function (reason) {
                var _a;
                _this.$mdToast.show(_this.$mdToast.simple().textContent("Error on file uploading: ".concat((reason === null || reason === void 0 ? void 0 : reason.description) || ((_a = reason === null || reason === void 0 ? void 0 : reason.data) === null || _a === void 0 ? void 0 : _a.errorDescription))).hideDelay(6000));
            });
        }
        else {
            var p = new Promise(function (resolve, reject) {
                var fs = require("fs");
                fs.readFile(file.path, function (err, data) {
                    if (err)
                        reject(err);
                    else
                        resolve(data.buffer);
                });
            });
            return p.then(function (arrayBuffer) {
                var encrypted = _this.encrypt(arrayBuffer, recipientPublicKey);
                var encryptedBuffer = converters.stringToArrayBuffer(JSON.stringify(encrypted));
                return _this.heat.api.uploadFile(messageId, encryptedBuffer);
            }).catch(function (reason) {
                var _a;
                _this.$mdToast.show(_this.$mdToast.simple().textContent("Error on file uploading: ".concat((reason === null || reason === void 0 ? void 0 : reason.description) || ((_a = reason === null || reason === void 0 ? void 0 : reason.data) === null || _a === void 0 ? void 0 : _a.errorDescription))).hideDelay(6000));
            });
        }
    };
    P2PMessaging.prototype.onFile = function (fileContent, room, fileTransferMessageId, fileDescriptor, fileSavedCallback) {
        var _this = this;
        var encryptedMessage = typeof fileContent === "string"
            ? JSON.parse(fileContent)
            : JSON.parse(converters.arrayBufferToString(fileContent));
        var buffer = this.decrypt(encryptedMessage, fileDescriptor.fileSender);
        dialogs.confirm("Save file", "Note the file will be deleted on the server after you confirm this.<br>Do you want to save the file on your device?").then(function () {
            saveAs(new Blob([buffer], { type: "text/text" }), fileDescriptor.fileName);
            setTimeout(function () {
                _this.u2uProtocol.sendFileIsReceived(fileTransferMessageId);
                var extraInfo = room.getMessageHistory().getExtraInfo(fileTransferMessageId);
                if (extraInfo) {
                    extraInfo.status.fileIndicator = 2;
                }
                else {
                    extraInfo = { status: { stage: 2, fileIndicator: 2 } };
                }
                room.getMessageHistory().putExtraInfo(fileTransferMessageId, extraInfo);
                if (fileSavedCallback)
                    fileSavedCallback();
            }, 250);
        });
    };
    P2PMessaging.prototype.onServerMessageRemoved = function (messages) {
        messages.filter(function (v) { return !v.error; });
        this.$mdToast.show(this.$mdToast.simple().textContent("".concat(messages.length, " messages have been deleted on the server")).hideDelay(9000));
    };
    P2PMessaging.prototype.onServerMessageExists = function (targetMessageId, message, file) {
        var callback = this.onServerMessageExistsCallbacks.get(targetMessageId);
        if (callback)
            callback(message, file);
    };
    P2PMessaging.prototype.onError = function (reason, protocol) {
        if (protocol == "U2U") {
            this.$mdToast.show(this.$mdToast.simple().textContent("Error: ".concat(reason)).hideDelay(9000));
        }
        else {
            console.error("Messaging error: ".concat(reason, "\n Protocol: ").concat(protocol));
        }
    };
    P2PMessaging.prototype.displayNewMessagePopup = function (msg, room) {
        this.roomMessagesAccumulator.push({ msg: msg, room: room });
        this.displayNewMessagePopupDebounced(this.roomMessagesAccumulator, heat);
    };
    Object.defineProperty(P2PMessaging.prototype, "onlineStatus", {
        get: function () {
            return this.connector.onlineStatus;
        },
        set: function (status) {
            this.connector.setOnlineStatus(status);
        },
        enumerable: false,
        configurable: true
    });
    P2PMessaging.prototype.getOneToOneRoom = function (peerId, required) {
        var roomName = this.generateOneToOneRoomName(this.user.publicKey, peerId);
        var room = this.connector.rooms.get(roomName);
        if (!room && required) {
            room = this.setupRoom(new p2p.Room(roomName, this.connector, this.storage, this.user, [peerId]));
            this.connector.rooms.set(roomName, room);
        }
        if (room && room.getAllPeers().size <= 1) {
            return room;
        }
    };
    P2PMessaging.prototype.enterRoom = function (peerId) {
        if (this.onlineStatus == "offline") {
            return null;
        }
        var roomName = this.generateOneToOneRoomName(this.user.publicKey, peerId);
        var room = this.connector.rooms.get(roomName);
        if (!room) {
            room = this.setupRoom(new p2p.Room(roomName, this.connector, this.storage, this.user, [peerId]));
            this.connector.rooms.set(roomName, room);
        }
        if (room.state.entered == "not") {
            room.enter();
        }
        return room;
    };
    P2PMessaging.prototype.requestNewContact = function (recipient, text) {
        var room = this.enterRoom(recipient);
        this.u2uProtocol.requestNewContact(recipient, this.user.publicKey, room, text);
        return room;
    };
    P2PMessaging.prototype.sign = function (dataHex) {
        var signature = heat.crypto.signBytes(dataHex, converters.stringToHexString(this.user.secretPhrase));
        return { signatureHex: signature, dataHex: dataHex, publicKeyHex: this.user.publicKey };
    };
    P2PMessaging.prototype.setupRoom = function (room) {
        var _this = this;
        room.onOpenDataChannel = function (peerId) {
            _this.emit(P2PMessaging_1.EVENT_ON_OPEN_DATA_CHANNEL, room, peerId);
        };
        room.onCloseDataChannel = function (peerId) {
            _this.emit(P2PMessaging_1.EVENT_ON_CLOSE_DATA_CHANNEL, room, peerId);
        };
        room.lastIncomingMessageTimestamp = this.seenP2PMessageTimestampStore.getNumber(room.name + "_last-message-time", 0);
        return room;
    };
    P2PMessaging.prototype.generateOneToOneRoomName = function (peerOnePublicKey, peerTwoPublicKey) {
        var arr = [heat.crypto.getAccountIdFromPublicKey(peerOnePublicKey), heat.crypto.getAccountIdFromPublicKey(peerTwoPublicKey)];
        arr.sort();
        return arr[0] + "-" + arr[1];
    };
    P2PMessaging.prototype.createRoomOnIncomingCall = function (roomName, peerId) {
        var room = this.connector.rooms.get(roomName);
        if (!room) {
            room = this.setupRoom(new p2p.Room(roomName, this.connector, this.storage, this.user, [peerId]));
            this.connector.rooms.set(roomName, room);
        }
        return room;
    };
    P2PMessaging.prototype.processIncomingCall = function (callerPublicKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.isPeerConnected(callerPublicKey)) {
                resolve();
                return;
            }
            var callerAccount = heat.crypto.getAccountIdFromPublicKey(callerPublicKey);
            var updateContactCallTime = function (account, publicKey, publicName) {
                _this.contactService.saveContact(callerAccount, callerPublicKey, publicName, -Date.now());
            };
            _this.heat.api.searchPublicNames(callerAccount, 0, 100).then(function (accounts) {
                var expectedAccount = accounts.find(function (value) { return value.publicKey == callerPublicKey; });
                var caller = expectedAccount ? expectedAccount.publicName : callerAccount;
                var closeDialogOnConnected = function (mdDialog) {
                    var interval = _this.$interval(function () {
                        if (_this.isPeerConnected(callerPublicKey)) {
                            mdDialog.cancel("Already connected");
                            _this.$interval.cancel(interval);
                            updateContactCallTime(callerAccount, callerPublicKey, caller);
                        }
                    }, 500, 7, false);
                };
                var notes = expectedAccount ? null : "Note the caller has no registered in the blockchain";
                dialogs.confirm("Incoming connect request", "Account &nbsp;&nbsp;<b>".concat(caller, "</b>&nbsp;&nbsp; wants to connect with you.\n           Accepting connection will share your current IP address.\n           <p><strong>Accept or decline?</strong> Click OK to accept, Cancel to decline.</p>\n           ").concat(notes || ""), closeDialogOnConnected).then(function () {
                    updateContactCallTime(callerAccount, callerPublicKey, expectedAccount ? expectedAccount.publicName : null);
                    resolve();
                });
            });
        });
    };
    P2PMessaging.prototype.dialog = function ($event, recipient, recipientPublicKey, messageText) {
        return new p2p.CallDialog($event, this.heat, this.user, recipient, recipientPublicKey, messageText, this);
    };
    P2PMessaging.prototype.isPeerConnected = function (peerId) {
        var room = this.getOneToOneRoom(peerId);
        if (room) {
            var peer = room.getPeer(peerId);
            return peer && peer.isConnected();
        }
        return false;
    };
    P2PMessaging.prototype.roomHasUnreadMessage = function (room) {
        return room.lastIncomingMessageTimestamp > this.seenP2PMessageTimestampStore.getNumber(room.name, 0);
    };
    P2PMessaging.prototype.updateSeenTime = function (roomName, timestamp) {
        var _this = this;
        if (roomName) {
            this.seenP2PMessageTimestampStore.put(roomName, timestamp ? timestamp : Date.now() - 500);
        }
        var unreadRooms = [];
        this.connector.rooms.forEach(function (room) {
            if (_this.roomHasUnreadMessage(room)) {
                unreadRooms.push(room);
            }
        });
        var nowHasUnreadMessage = unreadRooms.length > 0;
        if (nowHasUnreadMessage != this.hasUnreadMessage) {
            this.hasUnreadMessage = nowHasUnreadMessage;
            this.emit(P2PMessaging_1.EVENT_HAS_UNREAD_CHANGED, unreadRooms);
        }
    };
    P2PMessaging.prototype.checkToRemoveServerMessage = function (messageType, outgoing, transport, targetMessageId, extraInfo) {
        var _a;
        if (outgoing && (transport == "server" || messageType == "file")) {
            if (messageType == "file" || !extraInfo || ((_a = extraInfo.status) === null || _a === void 0 ? void 0 : _a.stage) != 1) {
                this.u2uProtocol.sendRemoveMessage(targetMessageId);
            }
        }
    };
    P2PMessaging.prototype.requestIsMessageExists = function (messageType, outgoing, transport, targetMessageId, extraInfo, callback) {
        var _this = this;
        var _a;
        if (outgoing && (transport == "server" || messageType == "file")) {
            if (messageType == "file" || !extraInfo || ((_a = extraInfo.status) === null || _a === void 0 ? void 0 : _a.stage) != 1) {
                this.onServerMessageExistsCallbacks.set(targetMessageId, callback);
                setTimeout(function () { return _this.onServerMessageExistsCallbacks.delete(targetMessageId); }, 12000);
                this.u2uProtocol.requestIsMessageExists(targetMessageId);
                return;
            }
        }
        callback(null, null);
    };
    var P2PMessaging_1;
    P2PMessaging.EVENT_NEW_MESSAGE = 'EVENT_NEW_MESSAGE';
    P2PMessaging.EVENT_HAS_UNREAD_CHANGED = 'EVENT_HAS_UNREAD_CHANGED';
    P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL = 'EVENT_ON_OPEN_DATA_CHANNEL';
    P2PMessaging.EVENT_ON_CLOSE_DATA_CHANNEL = 'EVENT_ON_CLOSE_DATA_CHANNEL';
    P2PMessaging = P2PMessaging_1 = __decorate([
        Service('P2PMessaging'),
        Inject('settings', 'user', 'storage', '$interval', 'heat', '$mdToast', 'contactService', 'env'),
        __metadata("design:paramtypes", [SettingsService,
            UserService,
            StorageService, Function, HeatService, Object, ContactService,
            EnvService])
    ], P2PMessaging);
    return P2PMessaging;
}(EventEmitter));
var p2p;
(function (p2p) {
    var MESSAGE_TEXT_MAX_SIZE = 8000;
    var U2UMessage = (function () {
        function U2UMessage(type, timestamp, text, file) {
            this.type = type;
            this.timestamp = timestamp;
            if (file) {
                this.text = "".concat(file.size, " | ").concat(file.name);
            }
            else {
                if ((text === null || text === void 0 ? void 0 : text.length) > MESSAGE_TEXT_MAX_SIZE) {
                    throw new Error("Text length ".concat(text.length, " is too big, the length is limited to ").concat(MESSAGE_TEXT_MAX_SIZE));
                }
                this.text = text;
            }
            this.id = utils.uuidv4();
        }
        return U2UMessage;
    }());
    p2p.U2UMessage = U2UMessage;
    var Room = (function () {
        function Room(name, connector, storage, user, memberPublicKeys) {
            this.name = name;
            this.connector = connector;
            this.storage = storage;
            this.user = user;
            this.memberPublicKeys = memberPublicKeys;
            this.state = {
                approved: false,
                entered: "not"
            };
            this.lastIncomingMessageTimestamp = 0;
            this.peers = new Map();
        }
        Room.prototype.enter = function (enforce) {
            this.connector.enter(this, enforce);
            return this;
        };
        Room.prototype.sendMessage = function (message) {
            var result = this.connector.sendMessage(this.name, message);
            this.registerInHistory(true, message, result);
            return result.count;
        };
        Room.prototype.sendFiles = function (files, recipientPublicKey) {
            var _this = this;
            var _loop_1 = function (file) {
                if (file.size > 0) {
                    var m_1 = new p2p.U2UMessage("file", Date.now(), null, file);
                    this_1.connector.messenger.sendFile(m_1.id, file, recipientPublicKey).then(function (responseStatusMessage) {
                        if (typeof responseStatusMessage == "string" && responseStatusMessage.toUpperCase() == "OK") {
                            _this.sendMessage(m_1);
                        }
                    });
                }
            };
            var this_1 = this;
            for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                var file = files_1[_i];
                _loop_1(file);
            }
        };
        Room.prototype.registerInHistory = function (sending, message, sendResult) {
            var _this = this;
            if (!(message.type == "chat" || message.type == "file"))
                return;
            if (this.getMessageHistory().isExistingId(message.id)) {
                throw new Error("Received a message with a duplicate ID (previously there was a message with the same ID)");
            }
            var item = {
                msgId: message.id,
                type: message.type,
                timestamp: message.timestamp,
                receiptTimestamp: Date.now(),
                fromPeer: sending ? this.user.publicKey : message.fromPeerId,
                content: message.text,
                transport: sending ? sendResult.transport : message.transport
            };
            if (sending && message.transport == "p2p" && sendResult.count > 0) {
                setTimeout(function () { return _this.getMessageHistory().putExtraInfo(message.id, { status: { stage: 1 } }); }, 100);
            }
            if (this.onNewMessageHistoryItem) {
                this.onNewMessageHistoryItem(item);
            }
            this.getMessageHistory().put(item);
        };
        Room.prototype.onMessageInternal = function (message) {
            if (this.getMessageHistory().isExistingId(message.id)) {
                throw new Error("Received a message with a duplicate ID (previously there was a message with the same ID)");
            }
            this.registerInHistory(false, message);
            if (message.type == "chat" || message.type == "file") {
                this.lastIncomingMessageTimestamp = Date.now();
            }
            if (this.onMessage) {
                this.onMessage(message);
            }
        };
        Room.prototype.getMessageHistory = function () {
            if (!this.messageHistory) {
                this.messageHistory = new p2p.MessageHistory(this, this.storage, this.user);
            }
            return this.messageHistory;
        };
        Room.prototype.provenPublicKeyAllowed = function (room, peerId, publicKey) {
            if (true)
                return true;
        };
        Room.prototype.getDataChannels = function () {
            var dataChannels = [];
            this.peers.forEach(function (peer) {
                if (peer.dataChannel) {
                    dataChannels.push(peer.dataChannel);
                }
            });
            return dataChannels;
        };
        Room.prototype.getPeer = function (peerId) {
            return this.peers.get(peerId);
        };
        Room.prototype.createPeer = function (peerId, publicKey) {
            if (this.memberPublicKeys.indexOf(publicKey) == -1) {
                return;
            }
            var existingPeer = this.peers.get(peerId);
            if (existingPeer) {
                return existingPeer;
            }
            var p = new RTCPeer(publicKey);
            this.peers.set(peerId, p);
            return p;
        };
        Room.prototype.getAllPeers = function () {
            return this.peers;
        };
        return Room;
    }());
    p2p.Room = Room;
    var RTCPeer = (function () {
        function RTCPeer(publicKey) {
            this.publicKey = publicKey;
        }
        RTCPeer.prototype.isConnected = function () {
            return this.dataChannel && this.dataChannel.readyState == "open";
        };
        RTCPeer.prototype.closeConnection = function () {
            if (this.isConnected())
                this.dataChannel.close();
        };
        return RTCPeer;
    }());
    p2p.RTCPeer = RTCPeer;
})(p2p || (p2p = {}));
var p2p;
(function (p2p) {
    var SignalingProtocol = (function (_super) {
        __extends(SignalingProtocol, _super);
        function SignalingProtocol() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.handlers = Object.assign(_this.baseHandlers, {
                PROVE_IDENTITY: function (roomName, msg) {
                    var signedData = _this.connector.sign(msg.data);
                    signedData["type"] = p2p.P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY;
                    _this.connector.sendWebsocketMessage("signaling", [signedData]);
                },
                APPROVED_IDENTITY: function (roomName, msg) {
                    _this.connector.identity = _this.connector.accountPublicKey;
                    _this.connector.pendingRooms.forEach(function (f) { return f(); });
                    _this.connector.pendingRooms = [];
                    if (_this.connector.pendingOnlineStatus)
                        _this.connector.pendingOnlineStatus();
                    _this.connector.pendingOnlineStatus = null;
                },
                WELCOME: function (roomName, msg) {
                    var room = _this.connector.rooms.get(roomName);
                    room.state.entered = "entered";
                    msg.remotePeerIds.forEach(function (peerId) {
                        var peer = room.createPeer(peerId, peerId);
                        if (peer && !peer.isConnected()) {
                            var pc = _this.connector.askPeerConnection(roomName, peerId);
                            _this.connector.doOffer(roomName, peerId, pc);
                        }
                    });
                },
                CALL: function (roomName, msg) {
                    var caller = msg.caller;
                    _this.connector.processIncomingCall(caller).then(function (value) {
                        var room = _this.connector.createRoom(roomName, caller);
                        _this.connector.enter(room, true);
                    });
                },
                offer: function (roomName, msg) {
                    var peerId = msg.fromPeer;
                    var peer = _this.connector.rooms.get(roomName).createPeer(peerId, peerId);
                    if (peer && !peer.isConnected()) {
                        var room_1 = _this.connector.rooms.get(roomName);
                        var pc_1 = _this.connector.askPeerConnection(roomName, peerId);
                        if (pc_1) {
                            pc_1.setRemoteDescription(new RTCSessionDescription(msg))
                                .then(function () {
                                _this.connector.doAnswer(roomName, peerId, pc_1);
                            })
                                .catch(function (e) {
                                if (room_1.onFailure) {
                                    room_1.onFailure(peerId, e);
                                }
                                else {
                                    console.log(e.name + "  " + e.message);
                                }
                            });
                        }
                    }
                },
                answer: function (roomName, msg) {
                    var room = _this.connector.rooms.get(roomName);
                    var peer = room.getPeer(msg.fromPeer);
                    if (peer && !peer.isConnected()) {
                        var pc = peer.peerConnection;
                        if (pc) {
                            pc.setRemoteDescription(new RTCSessionDescription(msg))
                                .catch(function (e) {
                                if (room.onFailure) {
                                    room.onFailure(msg.fromPeer, e);
                                }
                                else {
                                    console.log(e.name + "  " + e.message);
                                }
                            });
                        }
                    }
                },
                candidate: function (roomName, msg) {
                    var room = _this.connector.rooms.get(roomName);
                    var peer = room.getPeer(msg.fromPeer);
                    var pc = peer.peerConnection;
                    var candidate = new RTCIceCandidate({
                        sdpMLineIndex: msg.label,
                        candidate: msg.candidate
                    });
                    pc.addIceCandidate(candidate)
                        .catch(function (e) {
                        console.log("Failure during addIceCandidate(): " + e.name + "  " + e.message);
                        if (room.onFailure) {
                            room.onFailure(msg.fromPeer, e);
                        }
                    });
                    if (!peer['noNeedReconnect']) {
                        setTimeout(function () {
                            if (!peer.isConnected() && peer['connectionRole'] == "answer") {
                                peer['noNeedReconnect'] = true;
                                var pc_2 = _this.connector.askPeerConnection(roomName, msg.fromPeer);
                                _this.connector.doOffer(roomName, msg.fromPeer, pc_2);
                            }
                        }, 2500);
                    }
                },
                WRONGROOM: function (roomName, msg) {
                    console.log("Wrong room name \"".concat(roomName, "\""));
                },
            });
            return _this;
        }
        Object.defineProperty(SignalingProtocol.prototype, "name", {
            get: function () {
                return "signaling";
            },
            enumerable: false,
            configurable: true
        });
        return SignalingProtocol;
    }(p2p.BaseProtocol));
    p2p.SignalingProtocol = SignalingProtocol;
})(p2p || (p2p = {}));
var p2p;
(function (p2p) {
    var U2UProtocol = (function (_super) {
        __extends(U2UProtocol, _super);
        function U2UProtocol() {
            var _this = _super.call(this) || this;
            _this.commonMessageHandler = function (roomName, msg) {
                var room = _this.connector.rooms.get(roomName) || _this.connector.messenger.getOneToOneRoom(msg.fromPeer || msg.sender, true);
                if (room) {
                    var payload = JSON.parse(msg.payload);
                    var decrypted = _this.connector.decrypt(payload, msg.sender);
                    var chatMessage = JSON.parse(decrypted);
                    chatMessage.transport = "server";
                    _this.connector.processRoomMessage(chatMessage, room, msg.sender);
                    _this.connector.sendWebsocketMessage("U2U", [{
                            id: utils.uuidv4(),
                            type: "STATUS",
                            sender: _this.connector.identity,
                            recipient: msg.sender,
                            payload: JSON.stringify({ msgId: chatMessage.id, stage: 1 })
                        }]);
                }
                else {
                    throw new Error("Cannot get 'chat room' for message sender ".concat(msg.fromPeer));
                }
            };
            _this.handlers = Object.assign(_this.baseHandlers, {
                chat: _this.commonMessageHandler,
                file: _this.commonMessageHandler,
                newContact: function (roomName, msg) {
                    console.log(msg);
                },
                STATUS: function (roomName, msg) {
                    var payload = JSON.parse(msg.payload);
                    console.log(payload);
                    var room = _this.connector.rooms.get(roomName) || _this.connector.messenger.getOneToOneRoom(msg.sender || msg.fromPeer, true);
                    if (room) {
                        room.getMessageHistory().putExtraInfo(payload.msgId, { status: { stage: payload.stage, remark: payload.remark } });
                    }
                },
                TRANSFERFILE: function (roomName, msg) {
                    var payload = JSON.parse(msg.payload);
                    var fileDescriptor = _this.awaitingDownloadingFiles.get(msg.fileMessageId);
                    _this.awaitingDownloadingFiles.delete(msg.fileMessageId);
                    var fileContent = _this.connector.decrypt(payload, fileDescriptor.fileSender);
                    _this.connector.messenger.onFile(fileContent, null, msg.fileMessageId, fileDescriptor);
                },
                "remove-message.done": function (roomName, msg) {
                    _this.removeDoneMessageAccumulator.push({ roomName: roomName, targetMessageId: msg.targetMessageId, fileId: msg.fileId, error: msg.error });
                    _this.onRemoveDoneDebounced(_this.removeDoneMessageAccumulator);
                },
                "resp.is-message-exists": function (roomName, msg) {
                    _this.connector.messenger.onServerMessageExists(msg.targetMessageId, msg.message, msg.file);
                },
                ERROR: function (roomName, msg) {
                    var errorText = msg
                        ? "Server error response. ".concat(roomName ? "Room " + roomName : "", " ").concat(msg.reason)
                        : "error";
                    _this.connector.processError(errorText, "U2U");
                }
            });
            _this.removeDoneMessageAccumulator = [];
            _this.onRemoveDoneDebounced = utils.debounce(function (removeDoneMessages) {
                _this.connector.messenger.onServerMessageRemoved(removeDoneMessages);
                removeDoneMessages.length = 0;
            }, 1000, false);
            _this.awaitingDownloadingFiles = new Map();
            return _this;
        }
        Object.defineProperty(U2UProtocol.prototype, "name", {
            get: function () {
                return "U2U";
            },
            enumerable: false,
            configurable: true
        });
        U2UProtocol.prototype.requestNewContact = function (recipient, caller, room, text) {
            var m = new p2p.U2UMessage("chat", Date.now(), text);
            var encrypted = this.connector.encrypt(JSON.stringify(m), recipient);
            var sendingData = {
                id: m.id,
                type: m.type,
                room: room.name,
                sender: caller,
                recipient: recipient,
                payload: JSON.stringify(encrypted)
            };
            this.connector.sendWebsocketMessage(this.name, [sendingData]);
        };
        U2UProtocol.prototype.sendFileIsReceived = function (fileId) {
            this.connector.sendWebsocketMessage("U2U", [{
                    type: "file-received",
                    sender: this.connector.identity,
                    payload: fileId
                }]);
        };
        U2UProtocol.prototype.sendRemoveMessage = function (targetMessageId) {
            this.connector.sendWebsocketMessage("U2U", [{
                    type: "remove-message",
                    sender: this.connector.identity,
                    payload: targetMessageId
                }]);
        };
        U2UProtocol.prototype.requestIsMessageExists = function (targetMessageId) {
            this.connector.sendWebsocketMessage("U2U", [{
                    type: "req.is-message-exists",
                    sender: this.connector.identity,
                    payload: targetMessageId
                }]);
        };
        U2UProtocol.prototype.requestFile = function (fileMessageId, fileSender, fileDescriptor) {
            var sendingData = {
                id: utils.uuidv4(),
                type: "DOWNLOADFILE",
                sender: this.connector.identity,
                fileMessageId: fileMessageId
            };
            this.awaitingDownloadingFiles.set(fileMessageId, fileDescriptor);
            return this.connector.sendWebsocketMessage(this.name, [sendingData]);
        };
        return U2UProtocol;
    }(p2p.BaseProtocol));
    p2p.U2UProtocol = U2UProtocol;
})(p2p || (p2p = {}));
var AccountAssetLimitService = (function (_super) {
    __extends(AccountAssetLimitService, _super);
    function AccountAssetLimitService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    AccountAssetLimitService.prototype.dialog = function ($event, recipient, recipientPublicKey) {
        return new AccountAssetLimitDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey);
    };
    AccountAssetLimitService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type != 4 || transaction.subtype != 3)
            return false;
        transaction.assetId = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.amount = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.interval = converters.byteArrayToSignedInt32(attachment.byteArray, attachment.pos);
        attachment.pos += 4;
        return transaction.assetId === data.AccountAssetLimit.assetId
            && transaction.amount === data.AccountAssetLimit.amount
            && transaction.interval === data.AccountAssetLimit.interval;
    };
    AccountAssetLimitService = __decorate([
        Service('accountAssetLimit'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], AccountAssetLimitService);
    return AccountAssetLimitService;
}(AbstractTransaction));
var AccountAssetLimitDialog = (function (_super) {
    __extends(AccountAssetLimitDialog, _super);
    function AccountAssetLimitDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.dialogTitle = 'Assign asset limit to account';
        _this.dialogDescription = 'Set max asset amount per interval that account can to send';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.accountAssetLimitFee, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    AccountAssetLimitDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.staticText('dialogDescription', this.dialogDescription),
            builder.account('recipient', this.recipient)
                .label('Recipient (account to be limited)')
                .onchange(function () {
                _this.fields['recipientPublicKey'].value = null;
                _this.heat.api.getPublicKeyOrEmptyString(_this.fields['recipient'].value).then(function (publicKey) {
                    if (publicKey == '') {
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                    else {
                        _this.fields['recipientPublicKey'].value = publicKey;
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                }, function () {
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = false;
                    });
                });
            })
                .required(),
            builder.asset('asset')
                .label('Asset')
                .searchAllAssets(true)
                .onchange(function () {
                var amountField = _this.fields['amount'];
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                if (assetInfo) {
                    amountField.symbol(assetInfo.symbol);
                    amountField.precision(assetInfo.decimals);
                    $scope.$evalAsync(function () {
                        amountField.value = "0";
                        amountField.changed(true);
                    });
                }
            }),
            builder
                .money('amount')
                .label('Amount')
                .required()
                .precision(8)
                .symbol(''),
            builder.text('interval')
                .label('Interval (in seconds)')
                .required(),
            builder.hidden('recipientPublicKey', this.recipientPublicKey)
        ];
    };
    AccountAssetLimitDialog.prototype.getTransactionBuilder = function () {
        var interval = parseInt(this.fields['interval'].value);
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .recipient(this.fields['recipient'].value)
            .recipientPublicKey(this.fields['recipientPublicKey'].value)
            .feeNQT(HeatAPI.fee.accountAssetLimitFee)
            .attachment('AccountAssetLimit', {
            assetId: this.fields['asset'].value,
            amount: this.fields['amount'].value,
            interval: interval
        });
        return builder;
    };
    return AccountAssetLimitDialog;
}(GenericDialog));
var AssetAssignFeesService = (function (_super) {
    __extends(AssetAssignFeesService, _super);
    function AssetAssignFeesService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    AssetAssignFeesService.prototype.dialog = function ($event, recipient, recipientPublicKey) {
        return new AssetAssignFeesServiceDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey);
    };
    AssetAssignFeesService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type != 2 || transaction.subtype != 11)
            return false;
        transaction.assetId = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.tradeFee = converters.byteArrayToSignedInt32(attachment.byteArray, attachment.pos);
        attachment.pos += 4;
        transaction.orderFee = converters.byteArrayToSignedInt32(attachment.byteArray, attachment.pos);
        attachment.pos += 4;
        transaction.feeRecepient = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        return transaction.assetId === data.AssetAssignFees.assetId
            && transaction.tradeFee === data.AssetAssignFees.tradeFee
            && transaction.orderFee === data.AssetAssignFees.orderFee
            && transaction.feeRecepient === (data.AssetAssignFees.feeRecipient || '0');
    };
    AssetAssignFeesService = __decorate([
        Service('assetAssignFees'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], AssetAssignFeesService);
    return AssetAssignFeesService;
}(AbstractTransaction));
var AssetAssignFeesServiceDialog = (function (_super) {
    __extends(AssetAssignFeesServiceDialog, _super);
    function AssetAssignFeesServiceDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.dialogTitle = 'Assign fees for private asset';
        _this.dialogDescription = 'Assign fees for private asset';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.assetAssignFee, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    AssetAssignFeesServiceDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.asset('asset')
                .reset()
                .onchange(function (newValue) {
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(assetField.value);
                var assetInfoField = _this.fields['assetInfo'];
                var feeRecipient;
                if (assetInfo == null || assetInfo.type != 1) {
                    assetInfoField.value = "the private asset is not selected";
                }
                else {
                    if (assetInfo.issuer == _this.user.account) {
                        feeRecipient = (assetInfo.feeRecipient || "0") == "0" ? _this.user.account : assetInfo.feeRecipient;
                        assetInfoField.value = "Asset Info: order fee ".concat(assetInfo.orderFee || "0", "; trade fee ").concat(assetInfo.tradeFee || "0", "; fee recipient ").concat(feeRecipient);
                    }
                    else {
                        assetInfoField.value = "selected private asset was not created by you";
                    }
                }
                var f = _this.fields['feeRecipient'];
                if (!f.searchText) {
                    _this.fields['feeRecipient'].setSearchText(feeRecipient);
                }
            })
                .label('Your private asset')
                .validate("You dont own this asset", function (value) {
                if (value == "0")
                    return true;
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(assetField.value);
                return !!assetInfo;
            }).required(),
            builder
                .text('orderFee', 0)
                .label('Order Fee (scale 1000000 = 1%)')
                .required(),
            builder
                .text('tradeFee', 0)
                .label('Trade Fee (scale 1000000 = 1%)')
                .required(),
            builder
                .account('feeRecipient')
                .label('Account receiving fees'),
            builder
                .staticText("assetInfo", "the private asset is not selected")
        ];
    };
    AssetAssignFeesServiceDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.assetAssignFee)
            .attachment('AssetAssignFees', {
            assetId: this.fields['asset'].value,
            tradeFee: parseInt(this.fields['tradeFee'].value),
            orderFee: parseInt(this.fields['orderFee'].value),
            feeRecipient: this.fields['feeRecipient'].value
        });
        return builder;
    };
    return AssetAssignFeesServiceDialog;
}(GenericDialog));
var AssetExpirationService = (function (_super) {
    __extends(AssetExpirationService, _super);
    function AssetExpirationService($q, user, heat, $interval) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.$interval = $interval;
        return _this;
    }
    AssetExpirationService.prototype.dialog = function ($event, recipient, recipientPublicKey) {
        return new AssetExpirationDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey, this.$interval);
    };
    AssetExpirationService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 12)
            return false;
        transaction.assetId = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.expiration = converters.byteArrayToSignedInt32(attachment.byteArray, attachment.pos);
        attachment.pos += 4;
        return transaction.expiration === data.AssetExpiration.expiration &&
            transaction.assetId === data.AssetExpiration.assetId;
    };
    AssetExpirationService = __decorate([
        Service('assetExpiration'),
        Inject('$q', 'user', 'heat', '$interval'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService, Function])
    ], AssetExpirationService);
    return AssetExpirationService;
}(AbstractTransaction));
var AssetExpirationDialog = (function (_super) {
    __extends(AssetExpirationDialog, _super);
    function AssetExpirationDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey, $interval) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.$interval = $interval;
        _this.dialogTitle = 'Assign asset expiration';
        _this.dialogDescription = 'Description on how to assign asset expiration';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.assetAssignExpiration, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    AssetExpirationDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.asset('asset')
                .reset()
                .label('Your asset')
                .validate("You dont own this asset", function (value) {
                if (value == "0")
                    return true;
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                return !!assetInfo;
            }).
                required(),
            builder.staticText("assetInfo", ''),
            builder.text('expiration', 0)
                .label('Expiration timestamp (after timestamp the trading of asset will be disabled)'),
            builder.staticText("expirationDate", ''),
            builder.staticText("systemtimestamp", '')
        ];
    };
    AssetExpirationDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.assetAssignExpiration)
            .attachment('AssetExpiration', {
            assetId: this.fields['asset'].value,
            expiration: parseInt(this.fields['expiration'].value || '0')
        });
        return builder;
    };
    AssetExpirationDialog.prototype.fieldsReady = function ($scope) {
        var _this = this;
        var interval = this.$interval(function () {
            $scope.$evalAsync(function () {
                var expirationValue = parseInt(_this.fields['expiration'].value || '0');
                _this.fields['expirationDate'].value = expirationValue > 0
                    ? 'Entered expiration value date: ' + utils.timestampToDate(expirationValue).toLocaleString()
                    : '';
                _this.fields['systemtimestamp'].value = "Current timestamp: " + Math.round(utils.epochTime());
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                if (assetInfo) {
                    _this.fields['assetInfo'].value = assetInfo.expiration
                        ? "Current expiration: ".concat(assetInfo.expiration, " (").concat(utils.timestampToDate(assetInfo.expiration).toLocaleString(), ")")
                        : "Current expiration: no";
                }
                else {
                    _this.fields['assetInfo'].value = '';
                }
            });
        }, 1000, 0, false);
        $scope.$on('$destroy', function () { _this.$interval.cancel(interval); });
    };
    return AssetExpirationDialog;
}(GenericDialog));
var assetInfo = dialogs.assetInfo;
var AssetTransferService = (function (_super) {
    __extends(AssetTransferService, _super);
    function AssetTransferService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    AssetTransferService.prototype.dialog = function ($event, recipient, recipientPublicKey, asset, amount, userMessage) {
        return new AssetTransferDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey, asset, amount, userMessage);
    };
    AssetTransferService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 2)
            return false;
        transaction.assetId = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.quantity = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        return transaction.assetId === data.AssetTransfer.assetId &&
            transaction.quantity === data.AssetTransfer.quantity;
    };
    AssetTransferService = __decorate([
        Service('assetTransfer'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], AssetTransferService);
    return AssetTransferService;
}(AbstractTransaction));
var AssetTransferDialog = (function (_super) {
    __extends(AssetTransferDialog, _super);
    function AssetTransferDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey, asset, amount, userMessage) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.asset = asset;
        _this.amount = amount;
        _this.userMessage = userMessage;
        _this.dialogTitle = 'Asset Transfer';
        _this.dialogDescription = 'Description on how to transfer asset';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.asset = _this.asset || '';
        _this.amount = _this.amount || '0';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    AssetTransferDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.account('recipient', this.recipient).
                label('Recipient').
                onchange(function () {
                _this.fields['recipientPublicKey'].value = null;
                _this.fields['message'].changed();
                _this.heat.api.getPublicKeyOrEmptyString(_this.fields['recipient'].value).then(function (publicKey) {
                    if (publicKey == '') {
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                    else {
                        _this.fields['recipientPublicKey'].value = publicKey;
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                }, function () {
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = false;
                    });
                });
            }).
                required(),
            builder.asset('asset', this.asset).
                label('Asset').
                onchange(function () {
                var amountField = _this.fields['amount'];
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                if (assetInfo) {
                    amountField.symbol(assetInfo.symbol);
                    amountField.precision(assetInfo.decimals);
                    $scope.$evalAsync(function () {
                        amountField.value = "0";
                        amountField.changed(true);
                    });
                }
            }).
                validate("You dont own this asset", function () {
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                return !!assetInfo;
            }).
                required(),
            builder.money('amount', this.amount).
                label('Amount').
                required().
                precision(8).
                symbol('').
                asyncValidate("Not enough funds", function (amount) {
                var deferred = _this.$q.defer();
                if (_this.fields['asset'].value) {
                    _this.heat.api.getAccountBalance(_this.user.account, _this.fields['asset'].value).then(function (balance) {
                        try {
                            var avail = new Big(balance.unconfirmedBalance);
                            var total = new Big(amount);
                            if (avail.gte(total) > 0) {
                                deferred.resolve();
                            }
                            else {
                                deferred.reject();
                            }
                        }
                        catch (e) {
                            deferred.reject();
                        }
                    }, deferred.reject);
                }
                else {
                    deferred.resolve();
                }
                return deferred.promise;
            }),
            builder.text('message', this.userMessage).
                rows(2).
                asyncValidate("No recipient public key", function (message) {
                var deferred = _this.$q.defer();
                if (String(message).trim().length == 0) {
                    deferred.resolve();
                }
                else {
                    if (_this.fields['recipientPublicKey'].value) {
                        deferred.resolve();
                    }
                    else {
                        _this.heat.api.getPublicKey(_this.fields['recipient'].value).then(function (publicKey) {
                            _this.fields['recipientPublicKey'].value = publicKey;
                            deferred.resolve();
                        }, deferred.reject);
                    }
                }
                return deferred.promise;
            }).
                label('Message'),
            builder.hidden('recipientPublicKey', this.recipientPublicKey)
        ];
    };
    AssetTransferDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        var assetField = this.fields['asset'];
        var assetInfo = assetField.getAssetInfo(this.fields['asset'].value);
        if (assetInfo) {
            builder.secretPhrase(this.user.secretPhrase)
                .feeNQT(HeatAPI.fee.standard)
                .attachment('AssetTransfer', {
                assetId: this.fields['asset'].value,
                quantity: this.fields['amount'].value
            });
            builder.recipient(this.fields['recipient'].value);
            builder.recipientPublicKey(this.fields['recipientPublicKey'].value);
            if (this.fields['message'].value) {
                builder.message(this.fields['message'].value, TransactionMessageType.TO_RECIPIENT);
            }
            return builder;
        }
    };
    return AssetTransferDialog;
}(GenericDialog));
var AssetWithdrawService = (function (_super) {
    __extends(AssetWithdrawService, _super);
    function AssetWithdrawService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    AssetWithdrawService.prototype.getWithdrawFeeInfo = function (asset) {
        var localCache = heat.isTestnet ? {} : {
            "5592059897546023466": {
                feePercentage: 0.4,
                minimumQuantity: "40000",
                notice1: 'Bitcoin withdrawals are usually processed within 1 hour from request.',
                notice2: 'Occasionally longer delays on non-banking days are possible.'
            },
            "12723185826655406325": {
                feePercentage: 0.4,
                minimumQuantity: "500000000",
                notice1: 'NXT withdrawals are usually processed within 24 hour from requests.',
                notice2: 'Occasionally longer delays on non-banking days are possible.'
            },
            "17622812277075597103": {
                feePercentage: 0.4,
                minimumQuantity: "500000000",
                notice1: 'ARDOR withdrawals are usually processed within 24 hours from requests.',
                notice2: 'Occasionally longer delays on non-banking days are possible.'
            },
            "8593933499455210945": {
                feePercentage: 0.4,
                minimumQuantity: "500000000",
                notice1: 'FIMK withdrawals are usually processed with 1-12 hours from requests.',
                notice2: 'Occasionally longer delays due to network issues are possible.'
            }
        };
        var deferred = this.$q.defer();
        if (angular.isDefined(localCache[asset]))
            deferred.resolve(localCache[asset]);
        else
            deferred.reject();
        return deferred.promise;
    };
    AssetWithdrawService.prototype.dialog = function ($event, assetInfo, amount) {
        var _this = this;
        var deferred = this.$q.defer();
        if (assetInfo.id == "0")
            deferred.reject();
        this.heat.api.getAsset(assetInfo.id, "0", 1).then(function (asset) {
            var issuer = asset.account;
            _this.heat.api.getPublicKey(issuer).then(function (publicKey) {
                _this.heat.api.getAccountBalance(_this.user.account, assetInfo.id).then(function (balance) {
                    _this.getWithdrawFeeInfo(assetInfo.id).then(function (withdrawInfo) {
                        deferred.resolve(new AssetWithdrawDialog($event, _this, _this.$q, _this.user, _this.heat, issuer, publicKey, assetInfo, withdrawInfo, amount, balance));
                    }, deferred.reject);
                }, deferred.reject);
            }, deferred.reject);
        }, deferred.reject);
        return deferred.promise;
    };
    AssetWithdrawService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 2)
            return false;
        transaction.assetId = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.quantity = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        return transaction.assetId === data.AssetTransfer.assetId &&
            transaction.quantity === data.AssetTransfer.quantity;
    };
    AssetWithdrawService = __decorate([
        Service('assetWithdraw'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], AssetWithdrawService);
    return AssetWithdrawService;
}(AbstractTransaction));
var AssetWithdrawDialog = (function (_super) {
    __extends(AssetWithdrawDialog, _super);
    function AssetWithdrawDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey, assetInfo, withdrawInfo, amount, userBalance) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.assetInfo = assetInfo;
        _this.withdrawInfo = withdrawInfo;
        _this.amount = amount;
        _this.userBalance = userBalance;
        _this.dialogClass = "withdraw-asset-service";
        _this.dialogTitle = 'Withdraw ' + _this.assetInfo.symbol;
        _this.dialogDescription = 'Description on how to withdraw ' + _this.assetInfo.symbol;
        _this.okBtnTitle = 'WITHDRAW';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        _this.amount = _this.userBalance.unconfirmedBalance || _this.amount || '0';
        return _this;
    }
    AssetWithdrawDialog.prototype.fieldsReady = function ($scope) {
        var _this = this;
        var minFeeFloat = parseFloat(this.withdrawInfo.minimumQuantity + '');
        var amountFloat = parseFloat(this.userBalance.unconfirmedBalance + '');
        if (amountFloat > minFeeFloat) {
            $scope.$evalAsync(function () {
                _this.updateTotalAmountQNT(amountFloat, minFeeFloat);
            });
        }
        this.fields['amount'].changed(true);
    };
    AssetWithdrawDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var balance = utils.formatQNT(this.userBalance.balance, this.userBalance.decimals);
        var userBalanceText = "".concat(balance, " ").concat(this.assetInfo.symbol, " available on account");
        var feeText = "Processing and network fee ".concat(this.withdrawInfo.feePercentage.toFixed(2), "% (").concat(this.assetInfo.symbol, ")");
        var minAmountFormatted = utils.formatQNT(this.withdrawInfo.minimumQuantity, 8);
        var minWithdrawText = "Minimum withdraw fee is ".concat(minAmountFormatted, " ").concat(this.assetInfo.symbol);
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.hidden('recipient', this.recipient)
                .required(),
            builder.text('message', '')
                .visible(true)
                .label("Recipient ".concat(this.assetInfo.symbol, " address"))
                .required(),
            builder.hidden('asset', this.assetInfo.id)
                .required(),
            builder.money('amount', this.amount)
                .label('Amount')
                .required()
                .precision(this.assetInfo.decimals)
                .symbol(this.assetInfo.symbol).
                asyncValidate("Not enough funds", function (amount) {
                var deferred = _this.$q.defer();
                if (_this.fields['asset'].value) {
                    _this.heat.api.getAccountBalance(_this.user.account, _this.fields['asset'].value).then(function (balance) {
                        try {
                            var avail = new Big(balance.unconfirmedBalance);
                            var total = new Big(amount);
                            if (avail.gte(total) > 0) {
                                deferred.resolve();
                            }
                            else {
                                deferred.reject();
                            }
                        }
                        catch (e) {
                            deferred.reject();
                        }
                    }, deferred.reject);
                }
                else {
                    deferred.resolve();
                }
                return deferred.promise;
            }).
                validate("Minimum amount is ".concat(minAmountFormatted, " ").concat(this.assetInfo.symbol), function (amount) {
                return parseInt(amount) > parseInt(_this.withdrawInfo.minimumQuantity);
            }).
                onchange(function () {
                var amountQNT = parseFloat(_this.fields['amount'].value || '0');
                _this.updateTotalAmountQNT(amountQNT, parseFloat(_this.withdrawInfo.minimumQuantity));
            }),
            builder.hidden('recipientPublicKey', this.recipientPublicKey),
            builder.text('youWillReceive', '0')
                .label('You will receive')
                .readonly(true),
            builder.staticText('feeText', feeText),
            builder.staticText('totalFeeText', 'Total fee: '),
            builder.staticText('minWithdrawText', minWithdrawText),
            builder.staticText('withdrawalNotice1', this.withdrawInfo.notice1),
            builder.staticText('withdrawalNotice2', this.withdrawInfo.notice2)
        ];
    };
    AssetWithdrawDialog.prototype.updateTotalAmountQNT = function (amountFloat, minFeeFloat) {
        if (amountFloat <= 0) {
            this.fields['youWillReceive'].value = '0';
            this.fields['totalFeeText'].value = "Total fee ".concat(utils.formatQNT(Math.round(minFeeFloat) + '', 8), " ").concat(this.assetInfo.symbol);
        }
        else {
            var multiplier = 1.0 - (this.withdrawInfo.feePercentage / 100);
            var received = Math.round(amountFloat * multiplier);
            var totalFee = amountFloat - received;
            if (totalFee < minFeeFloat) {
                totalFee = minFeeFloat;
                received = Math.round(amountFloat - minFeeFloat);
            }
            this.fields['youWillReceive'].value = received < 0 ? '0' : utils.formatQNT(received + '', 8);
            this.fields['totalFeeText'].value = "Total fee ".concat(utils.formatQNT(totalFee + '', 8), " ").concat(this.assetInfo.symbol);
        }
    };
    AssetWithdrawDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('AssetTransfer', {
            assetId: this.fields['asset'].value,
            quantity: this.fields['amount'].value
        });
        builder.recipient(this.fields['recipient'].value);
        builder.recipientPublicKey(this.fields['recipientPublicKey'].value);
        if (this.fields['message'].value) {
            builder.message(this.fields['message'].value, TransactionMessageType.TO_RECIPIENT);
        }
        return builder;
    };
    return AssetWithdrawDialog;
}(GenericDialog));
var BalanceLeaseService = (function (_super) {
    __extends(BalanceLeaseService, _super);
    function BalanceLeaseService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    BalanceLeaseService.prototype.dialog = function (period, recipient, $event) {
        return new BalanceLeaseDialog($event, this, this.$q, this.user, this.heat, period, recipient);
    };
    BalanceLeaseService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 4)
            return false;
        if (transaction.subtype !== 0)
            return false;
        transaction.period = converters.byteArrayToSignedInt32(attachment.byteArray, attachment.pos);
        attachment.pos += 4;
        return transaction.period === data.EffectiveBalanceLeasing.period;
    };
    BalanceLeaseService = __decorate([
        Service('balanceLease'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], BalanceLeaseService);
    return BalanceLeaseService;
}(AbstractTransaction));
var BalanceLeaseDialog = (function (_super) {
    __extends(BalanceLeaseDialog, _super);
    function BalanceLeaseDialog($event, transaction, $q, user, heat, period, recipient) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.period = period;
        _this.recipient = recipient;
        _this.dialogTitle = 'Balance Lease';
        _this.dialogDescription = 'Description on how to lease balance';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    BalanceLeaseDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.account('recipient', this.recipient).
                label('Recipient').
                required(),
            builder.text('period', this.period).
                label('Period (number of blocks)').
                required()
        ];
    };
    BalanceLeaseDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .recipient(this.fields['recipient'].value)
            .attachment('EffectiveBalanceLeasing', {
            period: parseInt(this.fields['period'].value)
        });
        return builder;
    };
    return BalanceLeaseDialog;
}(GenericDialog));
var CancelAskOrderService = (function (_super) {
    __extends(CancelAskOrderService, _super);
    function CancelAskOrderService($q, user) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        return _this;
    }
    CancelAskOrderService.prototype.dialog = function (order, readonly, $event) {
        return new CancelAskOrderDialog($event, this, this.$q, this.user, order, readonly);
    };
    CancelAskOrderService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 5)
            return false;
        transaction.order = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        return transaction.order === data.AskOrderCancellation.orderId;
    };
    CancelAskOrderService = __decorate([
        Service('cancelAskOrder'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService])
    ], CancelAskOrderService);
    return CancelAskOrderService;
}(AbstractTransaction));
var CancelAskOrderDialog = (function (_super) {
    __extends(CancelAskOrderDialog, _super);
    function CancelAskOrderDialog($event, transaction, $q, user, order, readonly) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.order = order;
        _this.readonly = readonly;
        _this.dialogTitle = 'Cancel ask order';
        _this.dialogDescription = 'Description on how to cancel ask order';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    CancelAskOrderDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.text('order', this.order).
                label('Order').
                required().
                readonly(this.readonly)
        ];
    };
    CancelAskOrderDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('AskOrderCancellation', {
            orderId: this.fields['order'].value
        });
        return builder;
    };
    return CancelAskOrderDialog;
}(GenericDialog));
var CancelBidOrderService = (function (_super) {
    __extends(CancelBidOrderService, _super);
    function CancelBidOrderService($q, user) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        return _this;
    }
    CancelBidOrderService.prototype.dialog = function (order, readonly, $event) {
        return new CancelBidOrderDialog($event, this, this.$q, this.user, order, readonly);
    };
    CancelBidOrderService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 6)
            return false;
        transaction.order = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        return transaction.order === data.BidOrderCancellation.orderId;
    };
    CancelBidOrderService = __decorate([
        Service('cancelBidOrder'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService])
    ], CancelBidOrderService);
    return CancelBidOrderService;
}(AbstractTransaction));
var CancelBidOrderDialog = (function (_super) {
    __extends(CancelBidOrderDialog, _super);
    function CancelBidOrderDialog($event, transaction, $q, user, order, readonly) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.order = order;
        _this.readonly = readonly;
        _this.dialogTitle = 'Cancel bid order';
        _this.dialogDescription = 'Description on how to cancel bid order';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    CancelBidOrderDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.text('order', this.order).
                label('Order').
                required().
                readonly(this.readonly)
        ];
    };
    CancelBidOrderDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('BidOrderCancellation', {
            orderId: this.fields['order'].value
        });
        return builder;
    };
    return CancelBidOrderDialog;
}(GenericDialog));
var MasternodeService = (function (_super) {
    __extends(MasternodeService, _super);
    function MasternodeService($q, user, heatService) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heatService = heatService;
        _this.fee = HeatAPI.fee.registerInternetAddressFee;
        if (!heat.isTestnet) {
            _this.heatService.api.getBlockchainStatus().then(function (status) {
                _this.fee = (status === null || status === void 0 ? void 0 : status.lastBlockchainFeederHeight) < 4372000 ? utils.convertToQNT('100.00') : HeatAPI.fee.registerInternetAddressFee;
            });
        }
        return _this;
    }
    MasternodeService.prototype.dialog = function ($event) {
        return new RegisterInternetAddressDialog($event, this, this.$q, this.user, this.heatService, "", this.fee);
    };
    MasternodeService.prototype.verify = function (transaction, attachment, data) {
        if (!AbstractTransaction.checkType(transaction, 4, 1))
            return false;
        var len = attachment.byteArray[attachment.pos];
        attachment.pos += 1;
        transaction.internetAddress = converters.byteArrayToString(attachment.byteArray, attachment.pos, len);
        attachment.pos += len;
        return transaction.internetAddress === data.InternetAddress.internetAddress;
    };
    MasternodeService = __decorate([
        Service('masternode'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], MasternodeService);
    return MasternodeService;
}(AbstractTransaction));
var RegisterInternetAddressDialog = (function (_super) {
    __extends(RegisterInternetAddressDialog, _super);
    function RegisterInternetAddressDialog($event, transaction, $q, user, heat, internetAddress, fee) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.internetAddress = internetAddress;
        _this.fee = fee;
        _this.dialogTitle = 'Register Masternode Address';
        _this.dialogDescription = 'Register Internet Address to be Masternode';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(_this.fee, 8).replace(/000000$/, '');
        return _this;
    }
    RegisterInternetAddressDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder
                .text('internetAddress', this.internetAddress)
                .label('IP address or domain name')
                .required(),
            builder.staticText('note2', "Minimum stake for Masternode to receive POP reward at block generation is 1000 HEAT"),
            builder.staticText('feeText', "NOTICE: Masternode registration will expire after 311040  blocks (~90 days). To keep receiving POP rewards you will need to re-register at that time"),
            builder.staticText('masternodesList', "")
                .label("List of actual masternodes (account, IP or domain name, expiration height)")
                .scrollable(true)
        ];
    };
    RegisterInternetAddressDialog.prototype.fieldsReady = function ($scope) {
        var _this = this;
        this.heat.api.listMasternodes().then(function (masternodes) {
            var masterNodesStr = masternodes.map(function (v) { return "".concat(v.account, "   ").concat(v.internetAddress, "   ").concat(v.expirationHeight || ""); }).join("\n");
            $scope.$evalAsync(function () { return _this.fields['masternodesList'].value = masterNodesStr; });
        });
    };
    RegisterInternetAddressDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .recipient(this.user.account)
            .feeNQT(this.fee)
            .attachment('InternetAddress', {
            internetAddress: this.fields['internetAddress'].value
        });
        return builder;
    };
    return RegisterInternetAddressDialog;
}(GenericDialog));
var PlaceAskOrderService = (function (_super) {
    __extends(PlaceAskOrderService, _super);
    function PlaceAskOrderService($q, user) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        return _this;
    }
    PlaceAskOrderService.prototype.dialog = function (market, currencyInfo, assetInfo, price, quantity, expiration, readonly, $event) {
        return new PlaceAskOrderDialog($event, this, this.$q, this.user, market, currencyInfo, assetInfo, price, quantity, expiration, readonly);
    };
    PlaceAskOrderService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 3)
            return false;
        transaction.currency = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.asset = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.quantity = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.price = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.expiration = converters.byteArrayToSignedInt32(attachment.byteArray, attachment.pos);
        attachment.pos += 4;
        var result = transaction.currency === data.AskOrderPlacement.currencyId &&
            transaction.asset === data.AskOrderPlacement.assetId &&
            transaction.quantity === data.AskOrderPlacement.quantity &&
            transaction.price === data.AskOrderPlacement.price &&
            transaction.expiration === data.AskOrderPlacement.expiration;
        if (attachment.attachmentVersion > 1) {
            transaction.isSenderFeePayer = attachment.byteArray[attachment.pos] == 1;
            attachment.pos += 1;
            result = result && transaction.isSenderFeePayer === data.AskOrderPlacement.isSenderFeePayer;
        }
        return result;
    };
    PlaceAskOrderService = __decorate([
        Service('placeAskOrder'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService])
    ], PlaceAskOrderService);
    return PlaceAskOrderService;
}(AbstractTransaction));
var PlaceAskOrderDialog = (function (_super) {
    __extends(PlaceAskOrderDialog, _super);
    function PlaceAskOrderDialog($event, transaction, $q, user, market, currencyInfo, assetInfo, price, quantity, expiration, readonly) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.market = market;
        _this.currencyInfo = currencyInfo;
        _this.assetInfo = assetInfo;
        _this.price = price;
        _this.quantity = quantity;
        _this.expiration = expiration;
        _this.readonly = readonly;
        _this.dialogTitle = 'Place ask order';
        _this.dialogDescription = 'Description on how to place ask order';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    PlaceAskOrderDialog.prototype.getFields = function ($scope) {
        var _a;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.text('currency', this.currencyInfo.id).
                label('Currency').
                required().
                readonly(this.readonly),
            builder.text('asset', this.assetInfo.id).
                label('Asset').
                required().
                readonly(this.readonly),
            builder.text('price', this.price).
                label('Price').
                required().
                readonly(this.readonly),
            builder.text('quantity', this.quantity).
                label('Amount').
                required().
                readonly(this.readonly),
            builder.text('expiration', this.expiration).
                label('Expiration').
                required().
                readonly(this.readonly),
            builder.switcher("isSenderFeePayer", true)
                .label('Force sender pays network fee')
                .visible(((_a = this.market) === null || _a === void 0 ? void 0 : _a.isIssuerFeePayer) && (this.assetInfo.type == 1 || this.currencyInfo.type == 1))
        ];
    };
    PlaceAskOrderDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('AskOrderPlacement', {
            currencyId: this.fields['currency'].value,
            assetId: this.fields['asset'].value,
            price: utils.convertToQNT(this.fields['price'].value, this.currencyInfo.decimals),
            quantity: utils.convertToQNT(this.fields['quantity'].value, this.assetInfo.decimals),
            expiration: this.fields['expiration'].value,
            isSenderFeePayer: !!this.fields['isSenderFeePayer'].value
        });
        return builder;
    };
    return PlaceAskOrderDialog;
}(GenericDialog));
var PlaceBidOrderService = (function (_super) {
    __extends(PlaceBidOrderService, _super);
    function PlaceBidOrderService($q, user) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        return _this;
    }
    PlaceBidOrderService.prototype.dialog = function (market, currencyInfo, assetInfo, price, quantity, expiration, readonly, $event) {
        return new PlaceBidOrderDialog($event, this, this.$q, this.user, market, currencyInfo, assetInfo, price, quantity, expiration, readonly);
    };
    PlaceBidOrderService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 4)
            return false;
        transaction.currency = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.asset = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.quantity = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.price = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.expiration = converters.byteArrayToSignedInt32(attachment.byteArray, attachment.pos);
        attachment.pos += 4;
        var result = transaction.currency === data.BidOrderPlacement.currencyId &&
            transaction.asset === data.BidOrderPlacement.assetId &&
            transaction.quantity === data.BidOrderPlacement.quantity &&
            transaction.price === data.BidOrderPlacement.price &&
            transaction.expiration === data.BidOrderPlacement.expiration;
        if (attachment.attachmentVersion > 1) {
            transaction.isSenderFeePayer = attachment.byteArray[attachment.pos] == 1;
            attachment.pos += 1;
            result = result && transaction.isSenderFeePayer === data.BidOrderPlacement.isSenderFeePayer;
        }
        return result;
    };
    PlaceBidOrderService = __decorate([
        Service('placeBidOrder'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService])
    ], PlaceBidOrderService);
    return PlaceBidOrderService;
}(AbstractTransaction));
var PlaceBidOrderDialog = (function (_super) {
    __extends(PlaceBidOrderDialog, _super);
    function PlaceBidOrderDialog($event, transaction, $q, user, market, currencyInfo, assetInfo, price, quantity, expiration, readonly) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.market = market;
        _this.currencyInfo = currencyInfo;
        _this.assetInfo = assetInfo;
        _this.price = price;
        _this.quantity = quantity;
        _this.expiration = expiration;
        _this.readonly = readonly;
        _this.dialogTitle = 'Place bid order';
        _this.dialogDescription = 'Description on how to place bid order';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    PlaceBidOrderDialog.prototype.getFields = function ($scope) {
        var _a;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.text('currency', this.currencyInfo.id).
                label('Currency').
                required().
                readonly(this.readonly),
            builder.text('asset', this.assetInfo.id).
                label('Asset').
                required().
                readonly(this.readonly),
            builder.text('price', this.price).
                label('Price').
                required().
                readonly(this.readonly),
            builder.text('quantity', this.quantity).
                label('Amount').
                required().
                readonly(this.readonly),
            builder.text('expiration', this.expiration).
                label('Expiration').
                required().
                readonly(this.readonly),
            builder.switcher("isSenderFeePayer", true)
                .label('Force sender pays network fee')
                .visible(((_a = this.market) === null || _a === void 0 ? void 0 : _a.isIssuerFeePayer) && (this.assetInfo.type == 1 || this.currencyInfo.type == 1))
        ];
    };
    PlaceBidOrderDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('BidOrderPlacement', {
            currencyId: this.fields['currency'].value,
            assetId: this.fields['asset'].value,
            price: utils.convertToQNT(this.fields['price'].value, this.currencyInfo.decimals),
            quantity: utils.convertToQNT(this.fields['quantity'].value, this.assetInfo.decimals),
            expiration: this.fields['expiration'].value,
            isSenderFeePayer: !!this.fields['isSenderFeePayer'].value
        });
        return builder;
    };
    return PlaceBidOrderDialog;
}(GenericDialog));
var SendmessageService = (function (_super) {
    __extends(SendmessageService, _super);
    function SendmessageService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    SendmessageService.prototype.dialog = function ($event, recipient, recipientPublicKey, userMessage) {
        return new SendMessageDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey, userMessage);
    };
    SendmessageService.prototype.verify = function (transaction, attachment) {
        return transaction.type === 1 && transaction.subtype === 0;
    };
    SendmessageService = __decorate([
        Service('sendmessage'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], SendmessageService);
    return SendmessageService;
}(AbstractTransaction));
var SendMessageDialog = (function (_super) {
    __extends(SendMessageDialog, _super);
    function SendMessageDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey, userMessage) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.userMessage = userMessage;
        _this.missRecipient = false;
        _this.missRecipientPubKey = false;
        _this.dialogTitle = 'Send Message';
        _this.dialogDescription = 'Description on how to send message';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    SendMessageDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.account('recipient', this.recipient)
                .label('Recipient')
                .onchange(function () {
                if (_this.missRecipient) {
                    _this.missRecipient = false;
                    return;
                }
                _this.fields['recipientPublicKey'].value = null;
                _this.missRecipientPubKey = true;
                _this.heat.api.getPublicKey(_this.fields['recipient'].value, true).then(function (publicKey) {
                    _this.fields['recipientPublicKey'].value = publicKey;
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = true;
                    });
                }, function (reason) {
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = false;
                        _this.fields['recipientPublicKey'].value = null;
                    });
                });
            })
                .asyncValidate("No recipient public key", function (message) {
                var deferred = _this.$q.defer();
                if (String(message).trim().length == 0) {
                    deferred.resolve();
                }
                else {
                    if (_this.fields['recipientPublicKey'].value) {
                        deferred.resolve();
                    }
                    else {
                        _this.heat.api.getPublicKey(_this.fields['recipient'].value).then(function (publicKey) {
                            _this.fields['recipientPublicKey'].value = publicKey;
                            deferred.resolve();
                        }, deferred.reject);
                    }
                }
                return deferred.promise;
            })
                .required(),
            builder.text('recipientPublicKey', this.recipientPublicKey)
                .label("Recipient public key")
                .onchange(function () {
                if (_this.missRecipientPubKey) {
                    _this.missRecipientPubKey = false;
                    return;
                }
                var recipientId = heat.crypto.getAccountIdFromPublicKey(_this.fields['recipientPublicKey'].value);
                var f = _this.fields['recipient'];
                _this.missRecipient = true;
                f.setSearchText(recipientId);
            }),
            builder.text('message', this.userMessage)
                .rows(2)
                .required(true)
                .label('Message')
        ];
    };
    SendMessageDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('ArbitraryMessage', {});
        builder.recipient(this.fields['recipient'].value);
        builder.recipientPublicKey(this.fields['recipientPublicKey'].value);
        if (this.fields['message'].value) {
            builder.message(this.fields['message'].value, TransactionMessageType.TO_RECIPIENT);
        }
        return builder;
    };
    return SendMessageDialog;
}(GenericDialog));
var SupervisoryAccountService = (function (_super) {
    __extends(SupervisoryAccountService, _super);
    function SupervisoryAccountService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    SupervisoryAccountService.prototype.dialog = function ($event, recipient, recipientPublicKey) {
        return new SupervisoryAccountServiceDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey);
    };
    SupervisoryAccountService.prototype.verify = function (transaction, attachment, data) {
        return transaction.type === 4 && transaction.subtype === 2;
    };
    SupervisoryAccountService = __decorate([
        Service('supervisoryAccount'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], SupervisoryAccountService);
    return SupervisoryAccountService;
}(AbstractTransaction));
var SupervisoryAccountServiceDialog = (function (_super) {
    __extends(SupervisoryAccountServiceDialog, _super);
    function SupervisoryAccountServiceDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.dialogTitle = "Assigning the sender under control of the recipient";
        _this.dialogDescription = 'Puts the sender account under the control of the recipient';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.supervisoryAccountFee, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    SupervisoryAccountServiceDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.account('recipient', this.recipient)
                .label('Recipient')
                .onchange(function () {
                _this.fields['recipientPublicKey'].value = null;
                _this.heat.api.getPublicKeyOrEmptyString(_this.fields['recipient'].value).then(function (publicKey) {
                    if (publicKey == '') {
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                    else {
                        _this.fields['recipientPublicKey'].value = publicKey;
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                }, function () {
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = false;
                    });
                });
            })
                .required(),
            builder.hidden('recipientPublicKey', this.recipientPublicKey)
        ];
    };
    SupervisoryAccountServiceDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.supervisoryAccountFee)
            .attachment('SupervisoryAccount', {})
            .recipient(this.fields['recipient'].value)
            .recipientPublicKey(this.fields['recipientPublicKey'].value);
        return builder;
    };
    return SupervisoryAccountServiceDialog;
}(GenericDialog));
var WhitelistAssetAccountService = (function (_super) {
    __extends(WhitelistAssetAccountService, _super);
    function WhitelistAssetAccountService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    WhitelistAssetAccountService.prototype.dialog = function ($event, recipient, recipientPublicKey) {
        return new WhitelistAssetAccountDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey);
    };
    WhitelistAssetAccountService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type != 2 || transaction.subtype != 7)
            return false;
        transaction.assetId = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.accountId = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.endHeight = converters.byteArrayToSignedInt32(attachment.byteArray, attachment.pos);
        attachment.pos += 4;
        return transaction.assetId === data.WhitelistAssetAccount.assetId
            && transaction.accountId === data.WhitelistAssetAccount.accountId
            && transaction.endHeight === data.WhitelistAssetAccount.endHeight;
    };
    WhitelistAssetAccountService = __decorate([
        Service('whitelistAssetAccount'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], WhitelistAssetAccountService);
    return WhitelistAssetAccountService;
}(AbstractTransaction));
var WhitelistAssetAccountDialog = (function (_super) {
    __extends(WhitelistAssetAccountDialog, _super);
    function WhitelistAssetAccountDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.dialogTitle = 'Whitelist account to use the private asset';
        _this.dialogDescription = 'Description on how to whitelist account to use the private asset';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.whitelistAssetAccount, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    WhitelistAssetAccountDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder
                .staticText('feeNote', "Enabling account for private asset the fee: "
                + utils.formatQNT(HeatAPI.fee.whitelistAssetAccount, 8).replace(/000000$/, '')
                + ". Disabling account for private asset the fee: "
                + utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '')),
            builder.asset('asset')
                .label('Your private asset')
                .validate("You dont own this asset", function (value) {
                if (value == "0")
                    return true;
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                return !!assetInfo;
            }).required(),
            builder
                .account('account')
                .label('Account to be enabled to use the private asset')
                .required(),
            builder.text('endHeight')
                .label('End height (set 0 to disable the account for private asset)')
                .required(),
        ];
    };
    WhitelistAssetAccountDialog.prototype.getTransactionBuilder = function () {
        var endHeight = parseInt(this.fields['endHeight'].value);
        var fee = endHeight == 0 ? HeatAPI.fee.standard : HeatAPI.fee.whitelistAssetAccount;
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(fee)
            .attachment('WhitelistAssetAccount', {
            assetId: this.fields['asset'].value,
            accountId: this.fields['account'].value,
            endHeight: endHeight
        });
        return builder;
    };
    return WhitelistAssetAccountDialog;
}(GenericDialog));
var WhitelistMarketService = (function (_super) {
    __extends(WhitelistMarketService, _super);
    function WhitelistMarketService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    WhitelistMarketService.prototype.dialog = function ($event, recipient, recipientPublicKey) {
        return new WhitelistMarketferDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey);
    };
    WhitelistMarketService.prototype.verify = function (transaction, attachment, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 9)
            return false;
        transaction.currencyId = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        transaction.assetId = String(converters.byteArrayToBigInteger(attachment.byteArray, attachment.pos));
        attachment.pos += 8;
        var result = transaction.currencyId === data.WhitelistMarket.currencyId &&
            transaction.assetId === data.WhitelistMarket.assetId;
        if (attachment.attachmentVersion > 1) {
            transaction.isIssuerFeePayer = attachment.byteArray[attachment.pos];
            attachment.pos += 1;
            result = result && transaction.isIssuerFeePayer === data.WhitelistMarket.isIssuerFeePayer;
        }
        return result;
    };
    WhitelistMarketService = __decorate([
        Service('whitelistMarket'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], WhitelistMarketService);
    return WhitelistMarketService;
}(AbstractTransaction));
var WhitelistMarketferDialog = (function (_super) {
    __extends(WhitelistMarketferDialog, _super);
    function WhitelistMarketferDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.dialogTitle = 'Whitelist Market (update the market)';
        _this.dialogDescription = 'Description on how to whitelist a market';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.whitelistMarket, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    WhitelistMarketferDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var networkNote = "NETWORK FEE MIN 0.01 HEAT FOR EVERY SUBMITTED ORDER";
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.asset('asset')
                .label('Your asset')
                .onchange(function (newValue) {
                _this.assetIsPrivate = newValue && _this.isSelectedAssetPrivate(newValue);
                _this.fields['issuerFeePayer'].visible(_this.assetIsPrivate || _this.currencyIsPrivate);
                if (_this.isSelectedAssetExpired(newValue))
                    _this.fields['asset'].setValue("");
            })
                .validate("You dont own this asset", function (value) {
                if (value == "0")
                    return true;
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                return !!assetInfo;
            }).
                required(),
            builder.asset('currency')
                .label('Allow market')
                .searchAllAssets(true)
                .required()
                .onchange(function (newValue) {
                _this.currencyIsPrivate = newValue && _this.isSelectedAssetPrivate(newValue);
                _this.fields['issuerFeePayer'].visible(_this.assetIsPrivate || _this.currencyIsPrivate);
                if (_this.isSelectedAssetExpired(newValue))
                    _this.fields['currency'].setValue("");
            }),
            builder.switcher('issuerFeePayer', false)
                .label('Network fee paid by')
                .valueLabels("ISSUER", "SENDER")
                .valueNotes(networkNote, networkNote)
                .visible(false)
        ];
    };
    WhitelistMarketferDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        var assetId = this.fields['asset'].value;
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.whitelistMarket)
            .attachment('WhitelistMarket', {
            assetId: assetId,
            currencyId: this.fields['currency'].value,
            isIssuerFeePayer: (this.isSelectedAssetPrivate(assetId) ? (this.fields['issuerFeePayer'].value ? 2 : 1) : 1)
        });
        return builder;
    };
    WhitelistMarketferDialog.prototype.getSelectedAssetInfo = function (assetId) {
        var assetField = this.fields['asset'];
        return assetField.getAssetInfo(assetId);
    };
    WhitelistMarketferDialog.prototype.isSelectedAssetPrivate = function (assetId) {
        if (assetId == "0")
            return false;
        var assetInfo = this.getSelectedAssetInfo(assetId);
        return assetInfo && assetInfo.type == 1;
    };
    WhitelistMarketferDialog.prototype.isSelectedAssetExpired = function (assetId) {
        if (assetId == "0")
            return false;
        var assetInfo = this.getSelectedAssetInfo(assetId);
        return !!assetInfo && assetInfo.expired;
    };
    return WhitelistMarketferDialog;
}(GenericDialog));
var ArdorAccountComponent = (function () {
    function ArdorAccountComponent($scope, ardorBlockExplorerService, ardorPendingTransactions, $interval, $mdToast, settings, user) {
        this.$scope = $scope;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.ardorPendingTransactions = ardorPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
    }
    ArdorAccountComponent.prototype.$onInit = function () {
        var _this = this;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        this.ardorPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = this.$interval(this.timerHandler.bind(this), 7000);
        this.timerHandler();
        this.$scope.$on('$destroy', function () {
            _this.ardorPendingTransactions.removeListener(listener);
            _this.$interval.cancel(promise);
        });
        this.sockets = [
            {
                name: 'HEAT_Ardr_node',
                hostUrl: 'https://ardr1.heatwallet.com'
            },
            {
                name: 'Localhost',
                hostUrl: 'http://localhost:27876'
            }
        ];
        this.$scope['vm'].selectSocketEndPoint = this.sockets.find(function (w) { return _this.ardorBlockExplorerService.getHostUrl() == w.hostUrl; }).name;
    };
    ArdorAccountComponent.prototype.changeHostAddress = function () {
        var _this = this;
        var ret = this.sockets.find(function (w) { return _this.$scope['vm'].selectSocketEndPoint == w.name; });
        this.ardorBlockExplorerService.setUrl(ret.hostUrl);
        var host = ret.hostUrl.split(':27876')[0];
        SettingsService.changeCryptoNodeProperty('ARDR', host, 'priority', 0);
    };
    ArdorAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_1 = this.pendingTransactions[this.prevIndex];
            if (!pendingTxn_1.fullHash || pendingTxn_1.fullHash == "undefined") {
                this.ardorPendingTransactions.remove(pendingTxn_1.address, pendingTxn_1.txId, pendingTxn_1.time, pendingTxn_1.fullHash);
            }
            this.ardorBlockExplorerService.getTransactionStatus(pendingTxn_1.fullHash).then(function (data) {
                if (data.confirmations) {
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id ".concat(pendingTxn_1.txId, " found")).hideDelay(2000));
                    _this.ardorPendingTransactions.remove(pendingTxn_1.address, pendingTxn_1.txId, pendingTxn_1.time, pendingTxn_1.fullHash);
                }
            }, function (err) {
                console.log('Transaction not found', err);
            });
        }
    };
    ArdorAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.currency.address;
            var txns = _this.ardorPendingTransactions.pending[addr];
            if (txns) {
                var format_1 = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format_1),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr,
                        fullHash: tx.fullHash
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    ArdorAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.ardorBlockExplorerService.getBalance(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = new Big(utils.convertToQNTf(info)).toFixed(8);
                _this.busy = false;
            });
        });
    };
    ArdorAccountComponent = __decorate([
        RouteConfig('/ardor-account/:account'),
        Component({
            selector: 'ardorAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/ardor-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance:\n              <md-progress-circular style=\"display: initial; position: fixed;\" md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} ARDR\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              ARDOR Server:\n            </div>\n            <div class=\"value\">\n              <md-select class=\"md-select-ws\" ng-model=\"vm.selectSocketEndPoint\" ng-change=\"vm.changeHostAddress()\">\n                <md-option ng-repeat=\"socket in vm.sockets\" value=\"{{socket.name}}\">{{socket.name}}</md-option>\n              </md-select>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <span>{{item.txId}}</span>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-ardor-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-ardor-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'ardorBlockExplorerService', 'ardorPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, ArdorBlockExplorerService,
            ArdorPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], ArdorAccountComponent);
    return ArdorAccountComponent;
}());
var BitcoinAccountComponent = (function () {
    function BitcoinAccountComponent($scope, btcBlockExplorerService, bitcoinPendingTransactions, $interval, $mdToast, settings, user, heat) {
        this.$scope = $scope;
        this.btcBlockExplorerService = btcBlockExplorerService;
        this.bitcoinPendingTransactions = bitcoinPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.heat = heat;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
    }
    BitcoinAccountComponent.prototype.$onInit = function () {
        var _this = this;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        this.bitcoinPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = this.$interval(this.timerHandler.bind(this), 12000);
        this.timerHandler();
        this.$scope.$on('$destroy', function () {
            _this.bitcoinPendingTransactions.removeListener(listener);
            _this.$interval.cancel(promise);
        });
    };
    BitcoinAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_2 = this.pendingTransactions[this.prevIndex];
            this.btcBlockExplorerService.getTxInfo(pendingTxn_2.txId).then(function (data) {
                if (data.blockheight !== -1) {
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id ".concat(pendingTxn_2.txId, " found")).hideDelay(2000));
                    _this.bitcoinPendingTransactions.remove(pendingTxn_2.address, pendingTxn_2.txId, pendingTxn_2.time);
                }
            }, function (err) {
                console.log('Transaction not found', err);
            });
        }
    };
    BitcoinAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.currency.address;
            var txns = _this.bitcoinPendingTransactions.pending[addr];
            if (txns) {
                var format_2 = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format_2),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
                _this.loadPaymentMessages();
            }
        });
    };
    BitcoinAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        var balanceUnconfirmedHolder;
        this.btcBlockExplorerService.getBalance(this.account).then(function (unconfirmedBalance) {
            _this.$scope.$evalAsync(function () {
                balanceUnconfirmedHolder = unconfirmedBalance;
                _this.busy = false;
            });
        }).finally(function () {
            var b = wlt.getSavedCurrencyBalance(_this.account, "BTC", balanceUnconfirmedHolder ? String(balanceUnconfirmedHolder) : null);
            _this.balance = b.confirmed ? new Big(b.confirmed).div(wlt.SATOSHI_PER_BTC).toFixed(8) : null;
            _this.balanceUnconfirmed = b.unconfirmed ? new Big(b.unconfirmed).div(wlt.SATOSHI_PER_BTC).toFixed(8) : null;
        });
        this.loadPaymentMessages();
    };
    BitcoinAccountComponent.prototype.loadPaymentMessages = function () {
        var _loop_2 = function (ptx) {
            if (ptx.message === undefined) {
                wlt.loadPaymentMessage(ptx.txId)
                    .then(function (v) { return ptx.message = v; })
                    .catch(function (reason) { return console.warn("payment message is not loaded: " + JSON.stringify(reason)); });
            }
        };
        for (var _i = 0, _a = this.pendingTransactions; _i < _a.length; _i++) {
            var ptx = _a[_i];
            _loop_2(ptx);
        }
    };
    BitcoinAccountComponent = __decorate([
        RouteConfig('/bitcoin-account/:account'),
        Component({
            selector: 'bitcoinAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/bitcoin-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balance}} BTC\n              <span style=\"font-size: small\" ng-if=\"vm.balanceUnconfirmed && vm.balanceUnconfirmed != vm.balance\"><br>{{vm.balanceUnconfirmed}} (unconfirmed)</span>\n              <span ng-if=\"vm.cachedItems\" style=\"opacity: 0.8; color: darkorange\">&nbsp; (cached)</span>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col tx-col left\" flex>Transaction Id</div>\n              <div class=\"truncate-col info-col left\" flex>Message</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col tx-col left\" flex>\n                <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://live.blockcypher.com/btc/tx/{{item.txId}}\">{{item.txId}}</a>\n              </div>\n              <div class=\"truncate-col left\" ng-if=\"item.message\">\n                <span style=\"opacity: 0.5\">[{{item.message.method == 0 ? \"local\" : \"HEAT\"}}]</span> \n                {{item.message.text}}\n                <md-tooltip md-delay=\"800\">{{item.message.text}}</md-tooltip>\n              </div>\n              <span ng-if=\"!item.message\" class=\"truncate-col left\" style=\"opacity: 0.5\">-</span>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-btc-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-btc-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'btcBlockExplorerService', 'bitcoinPendingTransactions', '$interval', '$mdToast', 'settings', 'user', 'heat'),
        __metadata("design:paramtypes", [Object, BtcBlockExplorerService,
            BitcoinPendingTransactionsService, Function, Object, SettingsService,
            UserService,
            HeatService])
    ], BitcoinAccountComponent);
    return BitcoinAccountComponent;
}());
var BitcoinCashAccountComponent = (function () {
    function BitcoinCashAccountComponent($scope, bchBlockExplorerService, bchPendingTransactions, $interval, $mdToast, settings, user) {
        this.$scope = $scope;
        this.bchBlockExplorerService = bchBlockExplorerService;
        this.bchPendingTransactions = bchPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
    }
    BitcoinCashAccountComponent.prototype.$onInit = function () {
        var _this = this;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        this.bchPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = this.$interval(this.timerHandler.bind(this), 30000);
        this.timerHandler();
        this.$scope.$on('$destroy', function () {
            _this.bchPendingTransactions.removeListener(listener);
            _this.$interval.cancel(promise);
        });
    };
    BitcoinCashAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_3 = this.pendingTransactions[this.prevIndex];
            this.bchBlockExplorerService.getTxInfo(pendingTxn_3.txId).then(function (data) {
                if (data.blockHeight > 0) {
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id ".concat(pendingTxn_3.txId, " found")).hideDelay(2000));
                    _this.bchPendingTransactions.remove(pendingTxn_3.address, pendingTxn_3.txId, pendingTxn_3.time);
                }
            }, function (err) {
                console.log('Transaction not found', err);
            });
        }
    };
    BitcoinCashAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.currency.address;
            var txns = _this.bchPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    BitcoinCashAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.bchBlockExplorerService.getBalance(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = new Big(parseFloat(info) / 100000000).toFixed(8);
                _this.busy = false;
            });
        });
    };
    BitcoinCashAccountComponent = __decorate([
        RouteConfig('/bitcoin-cash-account/:account'),
        Component({
            selector: 'bitcoinCashAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/bitcoin-cash-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} BCH\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col tx-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col tx-col left\" flex>\n              <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://ltc1.heatwallet.com/tx/{{item.txId}}\">{{item.txId}}</a>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-bch-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-bch-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'bchBlockExplorerService', 'bchPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, BchBlockExplorerService,
            BchPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], BitcoinCashAccountComponent);
    return BitcoinCashAccountComponent;
}());
var EthereumAccountComponent = (function () {
    function EthereumAccountComponent($scope, web3, assetInfo, $q, user, ethBlockExplorerService, pendingService, settings, $interval, $mdToast, http) {
        this.$scope = $scope;
        this.web3 = web3;
        this.assetInfo = assetInfo;
        this.$q = $q;
        this.user = user;
        this.ethBlockExplorerService = ethBlockExplorerService;
        this.pendingService = pendingService;
        this.settings = settings;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.http = http;
        this.erc20Tokens = [];
        this.pendingTransactions = [];
        this.prevIndex = 0;
    }
    EthereumAccountComponent.prototype.$onInit = function () {
        var _this = this;
        this.personalize = this.account == this.user.currency.address;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        this.pendingService.addListener(listener);
        this.updatePendingTransactions();
        var promise = this.$interval(this.timerHandler.bind(this), 20000);
        this.timerHandler();
        this.$scope.$on('$destroy', function () {
            _this.pendingService.removeListener(listener);
            _this.$interval.cancel(promise);
        });
    };
    EthereumAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_4 = this.pendingTransactions[this.prevIndex];
            if (!utils.isHex(pendingTxn_4.txHash)) {
                this.pendingService.remove(pendingTxn_4.address, pendingTxn_4.txHash, pendingTxn_4.timestamp);
                return;
            }
            this.ethBlockExplorerService.getTxInfo(pendingTxn_4.txHash).then(function (data) {
                if (data.confirmations && data.confirmations > 0) {
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with hash ".concat(pendingTxn_4.txHash, " found")).hideDelay(2000));
                    _this.pendingService.remove(pendingTxn_4.address, pendingTxn_4.txHash, pendingTxn_4.timestamp);
                }
                if (data.error && data.error.indexOf("not found") > -1) {
                    _this.pendingService.remove(pendingTxn_4.address, pendingTxn_4.txHash, pendingTxn_4.timestamp);
                }
            }, function (err) {
                console.log('Transaction not found', err || "");
                if (!err) {
                    var minutesOld = (Date.now() - pendingTxn_4.timestamp) / (1000 * 60);
                    if (minutesOld > 60) {
                        _this.pendingService.remove(pendingTxn_4.address, pendingTxn_4.txHash, pendingTxn_4.timestamp);
                        console.log('Transaction was pending and is disappeared. Transaction is removed from pending list', pendingTxn_4);
                    }
                }
            });
        }
    };
    EthereumAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.currency.address;
            var txns = _this.pendingService.pending[addr];
            if (txns) {
                var format_3 = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.timestamp), format_3),
                        timestamp: tx.timestamp,
                        txHash: tx.txHash,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.timestamp - a.timestamp; });
                setTimeout(function () { return _this.loadPaymentMessages(); }, 1500);
            }
        });
    };
    EthereumAccountComponent.prototype.refresh = function () {
        var _this = this;
        var balances = wlt.getSavedCurrencyBalance(this.account, "ETH");
        this.balance = balances.confirmed || "*";
        this.balanceUnconfirmed = balances.unconfirmed;
        this.ethBlockExplorerService.getAddressInfo(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                var balances = wlt.getSavedCurrencyBalance(_this.account, "ETH", info.ETH.balance);
                _this.balance = balances.confirmed || "*";
                _this.balanceUnconfirmed = balances.unconfirmed;
                if (info.tokens) {
                    _this.erc20Tokens = info.tokens.map(function (token) {
                        var tokenInfo = _this.ethBlockExplorerService.tokenInfoCache[token.tokenInfo.address];
                        var balance = token.balance
                            ? utils.formatERC20TokenAmount(new Big(token.balance + "").toFixed(), tokenInfo ? tokenInfo.decimals : 18)
                            : "";
                        return {
                            balance: balance,
                            symbol: token.tokenInfo.symbol,
                            name: token.tokenInfo.name,
                            id: ''
                        };
                    });
                }
            });
        });
        this.loadPaymentMessages();
    };
    EthereumAccountComponent.prototype.loadPaymentMessages = function () {
        var _loop_3 = function (ptx) {
            if (ptx.message === undefined) {
                wlt.loadPaymentMessage(ptx.txHash)
                    .then(function (v) { return ptx.message = v; })
                    .catch(function (reason) { return console.warn("payment message is not loaded: " + JSON.stringify(reason)); });
            }
        };
        for (var _i = 0, _a = this.pendingTransactions; _i < _a.length; _i++) {
            var ptx = _a[_i];
            _loop_3(ptx);
        }
    };
    EthereumAccountComponent.prototype.addressDetails = function ($event, address) {
        this.http.get("https://eth1.heatwallet.com/api/v2/address/" + address).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed) {
                parsed.renderedAmount = (parsed.balance || 0) / 1000000000000000000 + " ETH";
                var fields = [["address"], ["renderedAmount", "balance"], ["txs", "number of transactions"], ["nonce"]];
                dialogs.jsonDetails(null, parsed, 'Address: ' + parsed.address, fields, null, true);
            }
        }).catch(function (reason) {
            if (reason)
                console.error(reason);
        });
    };
    EthereumAccountComponent = __decorate([
        RouteConfig('/ethereum-account/:account'),
        Component({
            selector: 'ethereumAccount',
            inputs: ['account'],
            styles: ["\n    .value a {\n      text-decoration: none !important;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.addressDetails($event, vm.account)\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance:\n            </div>\n            <div class=\"value\">\n              {{vm.balance}} ETH\n              <span style=\"font-size: small\" ng-if=\"vm.balanceUnconfirmed\"><br>{{vm.balanceUnconfirmed}} (unconfirmed)</span>\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\" flex>\n          <div class=\"col-item\" flex layout-fill>\n            <div class=\"title\">\n              ERC-20 Tokens:\n            </div>\n            <div class=\"scrollable\">\n              <div class=\"value\" ng-repeat=\"item in vm.erc20Tokens\">\n                <span class=\"balance\">{{item.balance}}</span>\n                <span class=\"symbol\"><b>{{item.symbol}}</b></span>\n                <span class=\"balance\">Token: {{item.name}}</span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Hash</div>\n              <div class=\"truncate-col left\" flex>Message</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://eth1.heatwallet.com/api/v2/tx/{{item.txHash}}\">{{item.txHash}}</a>\n              </div>\n              <div class=\"truncate-col left\" ng-if=\"item.message\">\n                <span style=\"opacity: 0.5\">[{{item.message.method == 0 ? \"local\" : \"HEAT\"}}]</span> \n                {{item.message.text}}\n                <md-tooltip md-delay=\"800\">{{item.message.text}}</md-tooltip>\n              </div>\n              <span ng-if=\"!item.message\" class=\"truncate-col left\" style=\"opacity: 0.5\">--</span>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-eth-transactions layout=\"column\" flex layout-fill account=\"vm.account\" personalize=\"vm.personalize\"></virtual-repeat-eth-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'web3', 'assetInfo', '$q', 'user', 'ethBlockExplorerService', 'ethereumPendingTransactions', 'settings', '$interval', '$mdToast', 'http'),
        __metadata("design:paramtypes", [Object, Web3Service,
            AssetInfoService, Function, UserService,
            EthBlockExplorerService,
            EthereumPendingTransactionsService,
            SettingsService, Function, Object, HttpService])
    ], EthereumAccountComponent);
    return EthereumAccountComponent;
}());
var HomeComponent = (function () {
    function HomeComponent(user) {
        this.user = user;
        user.requireLogin();
        user.on(UserService.EVENT_UNLOCKED, function () {
        });
    }
    HomeComponent = __decorate([
        RouteConfig('/home'),
        Component({
            selector: 'home',
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill>\n      <virtual-repeat-transactions layout=\"column\" flex account=\"vm.user.account\" personalize=\"true\"></virtual-repeat-transactions>\n      <!-- <virtual-repeat-eth-transactions layout=\"column\" flex account=\"vm.user.account\" personalize=\"true\"></virtual-repeat-eth-transactions> -->\n    </div>\n  "
        }),
        Inject('user'),
        __metadata("design:paramtypes", [UserService])
    ], HomeComponent);
    return HomeComponent;
}());
var IotaAccountComponent = (function () {
    function IotaAccountComponent($scope, iotaBlockExplorerService, iotaPendingTransactions, $interval, $mdToast, settings, user) {
        this.$scope = $scope;
        this.iotaBlockExplorerService = iotaBlockExplorerService;
        this.iotaPendingTransactions = iotaPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
    }
    IotaAccountComponent.prototype.$onInit = function () {
        var _this = this;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        this.iotaPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = this.$interval(this.timerHandler.bind(this), 30000);
        this.timerHandler();
        this.$scope.$on('$destroy', function () {
            _this.iotaPendingTransactions.removeListener(listener);
            _this.$interval.cancel(promise);
        });
    };
    IotaAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.iotaBlockExplorerService.getAccountInfo(this.user.currency.secretPhrase)
                .then(function (recentTransactions) {
                for (var i = 0; i < _this.pendingTransactions.length; i++) {
                    var isPending = true;
                    for (var j = 0; j < recentTransactions.transfers.length; j++) {
                        if (recentTransactions.transfers[j].hash == _this.pendingTransactions[i].txId) {
                            isPending = false;
                            break;
                        }
                    }
                    if (!isPending) {
                        _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id ".concat(_this.pendingTransactions[i].txId, " found")).hideDelay(2000));
                        _this.iotaPendingTransactions.remove(_this.pendingTransactions[i].address, _this.pendingTransactions[i].txId, _this.pendingTransactions[i].time);
                    }
                }
            }, function (err) {
                console.log('Error in getting recent IOTA Transactions ' + err);
            })
                .catch(function (reason) { return console.error(reason); });
        }
    };
    IotaAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.currency.address;
            var txns = _this.iotaPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    IotaAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.iotaBlockExplorerService.getAccountInfo(this.user.currency.secretPhrase)
            .then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = info ? info.accountData.balance : 0;
                _this.busy = false;
            });
        })
            .catch(function (reason) { return console.error(reason); });
    };
    IotaAccountComponent = __decorate([
        RouteConfig('/iota-account/:account'),
        Component({
            selector: 'iotaAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/iota-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} IOTA\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <span>{{item.txId}}</span>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-iota-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-iota-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'iotaBlockExplorerService', 'iotaPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, IotaBlockExplorerService,
            IotaPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], IotaAccountComponent);
    return IotaAccountComponent;
}());
var ExploreAccountComponent = (function () {
    function ExploreAccountComponent($scope, heat, assetInfo, $q, panel) {
        this.$scope = $scope;
        this.heat = heat;
        this.assetInfo = assetInfo;
        this.$q = $q;
        this.panel = panel;
        this.assetInfos = [];
    }
    ExploreAccountComponent.prototype.$onInit = function () {
        var _this = this;
        this.refresh();
        this.heat.subscriber.balanceChanged({ account: this.account, currency: "0" }, function () {
            _this.refresh();
        }, this.$scope);
    };
    ExploreAccountComponent.prototype.csv = function ($event) {
        dialogs.download($event, this.account);
    };
    ExploreAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.accountName = "*";
        this.email = "*";
        this.publicKey = "*";
        this.firstSeen = "*";
        this.lease = "*";
        this.leaseBlocksRemain = "*";
        this.totalRewards = "*";
        this.effectiveBalance = "*";
        this.balanceUnconfirmed = "*";
        this.balanceConfirmed = "*";
        this.heat.api.getPublicKey(this.account).then(function (publicKey) {
            _this.$scope.$evalAsync(function () {
                _this.publicKey = publicKey;
            });
        });
        this.heat.api.getAccountByNumericId(this.account).then(function (account) {
            _this.$scope.$evalAsync(function () {
                _this.accountName = account.publicName;
                _this.balanceConfirmed = utils.formatQNT(account.balance, 8);
                _this.effectiveBalance = utils.formatQNT(account.effectiveBalance, 8);
                _this.balanceUnconfirmed = utils.formatQNT(account.unconfirmedBalance, 8);
                _this.guaranteedBalance = utils.formatQNT(account.guaranteedBalance, 8);
                _this.currentLessee = account.currentLessee;
                _this.currentLesseeName = account.currentLesseeName || account.currentLessee;
                _this.currentLeasingHeightFrom = account.currentLeasingHeightFrom;
                _this.currentLeasingHeightTo = account.currentLeasingHeightTo;
                _this.nextLessee = account.nextLessee;
                _this.nextLesseeName = account.nextLesseeName || account.nextLessee;
                _this.nextLeasingHeightFrom = account.nextLeasingHeightFrom;
                _this.nextLeasingHeightTo = account.nextLeasingHeightTo;
                _this.lessors = account.lessors;
                _this.lessorsBalance = utils.formatQNT(account.lessorsBalance, 8);
                _this.supervisoryAccount = account.supervisoryAccount;
                if (angular.isArray(_this.lessors)) {
                    _this.lessors.forEach(function (lessor) {
                        lessor.balance = utils.formatQNT(lessor.effectiveBalance, 8) + " HEAT";
                        if (lessor.nextLessee == "0") {
                            lessor.nextLessee = "";
                        }
                        if (lessor.nextHeightFrom == 2147483647 || lessor.nextHeightFrom == lessor.currentHeightFrom) {
                            lessor.nextHeightFrom = "";
                        }
                        if (lessor.nextHeightTo == 2147483647) {
                            lessor.nextHeightTo = "";
                        }
                    });
                }
            });
            if (_this.currentLessee != "0") {
                _this.heat.api.getBlockchainStatus().then(function (status) {
                    _this.$scope.$evalAsync(function () {
                        _this.currentLeasingRemain = status.lastBlockchainFeederHeight - account.currentLeasingHeightTo;
                        _this.leaseTitle = "from ".concat(_this.currentLeasingHeightFrom, " to ").concat(_this.currentLeasingHeightTo, " remain ").concat(_this.currentLeasingRemain);
                        _this.nextLeaseTitle = "from ".concat(_this.nextLeasingHeightFrom, " to ").concat(_this.nextLeasingHeightTo);
                    });
                });
            }
        });
        this.getAccountAssets().then(function (assetInfos) {
            _this.$scope.$evalAsync(function () {
                _this.assetInfos = assetInfos
                    .filter(function (info) { return parseFloat(info.userBalance) !== 0; })
                    .map(function (info) {
                    info['balance'] = utils.formatQNT(info.userBalance, info.decimals);
                    return info;
                });
            });
        });
        this.heat.api.rewardsAccount(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.totalRewards = utils.commaFormat(utils.formatQNT(info.totalRewards, 8));
            });
        }).catch(function (reason) {
            if (reason.code == 3) {
            }
            else {
                console.error(reason);
            }
        });
    };
    ExploreAccountComponent.prototype.showDescription = function ($event, info) {
        dialogs.assetInfo($event, info);
    };
    ExploreAccountComponent.prototype.showPublicKey = function ($event) {
        this.panel.show("\n      <div layout=\"column\" flex class=\"toolbar-copy-passphrase\">\n        <md-input-container flex>                                                                                                                                                           \n          <div>Public key:</div>\n          <div>{{vm.publicKey}}</div>\n        </md-input-container>\n      </div>\n    ", {
            publicKey: this.publicKey
        });
    };
    ExploreAccountComponent.prototype.getAccountAssets = function () {
        var _this = this;
        var deferred = this.$q.defer();
        this.heat.api.getAccountBalances(this.account, "0", 1, 0, 100).then(function (balances) {
            var assetInfos = [];
            var promises = [];
            balances.forEach(function (balance) {
                if (balance.id != '0') {
                    promises.push(_this.assetInfo.getInfo(balance.id).then(function (info) {
                        var accountAssetInfo = angular.extend({}, info, {
                            userBalance: balance.virtualBalance
                        });
                        assetInfos.push(accountAssetInfo);
                    }));
                }
            });
            if (promises.length > 0) {
                _this.$q.all(promises).then(function () {
                    assetInfos.sort(function (a, b) {
                        var textA = a.symbol.toUpperCase();
                        var textB = b.symbol.toUpperCase();
                        return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;
                    });
                    deferred.resolve(assetInfos);
                }, deferred.reject);
            }
            else {
                deferred.resolve([]);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    ExploreAccountComponent = __decorate([
        RouteConfig('/explorer-account/:account/:type'),
        Component({
            selector: 'explorerAccount',
            inputs: ['account', 'type'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <explorer-search layout=\"column\" type=\"''\" query=\"''\"></explorer-search>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Account:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.showPublicKey()\">{{vm.accountName||vm.account}}</a>\n            </div>\n            <div ng-if=\"vm.supervisoryAccount\" style=\"font-size: x-small; margin-bottom: 6px;\">\n              under control <a href=\"#/explorer-account/{{vm.supervisoryAccount}}/transactions\">{{vm.supervisoryAccount}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Numeric account id:\n            </div>\n            <div class=\"value\">\n              {{vm.account}}\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance:\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} HEAT\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Effective balance:\n            </div>\n            <div class=\"value\">\n              {{vm.effectiveBalance}} HEAT\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Lease: [{{vm.leaseTitle}}]\n            </div>\n            <div class=\"value\">\n              <span ng-if=\"vm.currentLessee=='0'\">None</span>\n              <span ng-if=\"vm.currentLessee!='0'\">\n                <a href=\"#/explorer-account/{{vm.currentLessee}}/{{vm.type}}\">{{vm.currentLesseeName}}</a>\n              </span>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Next lease: [{{vm.nextLeaseTitle}}]\n            </div>\n            <div class=\"value\">\n              <span ng-if=\"vm.nextLessee=='0'\">None</span>\n              <span ng-if=\"vm.nextLessee!='0'\">\n                <a href=\"#/explorer-account/{{vm.nextLessee}}/{{vm.type}}\">{{vm.nextLesseeName}}</a>\n              </span>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Amount leased in:\n            </div>\n            <div class=\"value\">\n              {{vm.lessorsBalance}} HEAT\n            </div>\n          </div>\n          <div class=\"col-item\" ng-if=\"vm.currentLessee!='0'\">\n            <div class=\"title\">\n              Amount leased out:\n            </div>\n            <div class=\"value\">\n              {{vm.guaranteedBalance}} HEAT\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\" flex>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Total rewards:\n            </div>\n            <div class=\"value\">\n              {{vm.totalRewards}}\n            </div>\n          </div>\n          <div class=\"col-item\" flex layout-fill>\n            <div class=\"title\">\n              Assets:\n            </div>\n            <div class=\"scrollable\">\n              <div class=\"value\" ng-class=\"{expired: item.expired}\" ng-repeat=\"item in vm.assetInfos\">\n                <span class=\"balance\">{{item.balance}}</span>\n                <span class=\"symbol\"><b>{{item.symbol}}</b></span>\n                <span class=\"name\">\n                  <a ng-click=\"vm.showDescription($event, item)\">{{item.name}}</a>\n                </span>\n                <span class=\"issuer\">\n                  Issued by: <a href=\"#/explorer-account/{{item.issuer}}/{{vm.type}}\">{{item.issuerPublicName||item.issuer}}</a>\n                </span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div layout=\"row\" layout-align=\"start center\" class=\"type-row\">\n        <md-button ng-class=\"{'active':vm.type=='transactions'}\"\n          ng-disabled=\"vm.type=='transactions'\"\n          ng-href=\"#/explorer-account/{{vm.account}}/transactions\">Transactions</md-button>\n        <md-button ng-class=\"{'active':vm.type=='blocks'}\"\n          ng-disabled=\"vm.type=='blocks'\"\n          ng-href=\"#/explorer-account/{{vm.account}}/blocks\">Blocks</md-button>\n        <md-button ng-class=\"{'active':vm.type=='lessors'}\"\n          ng-disabled=\"vm.type=='lessors'\"\n          ng-href=\"#/explorer-account/{{vm.account}}/lessors\">Lessors</md-button>\n        <md-button ng-class=\"{'active':vm.type=='trades'}\"\n          ng-disabled=\"vm.type=='trades'\"\n          ng-href=\"#/explorer-account/{{vm.account}}/trades\">Trades</md-button>\n        <md-button ng-class=\"{'active':vm.type=='payments'}\"\n          ng-disabled=\"vm.type=='payments'\"\n          ng-href=\"#/explorer-account/{{vm.account}}/payments\">Payments</md-button>\n        <span flex></span>\n        <md-button ng-click=\"vm.csv($event)\">Download CSV</md-button>\n      </div>\n      <div ng-if=\"vm.type=='transactions'\" flex layout=\"column\">\n        <virtual-repeat-transactions hide-label=\"true\" layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-transactions>\n      </div>\n      <div ng-if=\"vm.type=='blocks'\" flex layout=\"column\">\n        <explorer-latest-blocks layout=\"column\" flex account=\"vm.account\" hide-label=\"true\"></explorer-latest-blocks>\n      </div>\n      <div ng-if=\"vm.type=='trades'\" flex layout=\"column\">\n        <virtual-repeat-trades hide-label=\"true\" layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-trades>\n      </div>\n      <div ng-if=\"vm.type=='payments'\" flex layout=\"column\">\n        <virtual-repeat-payments hide-label=\"true\" layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-payments>\n      </div>\n      <div ng-if=\"vm.type=='lessors'\" flex layout=\"column\" layout-fill>\n        <md-list flex layout-fill layout=\"column\" class=\"lessors\">\n          <md-list-item class=\"header\">\n            <div class=\"truncate-col id-col left\">ID</div>\n            <div class=\"truncate-col balance-col left\">Balance</div>\n            <div class=\"truncate-col from-col left\">From</div>\n            <div class=\"truncate-col to-col left\">To</div>\n            <div class=\"truncate-col next-lessee-col\">Next</div>\n            <div class=\"truncate-col from-col\">From</div>\n            <div class=\"truncate-col to-col\" flex>To</div>\n          </md-list-item>\n          <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n            <md-list-item md-virtual-repeat=\"item in vm.lessors\" aria-label=\"Entry\">\n              <div class=\"truncate-col id-col left\">\n                <a href=\"#/explorer-account/{{item.id}}/transactions\">{{item.id}}</a>\n              </div>\n              <div class=\"truncate-col balance-col\">\n                {{item.balance}}\n              </div>\n              <div class=\"truncate-col from-col left\">\n                {{item.currentHeightFrom}}\n              </div>\n              <div class=\"truncate-col to-col left\">\n                {{item.currentHeightTo}}\n              </div>\n              <div class=\"truncate-col next-lessee-col\">\n                <a ng-if=\"item.nextLessee\" href=\"#/explorer-account/{{item.nextLessee}}/transactions\">{{item.nextLessee}}</a>\n              </div>\n              <div class=\"truncate-col from-col\">\n                {{item.nextHeightFrom}}\n              </div>\n              <div class=\"truncate-col to-col\" flex>\n                {{item.nextHeightTo}}\n              </div>\n            </md-list-item>\n          </md-virtual-repeat-container>\n        </md-list>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'heat', 'assetInfo', '$q', 'panel'),
        __metadata("design:paramtypes", [Object, HeatService,
            AssetInfoService, Function, PanelService])
    ], ExploreAccountComponent);
    return ExploreAccountComponent;
}());
var ExplorerBlockComponent = (function () {
    function ExplorerBlockComponent($scope, heat, settings) {
        this.$scope = $scope;
        this.heat = heat;
        this.settings = settings;
    }
    ExplorerBlockComponent.prototype.$onInit = function () {
        var _this = this;
        this.heat.api.getBlock(this.block).then(function (block) {
            _this.$scope.$evalAsync(function () {
                _this.generator = block.generator;
                _this.generatorPublicName = block['generatorPublicName'];
                _this.totalAmount = utils.formatQNT(block.totalAmountHQT, 8);
                _this.totalFee = utils.formatQNT(block.totalFeeHQT, 8);
                _this.popReward = utils.formatQNT(block.popRewardHQT, 8);
                _this.posReward = utils.formatQNT(block.posRewardHQT, 8);
                var date = utils.timestampToDate(block.timestamp);
                _this.time = dateFormat(date, _this.settings.get(SettingsService.DATEFORMAT_DEFAULT));
                _this.height = block.height;
                _this.blockObject = block;
            });
        });
    };
    ExplorerBlockComponent.prototype.jsonDetails = function ($event, item) {
        var fields = [["block", "block id"], ["generator", "generator account"], ["height", "block height"], ["time"], ["amount"], ["fee"], ["pos", "POS reward"], ["pop", "POP reward"]];
        dialogs.jsonDetails($event, item, 'Block: ' + item.block, fields);
    };
    ExplorerBlockComponent = __decorate([
        RouteConfig('/explorer-block/:block'),
        Component({
            selector: 'explorerBlock',
            inputs: ['block'],
            styles: ["\n    explorer-block h3 {\n      font-size: 24px !important;\n      font-weight: bold;\n      padding-bottom: 0px;\n      margin-bottom: 0px;\n    }\n    explorer-block a {\n      cursor: pointer;\n    }\n    explorer-block a i {\n      font-size: 14px !important;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill layout-padding >\n      <explorer-search layout=\"column\" type=\"''\" query=\"''\"></explorer-search>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Height:\n            </div>\n            <div class=\"value\">\n              {{vm.height}}\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Time:\n            </div>\n            <div class=\"value\">\n              {{vm.time}}\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Block id:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/explorer-block/{{vm.block}}\">{{vm.block}}</a>\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Generator:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/explorer-account/{{vm.generator}}/transactions\">{{vm.generatorPublicName||vm.generator}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Total amount:\n            </div>\n            <div class=\"value\">\n              {{vm.totalAmount}} HEAT\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Total fee:\n            </div>\n            <div class=\"value\">\n              {{vm.totalFee}} HEAT\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\" flex>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              POP reward:\n            </div>\n            <div class=\"value\">\n              {{vm.popReward}} HEAT\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              POS reward:\n            </div>\n            <div class=\"value\">\n              {{vm.posReward}} HEAT\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              JSON:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.jsonDetails($event, vm.blockObject)\">Show <i class=\"material-icons\">code</i></a>\n            </div>\n          </div>\n        </div>\n      </div>\n      <virtual-repeat-transactions layout=\"column\" flex layout-fill block=\"vm.block\"></virtual-repeat-transactions>\n    </div>\n  "
        }),
        Inject('$scope', 'heat', 'settings'),
        __metadata("design:paramtypes", [Object, HeatService,
            SettingsService])
    ], ExplorerBlockComponent);
    return ExplorerBlockComponent;
}());
var ExplorerLatestBlocksComponent = (function (_super) {
    __extends(ExplorerLatestBlocksComponent, _super);
    function ExplorerLatestBlocksComponent($scope, $q, heat, latestBlocksProviderFactory, settings) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.heat = heat;
        _this.latestBlocksProviderFactory = latestBlocksProviderFactory;
        _this.settings = settings;
        _this.minerHeader = "Miner";
        _this.popHeaderOrig = "POP reward";
        _this.popHeader = _this.popHeaderOrig;
        return _this;
    }
    ExplorerLatestBlocksComponent.prototype.$onInit = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var headerInitialized = false;
        this.initializeVirtualRepeat(this.latestBlocksProviderFactory.createProvider(this.blockObject, this.account), function (block) {
            var date = utils.timestampToDate(block.timestamp);
            block.time = dateFormat(date, format);
            block.amount = utils.formatQNT(block.totalAmountHQT, 8) + " HEAT";
            block.fee = utils.trimDecimals(utils.formatQNT(block.totalFeeHQT, 8), 2) + " HEAT";
            block.pos = utils.trimDecimals(utils.formatQNT(block.posRewardHQT, 8), 2) + " HEAT";
            block.pop = utils.trimDecimals(utils.formatQNT(block.popRewardHQT, 8), 2) + " HEAT";
            if (!headerInitialized) {
                _this.minerHeader = "Miner (".concat(utils.trimDecimals(utils.formatQNT(block.posRewardHQT, 8), 2), " HEAT)");
                headerInitialized = true;
            }
            if (_this.popHeader == _this.popHeaderOrig && block.popRewardHQT != '0') {
                _this.popHeader = "POP reward (".concat(utils.trimDecimals(utils.formatQNT(block.popRewardHQT, 8), 2), " HEAT)");
            }
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        this.heat.subscriber.blockPopped({}, refresh, this.$scope);
        this.heat.subscriber.blockPushed({}, refresh, this.$scope);
    };
    ExplorerLatestBlocksComponent.prototype.jsonDetails = function ($event, item) {
        var fields = [["block"], ["generator", "generator account"], ["height", "block height"], ["time"], ["amount"], ["fee"], ["pos", "POS reward"], ["pop", "POP reward"]];
        dialogs.jsonDetails($event, item, 'Block: ' + item.block, fields);
    };
    ExplorerLatestBlocksComponent.prototype.onSelect = function (selectedBlock) {
    };
    ExplorerLatestBlocksComponent = __decorate([
        Component({
            selector: 'explorerLatestBlocks',
            inputs: ['blockObject', 'account', 'hideLabel'],
            styles: ["\n  .he {\n    min-width: 40px !important;\n    max-width: 70px !important;\n  }\n  .tx {\n    min-width: 20px !important;\n    max-width: 40px !important;\n  }\n  .fee {\n    max-width: 70px !important;\n  }\n  .loadingIcon {\n    color: grey;\n    flex: auto;\n    margin-left: 10px;\n  }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">\n      <div>Latest Blocks</div>\n      <div><md-icon md-font-library=\"material-icons\" class=\"loadingIcon rotate\" ng-if=\"vm.loadedPages.inProgress\">sync</md-icon></div>\n      </div>\n\n      <md-list flex layout-fill layout=\"column\" >\n        <md-list-item class=\"header\">\n          <div class=\"he truncate-col height-col left\">Height</div>\n          <div class=\"truncate-col date-col left\">Time</div>\n          <div class=\"truncate-col block-col block left\">Block</div>\n          <div class=\"truncate-col generator-col block left\" ng-if=\"!vm.account\">{{vm.minerHeader}}</div>\n          <div class=\"tx truncate-col transactions-col\">Tx</div>\n          <div class=\"truncate-col amount-col\">Amount</div>\n          <div class=\"fee truncate-col fee-col\">Fees</div>\n          <div class=\"truncate-col pop-col left\" flex>{{vm.popHeader}}</div>\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\">\n            <div class=\"he truncate-col height-col left\">{{item.height}}</div>\n            <div class=\"truncate-col date-col left\">{{item.time}}</div>\n            <div class=\"truncate-col block-col block left\"><a href=\"#/explorer-block/{{item.block}}\">{{item.block}}</a></div>\n            <div class=\"truncate-col generator-col block left\" ng-if=\"!vm.account\">\n                <a href=\"#/explorer-account/{{item.generator}}/transactions\">{{item.generatorPublicName||item.generator}}</a>\n            </div>\n            <div class=\"tx truncate-col transactions-col\">{{item.numberOfTransactions}}</div>\n            <div class=\"truncate-col amount-col\">{{item.amount}}</div>\n            <div class=\"fee truncate-col fee-col\">{{item.fee}}</div>\n            <div class=\"truncate-col pop-col left\" flex>\n                <a ng-if=\"item.popRewardHQT != '0'\" href=\"#/explorer-account/{{item.generator}}/transactions\">{{item.generatorPublicName||item.generator}}</a>\n            </div>\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'latestBlocksProviderFactory', 'settings'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            LatestBlocksProviderFactory,
            SettingsService])
    ], ExplorerLatestBlocksComponent);
    return ExplorerLatestBlocksComponent;
}(VirtualRepeatComponent));
var ExplorerResultsAccountsComponent = (function (_super) {
    __extends(ExplorerResultsAccountsComponent, _super);
    function ExplorerResultsAccountsComponent($scope, $q, searchAccountsProviderFactory) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.searchAccountsProviderFactory = searchAccountsProviderFactory;
        return _this;
    }
    ExplorerResultsAccountsComponent.prototype.$onInit = function () {
        this.initializeVirtualRepeat(this.searchAccountsProviderFactory.createProvider(this.query), function (account) {
            account.balanceFormatted = utils.formatQNT(account.unconfirmedBalance, 8);
            if (account.publicName == account.id) {
                account.publicName = '[private]';
            }
        });
    };
    ExplorerResultsAccountsComponent.prototype.onSelect = function (selectedAccount) {
    };
    ExplorerResultsAccountsComponent = __decorate([
        Component({
            selector: 'explorerResultsAccounts',
            inputs: ['query'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col id-col left\">Account</div>\n          <div class=\"truncate-col balance-col\">Balance</div>\n          <div class=\"truncate-col name-col left\" flex>Name</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\">\n            <div class=\"truncate-col id-col left\"><a href=\"#/explorer-account/{{item.id}}/transactions\">{{item.id}}</a></div>\n            <div class=\"truncate-col balance-col\">{{item.balanceFormatted}}</div>\n            <div class=\"truncate-col name-col left\" flex>{{item.publicName}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'searchAccountsProviderFactory'),
        __metadata("design:paramtypes", [Object, Function, SearchAccountsProviderFactory])
    ], ExplorerResultsAccountsComponent);
    return ExplorerResultsAccountsComponent;
}(VirtualRepeatComponent));
var ExplorerResultsComponent = (function () {
    function ExplorerResultsComponent($scope, heat, $location) {
        this.$scope = $scope;
        this.heat = heat;
        this.$location = $location;
    }
    ExplorerResultsComponent.prototype.$onInit = function () {
        var _this = this;
        if (this.type === 'search' || this.type === 'accounts') {
            this.heat.api.searchAccountsCount(this.query).then(function (count) {
                _this.$scope.$evalAsync(function () {
                    if (_this.type === 'search' && count > 0) {
                        _this.type = 'accounts';
                        _this.$location.path("/explorer-results/".concat(_this.type, "/").concat(_this.query));
                    }
                });
            });
        }
        if (this.type === 'search' || this.type === 'blocks') {
            this.heat.api.getBlock(this.query, true).then(function (block) {
                _this.$scope.$evalAsync(function () {
                    _this.blockObject = block;
                    if (_this.type === 'search') {
                        _this.type = 'blocks';
                        _this.$location.path("/explorer-results/".concat(_this.type, "/").concat(_this.query));
                    }
                });
            }, function () {
                var height = parseInt(_this.query);
                if (!isNaN(height)) {
                    _this.heat.api.getBlockAtHeight(height, true).then(function (block) {
                        _this.$scope.$evalAsync(function () {
                            _this.blockObject = block;
                            if (_this.type === 'search') {
                                _this.type = 'blocks';
                                _this.$location.path("/explorer-results/".concat(_this.type, "/").concat(_this.query));
                            }
                        });
                    });
                }
            });
        }
        if (this.type === 'search' || this.type === 'transactions') {
            this.heat.api.getTransaction(this.query).then(function (transaction) {
                _this.$scope.$evalAsync(function () {
                    _this.transactionObject = transaction;
                    if (_this.type === 'search') {
                        _this.type = 'transactions';
                        _this.$location.path("/explorer-results/".concat(_this.type, "/").concat(_this.query));
                    }
                });
            });
        }
    };
    ExplorerResultsComponent = __decorate([
        RouteConfig('/explorer-results/:type/', '/explorer-results/:type/:query'),
        Component({
            selector: 'explorerResults',
            inputs: ['type', 'query'],
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill>\n      <explorer-search layout=\"column\" query=\"vm.query\"></explorer-search>\n      <div layout=\"row\" layout-align=\"start center\" class=\"type-row\">\n        <md-button ng-class=\"{'active':vm.type=='accounts'}\"\n          ng-disabled=\"vm.type=='accounts'\"\n          ng-href=\"#/explorer-results/accounts/{{vm.query}}\">Accounts</md-button>\n        <md-button ng-class=\"{'active':vm.type=='blocks'}\"\n          ng-disabled=\"vm.type=='blocks'\"\n          ng-href=\"#/explorer-results/blocks/{{vm.query}}\">Blocks</md-button>\n        <md-button ng-class=\"{'active':vm.type=='transactions'}\"\n          ng-disabled=\"vm.type=='transactions'\"\n          ng-href=\"#/explorer-results/transactions/{{vm.query}}\">Transactions</md-button>\n      </div>\n\n      <!-- ACCOUNTS -->\n      <div layout=\"column\" flex ng-if=\"vm.type=='accounts'\">\n        <explorer-results-accounts query=\"vm.query\" flex layout=\"column\"></explorer-results-accounts>\n      </div>\n\n      <!-- BLOCKS -->\n      <div layout=\"column\" flex ng-if=\"vm.type=='blocks'\">\n        <explorer-latest-blocks ng-if=\"vm.blockObject\" layout=\"column\" flex block-object=\"vm.blockObject\"></explorer-latest-blocks>\n        <span ng-if=\"!vm.blockObject\">\n          No blocks found with that height or id.\n        </span>\n      </div>\n\n      <!-- TRANSACTIONS -->\n      <div layout=\"column\" flex ng-if=\"vm.type=='transactions'\">\n        <virtual-repeat-transactions ng-if=\"vm.transactionObject\" layout=\"column\" flex transaction-object=\"vm.transactionObject\"></virtual-repeat-transactions>\n        <span ng-if=\"!vm.transactionObject\">\n          No transaction found with that id.\n        </span>\n      </div>\n\n      <div layout=\"column\" flex ng-if=\"vm.type=='search'\">No results found</div>\n\n    </div>\n  "
        }),
        Inject('$scope', 'heat', '$location'),
        __metadata("design:paramtypes", [Object, HeatService, Object])
    ], ExplorerResultsComponent);
    return ExplorerResultsComponent;
}());
var ExplorerRewardsBlocksComponent = (function (_super) {
    __extends(ExplorerRewardsBlocksComponent, _super);
    function ExplorerRewardsBlocksComponent($scope, $q, heat, rewardsProviderFactory, settings) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.heat = heat;
        _this.rewardsProviderFactory = rewardsProviderFactory;
        _this.settings = settings;
        return _this;
    }
    ExplorerRewardsBlocksComponent.prototype.$onInit = function () {
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        this.initializeVirtualRepeat(this.rewardsProviderFactory.createProvider(), function (reward) {
            reward['effectiveBalanceFormatted'] = utils.commaFormat(reward.effectiveBalance) + " HEAT";
            reward['totalRewardsFormatted'] = utils.commaFormat(utils.formatQNT(reward.totalRewards, 8)) + " HEAT";
        });
        var refresh = utils.debounce(angular.bind(this, this.determineLength), 500, false);
        this.heat.subscriber.blockPopped({}, refresh, this.$scope);
        this.heat.subscriber.blockPushed({}, refresh, this.$scope);
    };
    ExplorerRewardsBlocksComponent.prototype.onSelect = function (selectedBlock) { };
    ExplorerRewardsBlocksComponent = __decorate([
        RouteConfig('/explorer-rewards'),
        Component({
            selector: 'explorerRewards',
            template: "\n    <div layout=\"column\" flex layout-fill layout-padding>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Forging Rewards\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col account-col left\">Account</div>\n          <div class=\"truncate-col effective-col block left\">Effective Balance</div>\n          <div class=\"truncate-col total-col left\">Total Rewards</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\">\n            <div class=\"truncate-col account-col left\">\n              <a href=\"#/explorer-account/{{item.account}}/transactions\">{{item.accountName||item.account}}</a>\n            </div>\n            <div class=\"truncate-col effective-col block left\">{{item.effectiveBalanceFormatted}}</div>\n            <div class=\"truncate-col total-col left\">{{item.totalRewardsFormatted}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'rewardsProviderFactory', 'settings'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            RewardsProviderFactory,
            SettingsService])
    ], ExplorerRewardsBlocksComponent);
    return ExplorerRewardsBlocksComponent;
}(VirtualRepeatComponent));
var ExplorerSearchComponent = (function () {
    function ExplorerSearchComponent($scope, $location) {
        this.$scope = $scope;
        this.$location = $location;
    }
    ExplorerSearchComponent.prototype.onKeyPress = function ($event) {
        if ($event.keyCode == 13) {
            var type = this.type || 'search';
            var query = this.query || '';
            this.$location.path("/explorer-results/".concat(type, "/").concat(query));
        }
    };
    ExplorerSearchComponent = __decorate([
        Component({
            selector: 'explorerSearch',
            inputs: ['type', 'query'],
            template: "\n    <div layout=\"row\" flex layout-fill>\n      <md-input-container flex>\n        <label>Search for account id, account public names, transaction id, block id or block height</label>\n        <input name=\"search-text\" ng-model=\"vm.query\" ng-keypress=\"vm.onKeyPress($event)\">\n      </md-input-container>\n    </div>\n  "
        }),
        Inject('$scope', '$location'),
        __metadata("design:paramtypes", [Object, Object])
    ], ExplorerSearchComponent);
    return ExplorerSearchComponent;
}());
var ExplorerComponent = (function () {
    function ExplorerComponent($scope) {
        this.$scope = $scope;
    }
    ExplorerComponent = __decorate([
        RouteConfig('/explorer'),
        Component({
            selector: 'explorer',
            styles: ["\n    explorer h3 {\n      font-size: 24px !important;\n      font-weight: bold;\n      padding-bottom: 0px;\n      margin-bottom: 0px;\n    }\n    explorer md-list-item.active {\n      background-color: #B2DFDB;\n    }\n    explorer .wallet {\n      height: 32px;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill>\n      <explorer-search layout=\"column\" type=\"''\" query=\"''\"></explorer-search>\n      <explorer-latest-blocks layout=\"column\" flex=\"30\"></explorer-latest-blocks>\n      <virtual-repeat-transactions layout=\"column\" flex=\"60\"></virtual-repeat-transactions>\n    </div>\n  "
        }),
        Inject('$scope'),
        __metadata("design:paramtypes", [Object])
    ], ExplorerComponent);
    return ExplorerComponent;
}());
var RewardsProviderFactory = (function () {
    function RewardsProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    RewardsProviderFactory.prototype.createProvider = function () {
        return new RewardsProvider(this.heat, this.$q);
    };
    RewardsProviderFactory = __decorate([
        Service('rewardsProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], RewardsProviderFactory);
    return RewardsProviderFactory;
}());
var RewardsProvider = (function () {
    function RewardsProvider(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    RewardsProvider.prototype.getPaginatedLength = function () {
        return this.heat.api.rewardsListCount();
    };
    RewardsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.heat.api.rewardsList(firstIndex, lastIndex);
    };
    return RewardsProvider;
}());
var SearchAccountsProviderFactory = (function () {
    function SearchAccountsProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    SearchAccountsProviderFactory.prototype.createProvider = function (query) {
        return new SearchAccountsProvider(this.heat, this.$q, query);
    };
    SearchAccountsProviderFactory = __decorate([
        Service('searchAccountsProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], SearchAccountsProviderFactory);
    return SearchAccountsProviderFactory;
}());
var SearchAccountsProvider = (function () {
    function SearchAccountsProvider(heat, $q, query) {
        this.heat = heat;
        this.$q = $q;
        this.query = query;
    }
    SearchAccountsProvider.prototype.getPaginatedLength = function () {
        return this.heat.api.searchAccountsCount(this.query);
    };
    SearchAccountsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.heat.api.searchAccounts(this.query, firstIndex, lastIndex);
    };
    return SearchAccountsProvider;
}());
var FimkAccountComponent = (function () {
    function FimkAccountComponent($scope, mofoSocketService, fimkPendingTransactions, $interval, $mdToast, settings, user, router) {
        this.$scope = $scope;
        this.mofoSocketService = mofoSocketService;
        this.fimkPendingTransactions = fimkPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.router = router;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
        this.selectSocketEndPoint = 'fimk1';
    }
    FimkAccountComponent.prototype.$onInit = function () {
        var _this = this;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        this.fimkPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = this.$interval(this.timerHandler.bind(this), 30000);
        this.timerHandler();
        this.$scope.$on('$destroy', function () {
            _this.fimkPendingTransactions.removeListener(listener);
            _this.$interval.cancel(promise);
        });
        this.sockets = SettingsService.CRYPTO_NODES.find(function (v) { return v.currencyName == 'FIM'; }).nodes.filter(function (v) { return v.status == 'ACTIVE'; }) || [];
        this.$scope['vm'].selectSocketEndPoint = this.sockets.find(function (w) { return _this.mofoSocketService.getSocketUrl() == w.host; }).name;
    };
    FimkAccountComponent.prototype.changeSocketAddress = function () {
        var _this = this;
        var ret = this.sockets.find(function (w) { return _this.$scope['vm'].selectSocketEndPoint == w.name; });
        this.mofoSocketService.mofoSocket(ret.host)
            .then(function (v) {
            var url = _this.router.lastNavigationAttempt;
            _this.router.navigate("/");
            setTimeout(function () { return _this.router.navigate(url); }, 300);
        }, function (reason) { return console.error("reason: " + reason); });
    };
    FimkAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.mofoSocketService.getRecentTx(this.user.currency.address).then(function (recentTransactions) {
                for (var i = 0; i < _this.pendingTransactions.length; i++) {
                    var isPending = false;
                    for (var j = 0; j < recentTransactions.length; j++) {
                        if (recentTransactions[j].transaction == _this.pendingTransactions[i].txId) {
                            isPending = true;
                            break;
                        }
                    }
                    if (!isPending) {
                        _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id ".concat(_this.pendingTransactions[i].txId, " found")).hideDelay(2000));
                        _this.fimkPendingTransactions.remove(_this.pendingTransactions[i].address, _this.pendingTransactions[i].txId, _this.pendingTransactions[i].time);
                    }
                }
            }, function (err) {
                console.log('Error in getting recent FIMK Transactions ' + err);
            });
        }
    };
    FimkAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.currency.address;
            var txns = _this.fimkPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    FimkAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.mofoSocketService.getAccount(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                var balance = info.unconfirmedBalanceNQT ? parseInt(info.unconfirmedBalanceNQT) / 100000000 : 0;
                var formattedBalance = new Big(balance + "");
                _this.balanceUnconfirmed = new Big(formattedBalance).toFixed(8);
                _this.busy = false;
            });
        });
    };
    FimkAccountComponent = __decorate([
        RouteConfig('/fimk-account/:account'),
        Component({
            selector: 'fimkAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/fimk-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} FIM\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              FIMK Server:\n            </div>\n            <div class=\"value\">\n              <md-select class=\"md-select-ws\" ng-model=\"vm.selectSocketEndPoint\" ng-change=\"vm.changeSocketAddress()\">\n                <md-option ng-repeat=\"socket in vm.sockets\" value=\"{{socket.name}}\">{{socket.name}}</md-option>\n              </md-select>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <span>{{item.txId}}</span>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-fimk-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-fimk-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'mofoSocketService', 'fimkPendingTransactions', '$interval', '$mdToast', 'settings', 'user', '$router'),
        __metadata("design:paramtypes", [Object, MofoSocketService,
            FimkPendingTransactionsService, Function, Object, SettingsService,
            UserService, Object])
    ], FimkAccountComponent);
    return FimkAccountComponent;
}());
var LtcAccountComponent = (function () {
    function LtcAccountComponent($scope, ltcBlockExplorerService, ltcPendingTransactions, $interval, $mdToast, settings, user) {
        this.$scope = $scope;
        this.ltcBlockExplorerService = ltcBlockExplorerService;
        this.ltcPendingTransactions = ltcPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
    }
    LtcAccountComponent.prototype.$onInit = function () {
        var _this = this;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        this.ltcPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = this.$interval(this.timerHandler.bind(this), 30000);
        this.timerHandler();
        this.$scope.$on('$destroy', function () {
            _this.ltcPendingTransactions.removeListener(listener);
            _this.$interval.cancel(promise);
        });
    };
    LtcAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_5 = this.pendingTransactions[this.prevIndex];
            this.ltcBlockExplorerService.getTxInfo(pendingTxn_5.txId).then(function (data) {
                if (data.blockHeight > 0) {
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id ".concat(pendingTxn_5.txId, " found")).hideDelay(2000));
                    _this.ltcPendingTransactions.remove(pendingTxn_5.address, pendingTxn_5.txId, pendingTxn_5.time);
                }
            }, function (err) {
                console.log('Transaction not found', err);
            });
        }
    };
    LtcAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.currency.address;
            var txns = _this.ltcPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    LtcAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.ltcBlockExplorerService.getBalance(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = new Big(parseFloat(info) / 100000000).toFixed(8);
                _this.busy = false;
            });
        });
    };
    LtcAccountComponent.prototype.txUrl = function (txId) {
        return HttpService.prepareUrl("https://ltc1.heatwallet.com/api/v2/tx/".concat(txId));
    };
    LtcAccountComponent = __decorate([
        RouteConfig('/ltc-account/:account'),
        Component({
            selector: 'ltcAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/ltc-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} LTC\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col tx-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col tx-col left\" flex>\n                <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"{{vm.txUrl(item.txid)}}\">{{item.txId}}</a>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-ltc-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-ltc-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'ltcBlockExplorerService', 'ltcPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, LtcBlockExplorerService,
            LtcPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], LtcAccountComponent);
    return LtcAccountComponent;
}());
var EditMessageComponent = (function () {
    function EditMessageComponent($scope, sendmessage, storage, $timeout, user, p2pMessaging, $mdToast) {
        this.$scope = $scope;
        this.sendmessage = sendmessage;
        this.$timeout = $timeout;
        this.user = user;
        this.p2pMessaging = p2pMessaging;
        this.$mdToast = $mdToast;
        this.store = storage.namespace('contacts.latestTimestamp', $scope);
    }
    EditMessageComponent.prototype.onKeyPress = function ($event) {
        if ($event.key == "Enter" && !$event.shiftKey) {
            this.send($event);
        }
    };
    EditMessageComponent.prototype.send = function ($event) {
        if (this.messageText && this.messageText.trim().length != 0) {
            if ($event.preventDefault)
                $event.preventDefault();
            if (this.p2pMessaging.onlineStatus == "online") {
                this.sendP2PMessage($event);
            }
            else {
                this.sendHeatMessage($event);
            }
        }
    };
    EditMessageComponent.prototype.sendP2PMessage = function ($event, files) {
        var _this = this;
        var notSentReason;
        var room = this.p2pMessaging.getOneToOneRoom(this.publickey);
        if (room) {
            var peer = room.getPeer(this.publickey) || room.createPeer(this.publickey, this.publickey);
            if (peer) {
                try {
                    if (files) {
                        room.sendFiles(files, this.publickey);
                    }
                    else {
                        var count = room.sendMessage(new p2p.U2UMessage("chat", Date.now(), this.messageText));
                        this.$scope.$evalAsync(function () { return _this.messageText = ''; });
                    }
                }
                catch (e) {
                    notSentReason = e;
                }
            }
            else {
                notSentReason = "Peer not found";
            }
        }
        else {
            notSentReason = "Chat 'room' for contact is not created";
        }
        if (notSentReason) {
            this.$mdToast.show(this.$mdToast.simple().textContent("Not sent. ".concat(notSentReason)).hideDelay(3000));
        }
    };
    EditMessageComponent.prototype.sendHeatMessage = function ($event) {
        var _this = this;
        var account = heat.crypto.getAccountIdFromPublicKey(this.publickey);
        this.sendmessage.
            dialog($event, account, this.publickey, this.messageText).
            send().
            then(function () {
            _this.$scope.$evalAsync(function () {
                _this.messageText = '';
            });
            _this.$timeout(2 * 1000, false).then(function () {
                var latestTimestamp = _this.store.getNumber(account, 0);
                _this.store.put(account, latestTimestamp + 1);
            });
        });
    };
    EditMessageComponent.prototype.onDrop = function ($event) {
        if (!($event.dataTransfer.files && $event.dataTransfer.files.length > 0))
            return;
        $event.preventDefault();
        if (this.p2pMessaging.onlineStatus != "online") {
            this.$mdToast.show(this.$mdToast.simple().textContent("Send file(s) is not accepted because of disabled offchain messaging").hideDelay(3000));
            return;
        }
        var files = $event.dataTransfer.files;
        var errorMessage;
        if (files.length > 10) {
            errorMessage = "Too many files, limit is 10";
        }
        else {
            for (var _i = 0, files_2 = files; _i < files_2.length; _i++) {
                var file = files_2[_i];
                if (file.size > 2 * 1024 * 1024) {
                    errorMessage = "File size of \"".concat(file.name, "\" is too big, limit is 2 MB");
                    break;
                }
            }
        }
        if (errorMessage) {
            this.$mdToast.show(this.$mdToast.simple().textContent("File(s) is not accepted. ".concat(errorMessage)).hideDelay(3000));
            return;
        }
        this.sendP2PMessage($event, files);
    };
    EditMessageComponent.prototype.onDragover = function ($event) {
        $event.preventDefault();
    };
    EditMessageComponent = __decorate([
        Component({
            selector: 'editMessage',
            inputs: ['publickey'],
            styles: ["\n    edit-message .md-button {\n      margin: 0px;\n      min-width: 46px;\n    }\n    .edit-message-textarea {\n      border: solid 1px;\n      border-radius: 5px 5px 0px;\n    }\n    .edit-message-textarea.offchain {\n      border-color: green;\n    }\n    .edit-message-textarea::placeholder {\n      color: rgb(117, 117, 117);\n    }\n    .send-button-container {\n      padding-left: 10px;\n    }\n  "],
            template: "\n<!--    <div layout=\"row\" flex ondrop=\"dropHandler($event);\" ondragover=\"dragOverHandler($event);\">-->\n    <div layout=\"row\" flex ng-on-drop=\"vm.onDrop($event)\" ng-on-dragover=\"vm.onDragover($event)\">\n      <div layout=\"column\" flex=\"noshrink\">\n        <form hide-gt-xs name=\"editMessageForm\" ng-submit=\"vm.sendMessage($event)\" flex layout=\"row\">\n          <textarea flex rows=\"4\" ng-model=\"vm.messageText\"></textarea>\n          <md-button type=\"submit\" aria-label=\"Submit\">\n            <md-icon md-font-library=\"material-icons\">send</md-icon>\n          </md-button>\n        </form>\n        <textarea hide-xs ng-model=\"vm.messageText\" flex rows=\"3\" class=\"edit-message-textarea\"\n          ng-class=\"{'offchain': vm.p2pMessaging.onlineStatus == 'online'}\"\n          ng-keypress=\"vm.onKeyPress($event)\" placeholder=\"Hit ENTER key to send, SHIFT+ENTER for new line. &#10;Drag and drop file (max 2MB) here to encrypt and send instantly\"></textarea>\n      </div>\n      <div layout=\"column\" class=\"send-button-container\">\n        <!--<md-button class=\"offchain-button\" ng-click=\"vm.toggleOffchain()\" ng-class=\"{'active': vm.p2pMessaging.offchainMode, 'disable': !vm.p2pMessaging.offchainMode}\">\n          <md-tooltip md-direction=\"top\">Peer-to-peer messages off blockchain</md-tooltip>\n          {{vm.p2pMessaging.offchainMode ? 'offchain  \u2714' : 'offchain'}}\n        </md-button>-->\n        <md-button class=\"md-primary send-button\" flex ng-click=\"vm.send($event)\">\n          Send\n        </md-button>\n      </div>\n    </div>\n\n  "
        }),
        Inject('$scope', 'sendmessage', 'storage', '$timeout', 'user', 'P2PMessaging', '$mdToast'),
        __metadata("design:paramtypes", [Object, SendmessageService,
            StorageService, Function, UserService,
            P2PMessaging, Object])
    ], EditMessageComponent);
    return EditMessageComponent;
}());
var MessageBatchEntryComponent = (function () {
    function MessageBatchEntryComponent($rootScope, $scope, messaging, heat, $mdToast) {
        var _this = this;
        this.$rootScope = $rootScope;
        this.$scope = $scope;
        this.messaging = messaging;
        this.heat = heat;
        this.$mdToast = $mdToast;
        this.fileIndicator = 0;
        $rootScope.$on('OFFCHAIN_MESSAGE_EXTRA_INFO', function (event, msgId, info) {
            if (_this.message.msgId == msgId) {
                _this.$scope.$evalAsync(function () {
                    var _a, _b;
                    _this.message.extraInfo = info;
                    _this.stage = (_b = (_a = _this.message.extraInfo) === null || _a === void 0 ? void 0 : _a.status) === null || _b === void 0 ? void 0 : _b.stage;
                });
            }
        });
    }
    MessageBatchEntryComponent.prototype.$onInit = function () {
        var _a, _b, _c;
        this.io = this.message['outgoing'] ? 'outgoing' : 'incoming';
        this.stage = (_b = (_a = this.message.extraInfo) === null || _a === void 0 ? void 0 : _a.status) === null || _b === void 0 ? void 0 : _b.stage;
        if (!this.message.type || this.message.type == "chat") {
            this.text = this.message.contents;
        }
        else if (this.message.type == "file") {
            var s = this.message.contents;
            var delimiterPos = s === null || s === void 0 ? void 0 : s.indexOf("|");
            if (delimiterPos > 0) {
                this.fileDescriptor = {
                    fileName: s.substr(delimiterPos + 1).trim(),
                    fileSize: parseInt(s.substr(0, delimiterPos)),
                    fileSender: this.message.fromPeer
                };
                if (this.io == 'incoming') {
                    this.text = "file \"".concat(this.fileDescriptor.fileName, "\", size ").concat(this.fileDescriptor.fileSize, " bytes");
                    this.fileIndicator = ((_c = this.message.extraInfo) === null || _c === void 0 ? void 0 : _c.status.fileIndicator) || 1;
                }
                else {
                    this.text = "sent file \"".concat(this.fileDescriptor.fileName, "\", size ").concat(this.fileDescriptor.fileSize, " bytes");
                }
            }
        }
    };
    MessageBatchEntryComponent.prototype.downloadFile = function () {
        var _this = this;
        this.heat.api.downloadFile(this.message.msgId).then(function (encryptedFileContent) {
            _this.messaging.onFile(encryptedFileContent, _this.room, _this.message.msgId, _this.fileDescriptor, function () {
                _this.fileIndicator = 2;
            });
        }).catch(function (reason) {
            _this.$mdToast.show(_this.$mdToast.simple().textContent("Error on file downloading").hideDelay(6000));
            console.error(reason);
        });
    };
    MessageBatchEntryComponent = __decorate([
        Component({
            selector: 'messageBatchEntry',
            inputs: ['message', 'room'],
            styles: ["\n    message-batch-entry .header {\n      font-size: 12px;\n    }\n    message-batch-entry .batch-entry {\n      padding-left: 0px;\n    }\n    message-batch-entry .message-content {\n      font-size: 16px;\n    }\n    message-batch-entry .status {\n      font-size: 12px;\n      float: right;\n      margin-left: 7px;\n      margin-right: -12px;\n    }\n    message-batch-entry .column {\n      border-radius: 15px;\n      min-width: 120px;\n      padding-top: 5px;\n    }\n    message-batch-entry .outgoing {\n      float: right;\n      background-color: #0c5f68;\n      color: white;\n      padding-left: 10px;\n      padding-top: 10px;\n      padding-right: 10px;\n      padding-bottom: 0px;\n      border-radius: .4em;\n      max-width: 75%;\n      min-width: 20%;\n    }\n    message-batch-entry .incoming {\n      text-align: left;\n      float: left;\n      background-color: #52a7b1;\n      color: black;\n      padding-left: 10px;\n      padding-top: 10px;\n      padding-right: 10px;\n      padding-botton: 0px;\n      border-radius: .4em;\n      max-width: 75%;\n      min-width: 20%;\n    }\n    message-batch-entry .message-content p {\n      white-space: pre-wrap;       /* Since CSS 2.1 */\n      white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */\n      white-space: -pre-wrap;      /* Opera 4-6 */\n      white-space: -o-pre-wrap;    /* Opera 7 */\n      word-wrap: break-word;       /* Internet Explorer 5.5+ */\n      /* Adds a hyphen where the word breaks, if supported (No Blink) */\n      -ms-hyphens: auto;\n      -moz-hyphens: auto;\n      -webkit-hyphens: auto;\n      hyphens: auto;\n    }\n    message-batch-entry .offchain {\n      border-left: solid 7px green;\n    }\n    message-batch-entry .onchain, message-batch-entry .chain {\n      border-left: solid 7px #ff3301;\n    }\n    message-batch-entry .p2p {\n      border-left: solid 7px green;\n    }\n    message-batch-entry .server {\n      border-left: solid 7px skyblue;\n    }\n  "],
            template: "\n    <div class=\"{{vm.message.transport}}\" ng-class=\"{'outgoing': vm.message.outgoing, 'incoming': !vm.message.outgoing}\">\n      <div class=\"header\">\n        <span>{{vm.message.date}}</span>\n        <!-- delivered icon, stage == 1 means Delivered -->\n        <md-icon class=\"status\" md-font-library=\"material-icons\" ng-if=\"vm.stage==1\">check</md-icon>\n      </div>\n      <div ng-if=\"!vm.fileIndicator\" class=\"message-content\"><p>{{vm.text}}</p></div>\n      <div ng-if=\"vm.fileIndicator\" class=\"message-content\">\n        <p>{{vm.text}}</p>\n        <p ng-if=\"vm.fileIndicator == 1\"><a class=\"md-primary md-button md-ink-ripple\" ng-click=\"vm.downloadFile()\">download</a></p>\n        <pre ng-if=\"vm.fileIndicator == 2\">File is downloaded</pre>\n      </div>\n    </div>\n  "
        }),
        Inject('$rootScope', '$scope', 'P2PMessaging', 'heat', '$mdToast'),
        __metadata("design:paramtypes", [Object, Object, P2PMessaging,
            HeatService, Object])
    ], MessageBatchEntryComponent);
    return MessageBatchEntryComponent;
}());
var MessageBatchViewerComponent = (function (_super) {
    __extends(MessageBatchViewerComponent, _super);
    function MessageBatchViewerComponent($scope, $q, $timeout, $document, heat, user, settings, render, controlCharRender, storage) {
        var _this = _super.call(this, $scope, $q, $timeout) || this;
        _this.$document = $document;
        _this.heat = heat;
        _this.user = user;
        _this.settings = settings;
        _this.render = render;
        _this.controlCharRender = controlCharRender;
        _this.store = storage.namespace('contacts.latestTimestamp', $scope);
        _this.dateFormat = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var refresh = utils.debounce((angular.bind(_this, _this.onMessageAdded)), 500, false);
        heat.subscriber.message({ sender: _this.user.account }, refresh, $scope);
        heat.subscriber.message({ recipient: _this.user.account }, refresh, $scope);
        return _this;
    }
    MessageBatchViewerComponent.prototype.$onInit = function () {
        this.loadInitial();
        if (this.publickey == this.user.publicKey) {
            throw Error("Same public key as logged in user");
        }
    };
    MessageBatchViewerComponent.prototype.loadInitial = function () {
        var _this = this;
        var deferred = this.$q.defer();
        this.clear();
        this.$scope.$evalAsync(function () { _this.getParentScope().loading = true; });
        this.getBatch(0).then(function (batch) {
            _this.$scope.$evalAsync(function () {
                _this.getParentScope().loading = false;
                _this.$timeout(0).then(function () {
                    deferred.resolve();
                });
            });
        });
        deferred.promise.then(function () {
            if (_this.batches[0].entries.length > 0) {
                _this.goTo(_this.getFirst().getLast().__id, 0, 1);
            }
        });
        return deferred.promise;
    };
    MessageBatchViewerComponent.prototype.onMessageAdded = function () {
        var _this = this;
        var batch = this.getFirst();
        if (!batch)
            return;
        batch.loadMore().then(function () {
            var entry = batch.getLast();
            var id = entry.__id;
            _this.$scope.$evalAsync(function () {
                _this.$timeout(0).then(function () {
                    _this.goTo(id, 0, 1000);
                });
            });
        });
    };
    MessageBatchViewerComponent.prototype.onMessageRemoved = function () { };
    MessageBatchViewerComponent.prototype.onMessageConfirmed = function () { };
    MessageBatchViewerComponent.prototype.goTo = function (id, offset, duration) {
        var container = this.getScrollContainer();
        var element = angular.element(document.getElementById(id));
        if (!element)
            return;
        var _offset = offset || 30;
        var _duration = duration || 2000;
        return container.duScrollToElement(element, _offset, _duration, heat.easing.easeOutCubic);
    };
    MessageBatchViewerComponent.prototype.getScrollContainer = function () {
        return angular.element(document.getElementById(this.containerId));
    };
    MessageBatchViewerComponent.prototype.getCount = function () {
        return this.heat.api.getMessagingContactMessagesCount(this.user.account, heat.crypto.getAccountIdFromPublicKey(this.publickey));
    };
    MessageBatchViewerComponent.prototype.getItems = function (firstIndex, lastIndex) {
        var _this = this;
        var deferred = this.$q.defer();
        this.heat.api.getMessagingContactMessages(this.user.account, heat.crypto.getAccountIdFromPublicKey(this.publickey), firstIndex, lastIndex).then(function (messages) {
            var index = firstIndex;
            var result = messages.map(function (message) {
                var date = utils.timestampToDate(message.timestamp);
                message['date'] = dateFormat(date, _this.dateFormat);
                message['outgoing'] = _this.user.account == message.sender;
                message['contents'] = _this.decryptMessage(message);
                message['index'] = index++;
                message['html'] = _this.render.render(message['contents'], [_this.controlCharRender]);
                _this.updateLatestMessageReadTimestamp(message);
                return message;
            });
            deferred.resolve(result);
        });
        return deferred.promise;
    };
    MessageBatchViewerComponent.prototype.decryptMessage = function (message) {
        return this.heat.getHeatMessageContents(message);
    };
    MessageBatchViewerComponent.prototype.updateLatestMessageReadTimestamp = function (message) {
        var account = this.user.account == message.sender ? message.recipient : message.sender;
        var latestTimestamp = this.store.getNumber(account, 0);
        if (message.timestamp > latestTimestamp) {
            this.store.put(account, message.timestamp);
        }
    };
    MessageBatchViewerComponent = __decorate([
        Component({
            selector: 'messageBatchViewer',
            inputs: ['publickey', '@containerId'],
            styles: ["\n    message-batch-viewer .message-item {\n      min-height: 80px;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex>\n      <div class=\"scroll-up\" layout=\"row\" flex ng-hide=\"vm.getParentScope().loading || vm.batches[vm.batches.length-1].firstIndex == 0\" layout-align=\"center\">\n        <md-button ng-click=\"vm.scrollUp()\" aria-label=\"Go up\">Go up</md-button>\n      </div>\n      <div layout=\"column\">\n        <div layout=\"column\" ng-repeat=\"batch in vm.batches | orderBy:'-'\">\n          <div layout=\"column\" ng-repeat=\"entry in batch.entries\">\n            <message-batch-entry id=\"{{::entry.__id}}\" message=\"entry\" flex=\"none\" class=\"message-item\"></message-batch-entry>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', '$q', '$timeout', '$document', 'heat', 'user', 'settings', 'render', 'controlCharRender', 'storage'),
        __metadata("design:paramtypes", [Object, Function, Function, Object, HeatService,
            UserService,
            SettingsService,
            RenderService,
            ControlCharRenderService,
            StorageService])
    ], MessageBatchViewerComponent);
    return MessageBatchViewerComponent;
}(AbstractBatchViewerComponent));
var MessengerComponent = (function () {
    function MessengerComponent($scope, user, sendmessage, p2pMessaging) {
        this.$scope = $scope;
        this.user = user;
        this.sendmessage = sendmessage;
        this.p2pMessaging = p2pMessaging;
        user.requireLogin();
    }
    MessengerComponent.prototype.showSendmessageDialog = function ($event) {
        this.sendmessage.dialog($event).show();
    };
    MessengerComponent.prototype.showCallDialog = function ($event) {
        if (this.p2pMessaging.onlineStatus == 'online') {
            var recipient = heat.crypto.getAccountIdFromPublicKey(this.publickey);
            this.p2pMessaging.dialog($event, recipient, this.publickey, "Hello, I am ".concat(this.user.accountName))
                .show()
                .finally(function () { });
        }
        else {
            this.sendmessage.dialog($event).show();
        }
    };
    MessengerComponent.prototype.toggleOnline = function ($event) {
        this.p2pMessaging.onlineStatus = this.p2pMessaging.onlineStatus == "online" ? "offline" : "online";
        this.p2pMessaging.enterRoom(this.publickey);
    };
    MessengerComponent = __decorate([
        RouteConfig('/messenger/:publickey'),
        Component({
            selector: 'messenger',
            inputs: ['publickey'],
            styles: ["\n    messenger user-contacts {\n      width: 300px;\n      min-width: 240px;\n    }\n    messenger .control-panel {\n      margin-top: 6px;\n      margin-right: 6px;\n    }\n    messenger .outer-container {\n      padding-top: 0px;\n      padding-bottom: 0px;\n    }\n    messenger md-content {\n      height: 100%;\n      //padding: 0 0 0 12px;\n    }\n    messenger .progress-indicator {\n      padding-left: 0px;\n      padding-right: 0px;\n    }\n    messenger md-progress-linear > .md-container {\n      height: 3px;\n      max-height: 3px;\n    }\n    messenger .edit-message {\n      padding-right: 0px;\n    }\n    .control-panel button {\n      flex: auto;\n    }\n    .p2p-messages {\n      height: 100%;\n    }\n    #offchainButton.disable span {\n      color: grey;\n    }\n    #offchainButton.active {\n      background-color: green;\n    }\n    #onlineStatusButton.disable span {\n      color: grey;\n    }\n    #onlineStatusButton.active {\n      background-color: green;\n    }\n    #newContactButton {\n      max-width: 171px;\n    }\n    #newContactButton md-icon {\n      margin-right: 8px;\n      color: white;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill class=\"outer-container\">\n      <div layout=\"row\" flex layout-fill>\n        <div layout=\"column\">\n          <user-contacts flex layout=\"column\" ></user-contacts>\n          <div layout=\"row\" class=\"control-panel\">\n            <md-button class=\"online\" id=\"onlineStatusButton\" ng-click=\"vm.toggleOnline()\"\n            ng-class=\"{'active': vm.p2pMessaging.onlineStatus == 'online', 'disable': vm.p2pMessaging.onlineStatus !== 'online'}\">\n              <md-tooltip md-direction=\"top\">{{vm.p2pMessaging.onlineStatus == 'online' ? 'NOW STEALTH - CLICK FOR ONCHAIN' : 'NOW ONCHAIN - CLICK FOR STEALTH'}}</md-tooltip>\n              {{vm.p2pMessaging.onlineStatus == 'online' ? 'offchain  \u2714' : 'onchain'}}\n            </md-button>\n            <md-button id=\"callButton\" class=\"md-primary\" aria-label=\"Send\" ng-click=\"vm.showCallDialog($event)\">\n              <md-tooltip md-direction=\"top\">\n                Send HEAT message to user to establish the contact\n              </md-tooltip>\n              New Contact\n            </md-button>\n            <!--<md-button id=\"newContactButton\" class=\"md-primary\" aria-label=\"Add contact\" ng-click=\"vm.showSendmessageDialog($event)\">\n              <md-tooltip md-direction=\"top\">\n                Send message to new contact\n              </md-tooltip>\n              <md-icon md-font-library=\"material-icons\">add_circle_outline</md-icon>\n              New CONTACT\n            </md-button>-->\n          </div>\n        </div>\n        <div layout=\"column\" layout-fill>\n          <div class=\"row\" class=\"progress-indicator\" flex ng-show=\"vm.loading\">\n            <md-progress-linear class=\"md-primary\" md-mode=\"indeterminate\"></md-progress-linear>\n          </div>\n          <md-content flex ng-if=\"vm.p2pMessaging.onlineStatus == 'offline'\" id=\"message-batch-container\">\n            <message-batch-viewer flex layout=\"column\" container-id=\"message-batch-container\"\n                    publickey=\"::vm.publickey\"></message-batch-viewer>\n          </md-content>\n          <md-content flex ng-if=\"vm.p2pMessaging.onlineStatus == 'online' && vm.publickey != 0\" id=\"p2p-messages-container\">\n            <p2p-messages-viewer flex layout=\"column\" class=\"p2p-messages\" container-id=\"p2p-messages-container\"\n                    publickey=\"::vm.publickey\"></p2p-messages-viewer>\n          </md-content>\n          <div layout=\"row\" flex=\"none\" class=\"edit-message\">\n            <edit-message publickey=\"vm.publickey\" layout=\"row\" flex></edit-message>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'user', 'sendmessage', 'P2PMessaging'),
        __metadata("design:paramtypes", [Object, UserService,
            SendmessageService,
            P2PMessaging])
    ], MessengerComponent);
    return MessengerComponent;
}());
var PAGE_LENGTH = 2;
var MsgViewerComponent = (function () {
    function MsgViewerComponent(heat, user, $scope, p2pMessaging, settings, $timeout, storage, $mdToast, router) {
        this.heat = heat;
        this.user = user;
        this.$scope = $scope;
        this.p2pMessaging = p2pMessaging;
        this.settings = settings;
        this.$timeout = $timeout;
        this.storage = storage;
        this.$mdToast = $mdToast;
        this.router = router;
        this.range = [0, PAGE_LENGTH];
    }
    MsgViewerComponent_1 = MsgViewerComponent;
    MsgViewerComponent.prototype.$onInit = function () {
        if (this.publickey == this.user.publicKey) {
            throw Error("Same public key as logged in user");
        }
        this.store = this.storage.namespace('contacts.latestTimestamp', this.$scope);
        this.dateFormat = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var refresh = utils.debounce((angular.bind(this, this.onMessageAdded)), 500, false);
        this.heat.subscriber.message({ sender: this.user.account }, refresh, this.$scope);
        this.heat.subscriber.message({ recipient: this.user.account }, refresh, this.$scope);
        MsgViewerComponent_1.count = 10000;
        this.room = this.p2pMessaging.getOneToOneRoom(this.publickey, true);
        this.initMessages();
    };
    MsgViewerComponent.prototype.initMessages = function () {
        var _this = this;
        this.offchainPages = 0;
        this.onchainMessagesCount = 0;
        this.messagesCount = 0;
        this.displayMessages = { index: 0, messages: [] };
        this.allMessages = [];
        this.heat.api.getMessagingContactMessagesCount(this.user.account, heat.crypto.getAccountIdFromPublicKey(this.publickey))
            .then(function (count) {
            if (count > 0) {
                _this.onchainMessagesCount = count;
                _this.messagesCount += count;
            }
        })
            .catch(function (reason) { return console.error('Error on getting contact messages count: ' + reason); })
            .then(function (value) {
            if (_this.room) {
                _this.p2pMessaging.updateSeenTime(_this.room.name, Date.now() + 1000 * 60 * 60 * 24);
                _this.messageHistory = _this.room.getMessageHistory();
                _this.offchainPages = _this.messageHistory.getPageCount() - 1;
                _this.room.onNewMessageHistoryItem = function (item) {
                    _this.onMessageAdded(item, true);
                };
                _this.messagesCount += _this.messageHistory.getItemCount();
                _this.$scope.$on('$destroy', function () {
                    _this.p2pMessaging.updateSeenTime(_this.room.name, Date.now());
                    _this.room.onNewMessageHistoryItem = null;
                });
            }
            _this.loadMessages();
        });
    };
    MsgViewerComponent.prototype.loadMessages = function () {
        var _this = this;
        var messagesA = [];
        if (this.offchainPages >= 0) {
            messagesA = this.messageHistory.getItems(--this.offchainPages);
        }
        messagesA.forEach(function (item) { return _this.processOffchainItem(item); });
        var timestampes = messagesA.map(function (m) { return m.timestamp; });
        var minTimestamp = timestampes.length > 0 ? Math.min.apply(Math, timestampes) : 0;
        var maxTimestamp = timestampes.length > 0 ? Math.max.apply(Math, timestampes) : 0;
        if (minTimestamp > 0) {
            this.heat.api.getMessagingContactMessagesByTimestampRange(this.user.account, heat.crypto.getAccountIdFromPublicKey(this.publickey), minTimestamp, maxTimestamp).then(function (messagesB) {
                _this.$scope.$evalAsync(function () {
                    _this.range[0] += messagesB.length;
                    _this.range[1] += messagesB.length;
                    var processedMessagesB = [];
                    messagesB.forEach(function (message) { return processedMessagesB.push(_this.processOnchainItem(message)); });
                    _this.displayMessages.messages = _this.displayMessages.messages
                        .concat(messagesA, processedMessagesB)
                        .sort(function (a, b) { return a.sortingTimestamp - b.sortingTimestamp; });
                    _this.displayMessages.index = _this.displayMessages.messages.length;
                    var joinedContent = _this.displayMessages.messages.map(function (item) { var _a; return (_a = item.content) === null || _a === void 0 ? void 0 : _a.substr(0, 10); }).join(" | ");
                    console.debug("loadOffchainMessages ".concat(_this.displayMessages.messages.length, "  offchainPages ").concat(_this.offchainPages, " joinedContent ").concat(joinedContent));
                });
            });
        }
        else {
            this.loadOnchainMessages(this.range[0], this.range[1]).then(function (messagesB) {
                _this.$scope.$evalAsync(function () {
                    _this.displayMessages.messages = _this.displayMessages.messages
                        .concat(messagesA, messagesB)
                        .sort(function (a, b) { return a.sortingTimestamp - b.sortingTimestamp; });
                    _this.displayMessages.index = _this.displayMessages.messages.length;
                    var joinedContent = _this.displayMessages.messages.map(function (item) { var _a; return (_a = item.content) === null || _a === void 0 ? void 0 : _a.substr(0, 10); }).join(" | ");
                    console.debug("loadOffchainMessages ".concat(_this.displayMessages.messages.length, "  offchainPages ").concat(_this.offchainPages, " joinedContent ").concat(joinedContent));
                });
            });
            this.range[0] += PAGE_LENGTH;
            this.range[1] += PAGE_LENGTH;
        }
    };
    MsgViewerComponent.prototype.loadOnchainMessages = function (from, to) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var onchainMessages = [];
            if (from < 0 || to < 0)
                resolve(onchainMessages);
            else {
                _this.heat.api.getMessagingContactMessages(_this.user.account, heat.crypto.getAccountIdFromPublicKey(_this.publickey), from, to).then(function (messages) {
                    messages.forEach(function (message) { return onchainMessages.push(_this.processOnchainItem(message)); });
                    resolve(onchainMessages);
                }).catch(function () { return resolve(onchainMessages); });
            }
        });
    };
    MsgViewerComponent.prototype.loadOffchainMessages = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.messageHistory && _this.offchainPages >= 0) {
                var page = _this.messageHistory.getItems(_this.offchainPages);
                if (page.length < PAGE_LENGTH && _this.offchainPages > 0) {
                    page = page.concat(_this.messageHistory.getItems(--_this.offchainPages));
                }
                page.forEach(function (item) { return _this.processOffchainItem(item); });
                var joinedContent = page.map(function (item) { return item.content; }).join(" | ");
                console.debug("loadOffchainMessages ".concat(page.length, "  offchainPages ").concat(_this.offchainPages, " joinedContent ").concat(joinedContent));
                resolve(page);
            }
            else {
                resolve([]);
            }
        });
    };
    MsgViewerComponent.prototype.processOnchainItem = function (message) {
        this.updateLatestMessageReadTimestamp(message);
        var date = utils.timestampToDate(message.timestamp);
        return {
            'senderPublicKey': message.senderPublicKey,
            'senderAccount': heat.crypto.getAccountIdFromPublicKey(message.senderPublicKey),
            'contents': this.heat.getHeatMessageContents(message),
            'date': dateFormat(date, this.dateFormat),
            'outgoing': this.user.account == message.sender,
            'transport': 'chain',
            'timestamp': message.timestamp,
            'sortingTimestamp': date.getTime(),
            '__id': ++MsgViewerComponent_1.count
        };
    };
    MsgViewerComponent.prototype.processOffchainItem = function (item) {
        if (item['__id'])
            return item;
        item['__id'] = ++MsgViewerComponent_1.count;
        item['senderPublicKey'] = item.fromPeer;
        item['senderAccount'] = heat.crypto.getAccountIdFromPublicKey(item.fromPeer);
        item['timestamp'] = item.timestamp;
        item['sortingTimestamp'] = item.receiptTimestamp || item.timestamp;
        item['outgoing'] = this.user.account == item['senderAccount'];
        item['date'] = dateFormat(item.timestamp, this.dateFormat);
        item.transport = item.transport || (item['onchain'] ? 'chain' : 'p2p');
        item['contents'] = item['content'] || item['message'];
        return item;
    };
    MsgViewerComponent.prototype.onMessageAdded = function (data, offchain) {
        var _this = this;
        if (offchain === void 0) { offchain = false; }
        var newMessage;
        if (offchain) {
            newMessage = this.processOffchainItem(data);
        }
        else {
            newMessage = this.processOnchainItem(data);
            if (!newMessage['outgoing']) {
                this.$mdToast.show(this.$mdToast.simple().textContent("New message from ".concat(newMessage['senderAccount'], ": \"").concat(newMessage['contents'], "\"")).hideDelay(6000));
            }
        }
        if (newMessage['outgoing'] || this.publickey == newMessage.senderPublicKey) {
            this.displayMessages.messages.splice(0, 0, newMessage);
            this.displayMessages.index++;
            this.messagesCount++;
            this.$scope.$evalAsync(function () {
                _this.$timeout(0).then(function () {
                    _this.scrollElement = document.getElementById(newMessage.__id);
                    if (_this.scrollElement) {
                        _this.getScrollContainer().duScrollToElement(angular.element(_this.scrollElement), 0, 1200, heat.easing.easeOutCubic);
                    }
                });
            });
        }
    };
    MsgViewerComponent.prototype.scrollUp = function () {
        this.onchainMessagesCount -= PAGE_LENGTH + 1;
        this.loadMessages();
    };
    MsgViewerComponent.prototype.openMenu = function ($mdMenu, event) {
        $mdMenu.open(event);
    };
    MsgViewerComponent.prototype.removeOffchainMessage = function ($event, item) {
        var _this = this;
        dialogs.confirm("Remove message", "Do you want to remove this message (from yourself only)?").then(function () {
            _this.messageHistory.remove(item.timestamp);
            _this.displayMessages.messages = _this.displayMessages.messages.filter(function (i) { return i.timestamp != item.timestamp; });
            _this.displayMessages.index--;
            _this.allMessages = _this.allMessages.filter(function (i) { return i.timestamp != item.timestamp; });
        }).then(function () {
            _this.initMessages();
        });
    };
    MsgViewerComponent.prototype.getScrollContainer = function () {
        return angular.element(document.getElementById(this.containerId));
    };
    MsgViewerComponent.prototype.updateLatestMessageReadTimestamp = function (message) {
        var account = this.user.account == message.sender ? message.recipient : message.sender;
        var latestTimestamp = this.store.getNumber(account, 0);
        if (message.timestamp > latestTimestamp) {
            this.store.put(account, message.timestamp);
        }
    };
    var MsgViewerComponent_1;
    MsgViewerComponent = MsgViewerComponent_1 = __decorate([
        Component({
            selector: 'msgViewer',
            inputs: ['publickey', '@containerId'],
            styles: ["\n    .msg-entry-menu-disabled {\n      opacity: 20%;\n    }\n    .entry-menu {\n      place-content: center;\n    }\n  "],
            template: "\n    <div>\n      <div class=\"row\" class=\"progress-indicator\" flex ng-show=\"vm.loading\">\n        <md-progress-linear class=\"md-primary\" md-mode=\"indeterminate\"></md-progress-linear>\n      </div>\n      <div layout=\"column\" flex>\n        <div class=\"scroll-up\" layout=\"row\" flex ng-hide=\"vm.loading || vm.displayMessages.messages.length === vm.messagesCount\" layout-align=\"center\">\n          <md-button ng-click=\"vm.scrollUp()\" aria-label=\"Go up\">Go up</md-button>\n        </div>\n        <div layout=\"column\">\n          <div layout=\"row\" flex layout-fill ng-repeat=\"message in vm.displayMessages.messages track by $index\">\n            <div layout=\"column\" flex>\n              <message-batch-entry id=\"{{::message.__id}}\" message=\"message\" room=\"vm.room\" flex=\"none\" class=\"message-item\"></message-batch-entry>\n            </div>\n            <div layout=\"column\" class=\"entry-menu\">\n              <md-menu ng-class=\"{'msg-entry-menu-disabled': message.onchain || message.transport == 'chain'}\">\n                <md-button ng-disabled=\"message.onchain || message.transport == 'chain'\" aria-label=\"Message menu\" class=\"md-icon-button menu-button\" ng-click=\"vm.openMenu($mdMenu, $event)\">\n                  <!--<md-icon md-menu-origin md-svg-icon=\"call:phone\"></md-icon>-->\n                  ...\n                </md-button>\n                <md-menu-content width=\"4\">\n                  <md-menu-item>\n                    <md-button ng-click=\"vm.removeOffchainMessage($event, message)\">\n                      Remove\n                    </md-button>\n                  </md-menu-item>\n                </md-menu-content>\n              </md-menu>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('heat', 'user', '$scope', 'P2PMessaging', 'settings', '$timeout', 'storage', '$mdToast', '$router'),
        __metadata("design:paramtypes", [HeatService,
            UserService, Object, P2PMessaging,
            SettingsService, Function, StorageService, Object, Object])
    ], MsgViewerComponent);
    return MsgViewerComponent;
}());
var P2PMessagesViewerComponent = (function () {
    function P2PMessagesViewerComponent($scope, $q, $timeout, $document, heat, user, settings, render, controlCharRender, storage, p2pMessaging, $mdToast) {
        this.$scope = $scope;
        this.$document = $document;
        this.heat = heat;
        this.user = user;
        this.settings = settings;
        this.render = render;
        this.controlCharRender = controlCharRender;
        this.storage = storage;
        this.p2pMessaging = p2pMessaging;
        this.$mdToast = $mdToast;
        this.items = [];
    }
    P2PMessagesViewerComponent.prototype.$onInit = function () {
        var _this = this;
        if (this.publickey == this.user.publicKey) {
            throw Error("Same public key as logged in user");
        }
        this.dateFormat = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        if (this.publickey != '0') {
            this.room = this.p2pMessaging.getOneToOneRoom(this.publickey, true);
            if (this.room) {
                this.p2pMessaging.updateSeenTime(this.room.name, Date.now() + 1000 * 60 * 60 * 24);
                this.datasource = new P2PMessagesDataSource(this.room.getMessageHistory(), function (item) { return _this.processItem(item); });
                this.room.onNewMessageHistoryItem = function (item) {
                    _this.datasource.first++;
                    var adapter = _this.$scope.adapter;
                    if (adapter.isEOF()) {
                        adapter.append([_this.processItem(item)]);
                    }
                };
                var $rootScope = heat.$inject.get('$rootScope');
                $rootScope.$on('OFFCHAIN_MESSAGE_EXTRA_INFO', function (event, msgId, info) {
                    _this.items.forEach(function (item) {
                        if (item.msgId == msgId) {
                            _this.$scope.$evalAsync(function () {
                                item.extraInfo = info;
                                _this.processItem(item);
                            });
                        }
                    });
                });
                this.$scope.$on('$destroy', function () {
                    _this.p2pMessaging.updateSeenTime(_this.room.name, Date.now());
                    _this.room.onNewMessageHistoryItem = null;
                });
            }
        }
    };
    P2PMessagesViewerComponent.prototype.openMenu = function ($mdMenu, event) {
        $mdMenu.open(event);
    };
    P2PMessagesViewerComponent.prototype.removeMessage = function (event, item) {
        var _this = this;
        var displayDialog = function (message, file) {
            var ss = ["local message"];
            if (message)
                ss.push("message on server");
            if (file)
                ss.push("file on server");
            dialogs.confirm("Remove message", "Objects to be removed: " + ss.join(", ") + " <br/><br/> Do you want to remove the message ?").then(function () {
                _this.datasource.remove(item);
                _this.p2pMessaging.checkToRemoveServerMessage(item.type, item["outgoing"], item.transport, item.msgId, item.extraInfo);
                var adapter = _this.$scope.adapter;
                adapter.applyUpdates(function (item2) {
                    if (item2 == item) {
                        return [];
                    }
                });
            }).catch(function (reason) {
                if (reason)
                    console.error(reason);
            });
        };
        this.p2pMessaging.requestIsMessageExists(item.type, item["outgoing"], item.transport, item.msgId, item.extraInfo, function (message, file) {
            displayDialog(message, file);
            displayDialog = null;
        });
        setTimeout(function () {
            if (displayDialog)
                displayDialog(null, null);
        }, 2000);
    };
    P2PMessagesViewerComponent.prototype.processItem = function (item) {
        var _a, _b, _c;
        this.items.push(item);
        item['senderAccount'] = heat.crypto.getAccountIdFromPublicKey(item.fromPeer);
        item['outgoing'] = this.user.account == item['senderAccount'];
        item['dateFormatted'] = dateFormat(item.timestamp, this.dateFormat);
        item['fileIndicator'] = 0;
        item['stage'] = (_b = (_a = item.extraInfo) === null || _a === void 0 ? void 0 : _a.status) === null || _b === void 0 ? void 0 : _b.stage;
        if (item.type == "file") {
            if (!item['fileDescriptor']) {
                var s = item.content;
                var delimiterPos = s === null || s === void 0 ? void 0 : s.indexOf("|");
                if (delimiterPos > 0) {
                    item['fileDescriptor'] = {
                        fileName: s.substr(delimiterPos + 1).trim(),
                        fileSize: parseInt(s.substr(0, delimiterPos)),
                        fileSender: item.fromPeer
                    };
                }
            }
            var fileDescriptor = item['fileDescriptor'];
            if (fileDescriptor) {
                if (item['outgoing']) {
                    item.content = "Sent file \"".concat(fileDescriptor.fileName, "\" (").concat(fileDescriptor.fileSize, " bytes)");
                }
                else {
                    item.content = "file \"".concat(fileDescriptor.fileName, "\", size ").concat(fileDescriptor.fileSize, " bytes");
                    item['fileIndicator'] = ((_c = item.extraInfo) === null || _c === void 0 ? void 0 : _c.status.fileIndicator) || 1;
                }
            }
        }
        return item;
    };
    P2PMessagesViewerComponent.prototype.downloadFile = function (item) {
        var _this = this;
        item['fileIndicator'] = 3;
        this.heat.api.downloadFile(item.msgId).then(function (encryptedFileContent) {
            item['fileIndicator'] = 1;
            _this.p2pMessaging.onFile(encryptedFileContent, _this.room, item.msgId, item['fileDescriptor'], function () { return item['fileIndicator'] = 2; });
        }).catch(function (reason) {
            _this.$mdToast.show(_this.$mdToast.simple().textContent("Error on file downloading").hideDelay(6000));
            console.error(reason);
            item['fileIndicator'] = 4;
            var ei = _this.room.getMessageHistory().getExtraInfo(item.msgId)
                || { status: { stage: 0, fileIndicator: 4 } };
            ei.status.fileIndicator = 4;
            _this.room.getMessageHistory().putExtraInfo(item.msgId, ei);
        });
    };
    P2PMessagesViewerComponent = __decorate([
        Component({
            selector: 'p2pMessagesViewer',
            inputs: ['publickey', '@containerId'],
            styles: ["\n    .messages {\n      overflow: auto;\n      font-size: 14px;\n    }\n    .message-entry {\n      color: white;\n      margin-bottom: 24px;\n      margin-right: 10px;\n      // max-width: 85%;\n    }\n    .message-entry .message-content {\n      white-space: pre-line;\n    }\n    .message-entry md-icon {\n      color: green;\n      margin: 0 12px 0 0;\n    }\n    .message-entry md-icon.transportserver {\n      color: skyblue;\n    }\n    .message-entry .header {\n      padding-bottom: 6px;\n      color: grey;\n    }\n    .message-entry .menu-button {\n      color: grey !important;\n    }\n    .message-entry div.message {\n      width: 100%;\n    }\n    .message-entry .status {\n      font-size: 12px;\n      margin-top: 4px;\n      margin-left: -30px;\n    }\n\n    .message-entry .file-status {\n      color: green;\n    }\n\n    .message-entry.outgoing .message-wrapper {\n      margin-left: 20%;\n      margin-right: 0;\n      display: flex;\n      max-width: 80%;\n    }\n\n    .message-entry.incoming .message-wrapper {\n      max-width: 80%;\n      display: flex;\n    }\n\n    .message-entry.outgoing md-menu {\n      margin-left: -60px;\n    }\n\n    .message-entry.incoming md-menu {\n      margin-left: -55px;\n    }\n\n    .message-wrapper md-menu {\n      margin-top: 10px;\n      font-weight: 800;\n    }\n\n    // .outgoing {\n    //   align-self: flex-end;\n    // }\n    .message-entry.ng-enter, .message-entry.ng-leave {\n      -webkit-transition: 0.5s linear all;\n      transition: 0.5s linear all;\n    }\n    .message-entry.ng-enter, .message-entry.ng-leave.ng-leave-active {\n      opacity: 0;\n      height: 0px;\n    }\n    .message-entry.ng-leave, .message-entry.ng-enter.ng-enter-active {\n      opacity: 1;\n      height: 40px;\n    }\n  "],
            template: "\n<div class=\"messages\" ui-scroll-viewport layout=\"column\" flex scroll-glue>\n\n<div ui-scroll=\"item in vm.datasource\" buffer-size=\"200\" adapter=\"adapter\"\n      layout=\"row\" class=\"message-entry\" ng-class=\"{outgoing: item.outgoing, incoming: !item.outgoing}\">\n<div class=\"message-wrapper\">\n    <md-icon ng-class=\"{transportserver: item.transport=='server'}\" md-font-library=\"material-icons\">{{item.outgoing ? 'chat_bubble_outline' : 'comment'}}</md-icon>\n    <md-icon class=\"status\" md-font-library=\"material-icons\" ng-class=\"{transportserver: item.transport=='server'}\"\n            ng-if=\"item.stage==1\">check</md-icon>\n    <md-menu>\n      <md-button aria-label=\"Message menu\" class=\"md-icon-button menu-button\" ng-click=\"vm.openMenu($mdMenu, $event)\">\n        <!--<md-icon md-menu-origin md-svg-icon=\"call:phone\"></md-icon>-->\n        ...\n      </md-button>\n      <md-menu-content width=\"4\">\n        <md-menu-item>\n          <md-button ng-click=\"vm.removeMessage($event, item)\">\n            Remove\n          </md-button>\n        </md-menu-item>\n      </md-menu-content>\n    </md-menu>\n    <div layout=\"column\" class=\"message\">\n      <div class=\"header\">\n        <b ng-if=\"!item.outgoing\">{{item.senderAccount}}&nbsp;&nbsp;&nbsp;&nbsp;</b>{{::item.dateFormatted}}\n      </div>\n      <div ng-if=\"!item.fileIndicator\" class=\"message-content\">{{item.content}}</div>\n      <div ng-if=\"item.fileIndicator\" class=\"message-content\">{{item.content}}</div>\n      <div ng-if=\"item.fileIndicator == 1 || item.fileIndicator == 4\">\n          <a class=\"md-primary md-button md-ink-ripple\" ng-click=\"vm.downloadFile(item)\">download</a>\n      </div>\n      <div ng-if=\"item.fileIndicator == 2\" class=\"file-status\">File is downloaded</div>\n      <div ng-if=\"item.fileIndicator == 3\" class=\"file-status\">downloading <elipses-loading></elipses-loading></div>\n      <div ng-if=\"item.fileIndicator == 4\" class=\"file-status\">file download error</div>\n    </div>\n</div>\n</div>\n\n</div>\n  "
        }),
        Inject('$scope', '$q', '$timeout', '$document', 'heat', 'user', 'settings', 'render', 'controlCharRender', 'storage', 'P2PMessaging', '$mdToast'),
        __metadata("design:paramtypes", [Object, Function, Function, Object, HeatService,
            UserService,
            SettingsService,
            RenderService,
            ControlCharRenderService,
            StorageService,
            P2PMessaging, Object])
    ], P2PMessagesViewerComponent);
    return P2PMessagesViewerComponent;
}());
var P2PMessagesDataSource = (function () {
    function P2PMessagesDataSource(messageHistory, processItem) {
        this.messageHistory = messageHistory;
        this.processItem = processItem;
        this.data = [];
        this.first = 1;
    }
    P2PMessagesDataSource.prototype.get = function (index, count, success) {
        var _this = this;
        var start = index;
        var end = Math.min(index + count - 1, this.first);
        if (start <= end) {
            var lastIndex = this.messageHistory.getItemCount() - 1;
            var items = this.messageHistory.getItemsScrollable(lastIndex + start - this.first, lastIndex + end - this.first + 1)
                .map(function (item) { return _this.processItem(item); });
            success(items);
        }
        else {
            success([]);
        }
    };
    P2PMessagesDataSource.prototype.remove = function (item) {
        this.messageHistory.remove(item.timestamp);
    };
    return P2PMessagesDataSource;
}());
var P2PMessagingProbeComponent = (function () {
    function P2PMessagingProbeComponent() {
    }
    P2PMessagingProbeComponent_1 = P2PMessagingProbeComponent;
    var P2PMessagingProbeComponent_1;
    P2PMessagingProbeComponent = P2PMessagingProbeComponent_1 = __decorate([
        RouteConfig('/p2pmessagingprobe'),
        Component({
            controller: P2PMessagingProbeComponent_1,
            selector: 'probe',
            template: "\n<p>\n  My name: <input type=\"text\" ng-model=\"vm.myName\" />\n  Room: <input type=\"text\" ng-model=\"vm.roomName\" />\n  Call to Peer Id: <input type=\"text\" ng-model=\"vm.peerId\" />\n</p>\n\n<p>\n<button class=\"md-primary md-button md-ink-ripple\" ng-click=\"vm.enterRoom()\">Enter room</button>\n<button class=\"md-primary md-button md-ink-ripple\" ng-disabled=\"!vm.canCall\" ng-click=\"vm.call()\">Call</button>\n</p>\n\n<p>Who is online: {{vm.whoIsOnline}}</p>\n\n<form ng-submit=\"vm.send()\">\n   <input type=\"text\" ng-model=\"vm.messageText\" ng-disabled=\"!vm.connected\"/>\n   <button type=\"submit\" class=\"md-primary md-button md-ink-ripple\" ng-disabled=\"!vm.connected\">Send</button>\n   <!--<input type=\"submit\" class=\"md-primary md-button md-ink-ripple\" ng-disabled=\"!vm.connected\"/>-->\n</form>\n\n<!--\n<p><input type=\"text\" ng-model=\"vm.messageText\" />\n<button class=\"md-primary md-button md-ink-ripple\" ng-disabled=\"!vm.connected\" ng-click=\"vm.send()\">Send</button>\n</p>\n-->\n\n<div style=\"overflow: scroll;\">\n  <div ng-repeat=\"message in vm.messages track by $index\">\n    <span>{{message}}</span>\n  </div>\n</div>\n\n<!--<textarea>{{vm.messageConsole}}</textarea>-->\n"
        }),
        Inject('$scope', 'user', 'sendmessage', '$interval', 'P2PConnector', 'storage', 'settings')
    ], P2PMessagingProbeComponent);
    return P2PMessagingProbeComponent;
}());
var NxtAccountComponent = (function () {
    function NxtAccountComponent($scope, nxtBlockExplorerService, nxtPendingTransactions, $interval, $mdToast, settings, user) {
        this.$scope = $scope;
        this.nxtBlockExplorerService = nxtBlockExplorerService;
        this.nxtPendingTransactions = nxtPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
    }
    NxtAccountComponent.prototype.$onInit = function () {
        var _this = this;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        this.nxtPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = this.$interval(this.timerHandler.bind(this), 7000);
        this.timerHandler();
        this.$scope.$on('$destroy', function () {
            _this.nxtPendingTransactions.removeListener(listener);
            _this.$interval.cancel(promise);
        });
        this.sockets = [
            {
                name: 'HEAT_NXT_node',
                hostUrl: 'https://nxt1.heatwallet.com'
            },
            {
                name: 'Localhost',
                hostUrl: 'http://localhost:7876'
            }
        ];
        this.$scope['vm'].selectSocketEndPoint = this.sockets.find(function (w) { return _this.nxtBlockExplorerService.getHostUrl() == w.hostUrl; }).name;
    };
    NxtAccountComponent.prototype.changeHostAddress = function () {
        var _this = this;
        var ret = this.sockets.find(function (w) { return _this.$scope['vm'].selectSocketEndPoint == w.name; });
        this.nxtBlockExplorerService.setUrl(ret.hostUrl);
        var host = ret.hostUrl.split(':7876')[0];
        SettingsService.changeCryptoNodeProperty('NXT', host, 'priority', 0);
    };
    NxtAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_6 = this.pendingTransactions[this.prevIndex];
            this.nxtBlockExplorerService.getTransactionStatus(pendingTxn_6.txId).then(function (data) {
                if (data.confirmations) {
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id ".concat(pendingTxn_6.txId, " found")).hideDelay(2000));
                    _this.nxtPendingTransactions.remove(pendingTxn_6.address, pendingTxn_6.txId, pendingTxn_6.time);
                }
            }, function (err) {
                console.log('Transaction not found', err);
            });
        }
    };
    NxtAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.currency.address;
            var txns = _this.nxtPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    NxtAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.nxtBlockExplorerService.getAccount(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = new Big(utils.convertToQNTf(info.balanceNQT)).toFixed(8);
                _this.busy = false;
            });
        });
    };
    NxtAccountComponent = __decorate([
        RouteConfig('/nxt-account/:account'),
        Component({
            selector: 'nxtAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/nxt-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance:\n              <md-progress-circular style=\"display: initial; position: fixed;\" md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} NXT\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              NXT Server:\n            </div>\n            <div class=\"value\">\n              <md-select class=\"md-select-ws\" ng-model=\"vm.selectSocketEndPoint\" ng-change=\"vm.changeHostAddress()\">\n                <md-option ng-repeat=\"socket in vm.sockets\" value=\"{{socket.name}}\">{{socket.name}}</md-option>\n              </md-select>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <span>{{item.txId}}</span>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-nxt-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-nxt-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'nxtBlockExplorerService', 'nxtPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, NxtBlockExplorerService,
            NxtPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], NxtAccountComponent);
    return NxtAccountComponent;
}());
var PeersComponent = (function () {
    function PeersComponent($rootScope, $scope, heat, settings) {
        this.$rootScope = $rootScope;
        this.$scope = $scope;
        this.heat = heat;
        this.settings = settings;
        this.peerMap = new Map();
    }
    PeersComponent.prototype.$onInit = function () {
        var _this = this;
        var peersCompare = function (a, b) {
            var _a;
            var stateA = a.state == "CONNECTED" ? -1 : 1;
            var stateB = b.state == "CONNECTED" ? -1 : 1;
            return (stateA - stateB) || ((_a = a.address) === null || _a === void 0 ? void 0 : _a.localeCompare(b.address));
        };
        var onPeerInfo = function (peerList) {
            var now = Date.now();
            peerList.peers.forEach(function (p) {
                var pv = Object.assign(_this.peerMap.get(p.address) || {}, p);
                pv.updateTime = now;
                _this.peerMap.set(p.address, pv);
            });
            _this.peers = Array.from(_this.peerMap, function (_a) {
                var name = _a[0], value = _a[1];
                return value;
            })
                .filter(function (pv) { return pv.updateTime > now - 60000 && (pv.downloaded > 0 || pv.uploaded > 0); });
            _this.peers.sort(peersCompare);
            _this.peerMap.clear();
            _this.peers.forEach(function (pv) { return _this.peerMap.set(pv.address, pv); });
            _this.$scope.$evalAsync(function () {
                _this.calculateDerived(_this.peers, peerList.recentFeeders);
            });
        };
        var onPeerInfoDebounced = utils.debounce(angular.bind(this, onPeerInfo), 200, false);
        var updateTitle = function () {
            _this.$scope.$evalAsync(function () {
                var port = _this.settings.get(SettingsService.HEAT_PORT);
                _this.apiServerAddress = _this.settings.get(SettingsService.HEAT_HOST) + (port ? ":" + port : "");
                _this.heat.api.getBlockchainStatus().then(function (status) {
                    _this.apiServerVersion = status.version;
                });
            });
        };
        var unsubscribe;
        setTimeout(function () { return unsubscribe = _this.heat.subscriber.peer({}, onPeerInfoDebounced, _this.$scope); }, 1000);
        setTimeout(function () {
            updateTitle();
            _this.$rootScope.$on('HEAT_SERVER_LOCATION', function (event, nothing) {
                _this.peerMap.clear();
                _this.peers = [];
                updateTitle();
                if (unsubscribe)
                    unsubscribe();
                unsubscribe = _this.heat.subscriber.peer({}, onPeerInfoDebounced, _this.$scope);
            });
        }, 1500);
        this.$scope.$on('$destroy', unsubscribe);
    };
    PeersComponent.prototype.feederTimeLine = function (pv) {
        return pv.feederTimeLine;
    };
    PeersComponent.prototype.calculateDerived = function (peers, recentFeeders) {
        var _this = this;
        if (peers.length == 0)
            return;
        var maxd = peers.reduce(function (p, v) {
            return (p.downloaded > v.downloaded ? p : v);
        });
        var kd = maxd.downloaded / MAX_RECT_SQUARE;
        var maxu = peers.reduce(function (p, v) {
            return (p.uploaded > v.uploaded ? p : v);
        });
        var ku = maxu.uploaded / MAX_RECT_SQUARE;
        var scaleRatio = Math.max(1, kd, ku);
        peers.forEach(function (p) {
            p.downloadedRectangle = _this.calculateRectangle(p.downloaded, scaleRatio);
            p.uploadedRectangle = _this.calculateRectangle(p.uploaded, scaleRatio);
            p.downloadedSpeedMeter = _this.speedMeter(p.downloadedSpeedMeter, p.downloaded);
            p.uploadedSpeedMeter = _this.speedMeter(p.uploadedSpeedMeter, p.uploaded);
            _this.buildBlockFeederTimeLine(p, recentFeeders);
            p.connectedChangedDate = p.connectedChangedTime ? utils.timestampToDate(p.connectedChangedTime).toLocaleString() : "-";
        });
    };
    PeersComponent.prototype.speedMeter = function (meter, volume) {
        var now = Date.now();
        if (meter) {
            var interval = now - meter.t;
            if (interval > 4000) {
                meter.speed = Math.max(0, Math.round((volume - meter.v) / interval * 1000));
                meter.t = now;
                meter.v = volume;
            }
            return meter;
        }
        else {
            return { t: now, v: volume, speed: 0 };
        }
    };
    PeersComponent.prototype.calculateRectangle = function (s, scaleRatio) {
        s = s / scaleRatio;
        var a = Math.sqrt(s / 8);
        var b = a * 8;
        return { a: a, b: b };
    };
    PeersComponent.prototype.buildBlockFeederTimeLine = function (peerView, recentFeeders) {
        var _a;
        if (!recentFeeders)
            return;
        peerView.feederTimeLine = recentFeeders.map(function (v) { return v.address == peerView.address ? "o" : "-"; }).join("");
        peerView.lastFeeder = ((_a = recentFeeders[recentFeeders.length - 1]) === null || _a === void 0 ? void 0 : _a.address) == peerView.address;
    };
    PeersComponent.prototype.formatBytes = function (value) {
        return utils.formatBytes(value, value > 1024 * 1024 * 1024 ? 2 : 0);
    };
    PeersComponent = __decorate([
        RouteConfig('/peers'),
        Component({
            selector: 'peers',
            styles: ["\n    .item {\n        display: inline-block;\n    }\n    .peer {\n        background-color: lightslategrey;\n        border-radius: 9px;\n        padding: 6px;\n        margin: 4px;\n    }\n    .downloaded {\n        border: solid 1px lightgrey;\n        border-radius: 6px;\n        //padding: 4px;\n        //margin: 4px;\n        background-color: #b0ffb07a;\n        min-width: 5px;    \n        min-height: 16px;\n        max-height: 16px;\n        white-space: nowrap;\n        //margin-top: -48px;\n    }\n    .uploaded {\n        border: solid 1px lightgrey;\n        border-radius: 6px;\n        //padding: 4px;\n        //margin: 4px;\n        background-color: #7175f552;\n        min-width: 5px;    \n        min-height: 16px;\n        max-height: 16px;\n        white-space: nowrap;\n        //margin-top: -48px;\n    }\n    .speed {\n        //border: solid 1px lightgrey;\n        //border-radius: 4px;\n        //padding: 2px;\n        margin: 2px;\n        //background-color: rgb(255 60 30 / 0.45);\n        min-width: 5px;\n        max-width: 320px;    \n        height: 3px;\n        white-space: nowrap;\n    }\n    .speed {\n        -webkit-transition: all 3s; \n        -moz-transition: all 3s; \n        -ms-transition: all 3s; \n        -o-transition: all 3s; \n        transition: all 3s;  \n    }\n    .connected {\n        color: springgreen;  \n    }\n    .stats {\n      display: grid;\n      grid-template-columns: auto auto;\n      grid-template-rows: auto auto;\n      gap: 4px;\n      justify-content: start;\n      margin-top: 6px;\n    }\n\n    .feeder-timeline {\n        font-family: monospace;\n        -webkit-transition: all 3s; \n        -moz-transition: all 3s; \n        -ms-transition: all 3s; \n        -o-transition: all 3s; \n        transition: all 3s ease-in-out;  \n    }\n    .last-feeder {\n        background-color: rgb(255 128 171 / 40%);\n    }\n    @keyframes scaleUp {\n      0% { transform: scale(0.1); }\n      100% { transform: scale(1)}\n    }\n    .scale-up {\n      animation: scaleUp 4s;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill style=\"padding: 8px\">\n        <h2>Network peers</h2>\n        <div style=\"overflow: scroll\">\n            <p>Connected to <span style=\"font-weight: bold;\">{{vm.apiServerAddress}}</span>, server version <span style=\"font-weight: bold;\">{{vm.apiServerVersion}}</span></p>\n            <p ng-if=\"vm.apiServerVersion < '4.3.0'\">Connected API server should be at least 4.3.0 to provide peers info</p>\n            <div ng-repeat=\"item in vm.peers\" class=\"peer item scale-up\">\n                <b>{{item.address}}</b> &nbsp;&nbsp;{{item.platform}} &nbsp;&nbsp;{{item.application}} &nbsp;&nbsp;{{item.version}} &nbsp;&nbsp;\n                <span ng-if=\"item.height > 0\"><label>height:</label> {{item.height}}</span> &nbsp;&nbsp; <label>was connected:</label> {{item.connectedChangedDate}}\n                <div>\n                    <span ng-class=\"{'connected':item.state=='CONNECTED'}\">{{item.state}}</span>\n                    <span ng-if=\"item.stateNote\">({{item.stateNote}})</span>\n                    &nbsp;&nbsp;<span ng-if=\"item.remoteServerRequestCounter\">Server requests: {{item.remoteServerRequestCounter}}</span>\n                </div>\n                <div class=\"feeder-timeline\" ng-class=\"{'last-feeder':item.lastFeeder}\">{{vm.feederTimeLine(item)}}</div>\n                <div class=\"stats\">\n                    <div class=\"item\">downloaded {{vm.formatBytes(item.downloaded)}}</div>\n                    <div class=\"downloaded item\" style=\"width: {{item.downloadedRectangle.b}}px;height: {{item.downloadedRectangle.a}}px;\">\n                        <div>\n                            <div class=\"speed item\" style=\"width: {{0.3 * item.downloadedSpeedMeter.speed}}px;background-color: rgb(180 30 30 / {{0.1 + item.downloadedSpeedMeter.speed/1200}});\"></div>\n                            <div class=\"item\">speed {{item.downloadedSpeedMeter.speed}} b/s</div>\n                        </div>\n                    </div>\n                    <div class=\"item\">uploaded {{vm.formatBytes(item.uploaded)}}</div>\n                    <div class=\"uploaded item\" style=\"width: {{item.uploadedRectangle.b}}px;height: {{item.uploadedRectangle.a}}px;\">\n                        <div>\n                            <div class=\"speed item\" style=\"width: {{0.2 * item.uploadedSpeedMeter.speed}}px;background-color: rgb(180 30 30 / {{0.1 + item.uploadedSpeedMeter.speed/1200}});\"></div>\n                            <div class=\"item\">speed {{item.uploadedSpeedMeter.speed}} b/s</div>\n                        </div>\n                    </div>\n                </div>\n        </div>\n    </div>\n  "
        }),
        Inject('$rootScope', '$scope', 'heat', 'settings'),
        __metadata("design:paramtypes", [Object, Object, HeatService,
            SettingsService])
    ], PeersComponent);
    return PeersComponent;
}());
var MAX_RECT_SQUARE = 20000;
var ServerComponent = (function () {
    function ServerComponent($scope, serverService, heat, user, settings, $mdToast, clipboard) {
        var _this = this;
        this.$scope = $scope;
        this.serverService = serverService;
        this.heat = heat;
        this.user = user;
        this.settings = settings;
        this.$mdToast = $mdToast;
        this.clipboard = clipboard;
        this.ROW_HEIGHT = 14;
        this.calculatedTopIndex = 0;
        this.topIndex = 0;
        this.consoleRowCount = 0;
        this.isMining = false;
        this.isUpdatingMiningInfo = false;
        this.miningRemaining = '*';
        this.miningHittime = '*';
        this.msgRegExp = /^([\d-]+\s[\d:]+)\s(.+)\s-\s(.*)/;
        if (user.unlocked) {
            heat.subscriber.blockPushed({ generator: user.account }, function () { _this.updateMiningInfo(); });
            heat.subscriber.blockPopped({ generator: user.account }, function () { _this.updateMiningInfo(); });
        }
        else {
            var listener_2 = function () { _this.updateMiningInfo(); };
            user.on(UserService.EVENT_UNLOCKED, listener_2);
            $scope.$on('$destroy', function () { return user.removeListener(UserService.EVENT_UNLOCKED, listener_2); });
        }
        this.hostLocal = this.settings.get(SettingsService.HEAT_HOST_LOCAL);
        this.hostRemote = this.settings.get(SettingsService.HEAT_HOST_REMOTE);
        this.portLocal = this.settings.get(SettingsService.HEAT_PORT_LOCAL);
        this.portRemote = this.settings.get(SettingsService.HEAT_PORT_REMOTE);
        this.connectionWay = this.settings["connectionWay"] || "failover";
        SettingsService.forceServerPriority(this.connectionWay == "localhost" ? this.hostLocal : this.hostRemote, this.connectionWay == "localhost" ? this.portLocal : this.portRemote);
        this.onOutput = function () {
            $scope.$evalAsync(function () {
                _this.calculatedTopIndex = _this.determineTopIndex();
                if (!(_this.topIndex < (_this.calculatedTopIndex - 5)) || _this.consoleRowCount < _this.getLength()) {
                    _this.topIndex = _this.calculatedTopIndex;
                }
            });
        };
        serverService.addListener('output', this.onOutput);
        this.updateMiningInfo();
        window.setTimeout(function () {
            _this.topIndex = _this.determineTopIndex();
            _this.onOutput();
        }, 3000);
        this.remotehostDisplay = this.hostRemote.replace('https://', '');
        var interval = setInterval(function () {
            if (typeof _this.miningRemaining === "number") {
                if (_this.miningRemaining > 0) {
                    _this.miningRemaining--;
                }
                else {
                    if (Math.random() < 0.2)
                        _this.updateMiningInfo();
                }
            }
        }, 1000);
        $scope.$on('$destroy', function () {
            serverService.removeListener('output', _this.onOutput);
            clearInterval(interval);
        });
    }
    ServerComponent.prototype.isServerAvailable = function () {
        return this.serverService.isHeatledgerServerDirExists();
    };
    ServerComponent.prototype.showInstallFolder = function () {
        require('electron').shell.showItemInFolder(this.serverService.getAppDir('.'));
    };
    ServerComponent.prototype.showUserDataFolder = function () {
        this.serverService.getUserDataDirFromMainProcess().then(function (userDataDir) {
            var path = require('path');
            var dir = path.join(userDataDir);
            require('electron').shell.showItemInFolder(path.resolve(dir));
        });
    };
    ServerComponent.prototype.editHeatwalletConfig = function () {
        var _this = this;
        this.editConfig("Client Application Config", this.settings.getHeatwalletConfigFilePath(), function () { return _this.settings.applyFailoverConfig(); });
    };
    ServerComponent.prototype.editHeatledgerConfig = function () {
        this.editConfig("Heatledger server Config", this.serverService.getHeatConfigFilePath());
    };
    ServerComponent.prototype.editConfig = function (title, filePath, applyConfig) {
        var _this = this;
        this.serverService.getServerProperties(filePath).then(function (content) {
            _this.$scope.$evalAsync(function () {
                dialogs.textEditor(title, content, function (editedData) {
                    var fs = require('fs');
                    fs.writeFile(filePath, editedData, function (err) {
                        if (err)
                            throw err;
                        if (applyConfig)
                            applyConfig();
                    });
                }, function (content) {
                    _this.clipboard.copyText(content, 'Copied text to clipboard');
                });
            });
        });
    };
    ServerComponent.prototype.getItemAtIndex = function (index) {
        return this.render(this.serverService.buffer[index]);
    };
    ServerComponent.prototype.getLength = function () {
        return this.serverService.buffer.length;
    };
    ServerComponent.prototype.failoverUsageChanged = function () {
        if (this.connectionWay == "failover") {
            this.heat.switchToServer({ way: "remote", failoverEnabled: true, sameMessagingHost: false });
        }
        else if (this.connectionWay == "localhost") {
            this.heat.switchToServer({ way: "local", failoverEnabled: false, sameMessagingHost: false });
        }
        this.settings["connectionWay"] = this.connectionWay;
    };
    ServerComponent.prototype.startServer = function () {
        this.serverService.startServer();
        this.$mdToast.show(this.$mdToast.simple().textContent("In some cases you need to Start the server A SECOND TIME!\n" +
            "Wheter that's the case is indicated at the end of the log output (the colored text with black background).").hideDelay(10000));
    };
    ServerComponent.prototype.stopServer = function () {
        this.serverService.stopServer();
    };
    ServerComponent.prototype.determineRowCount = function () {
        var el = document.getElementById('server-console-container');
        return el ? Math.round(el.clientHeight / this.ROW_HEIGHT) : 5;
    };
    ServerComponent.prototype.determineTopIndex = function () {
        this.consoleRowCount = this.determineRowCount();
        return Math.max(0, this.getLength() - this.consoleRowCount + 2);
    };
    ServerComponent.prototype.render = function (msg) {
        if (angular.isUndefined(msg))
            return msg;
        if (angular.isUndefined(msg.rendered)) {
            var match = this.msgRegExp.exec(msg);
            msg.rendered = match ? { timestamp: match[1], severity: match[2], message: match[3] } : { message: msg };
        }
        return msg.rendered;
    };
    ServerComponent.prototype.startMining = function () {
        var _this = this;
        this.isUpdatingMiningInfo = true;
        this.heat.api.startMining(this.user.secretPhrase).then(function (info) {
            _this.updateMiningInfo();
        }).catch(function (reason) {
            _this.isUpdatingMiningInfo = false;
        });
    };
    ServerComponent.prototype.stopMining = function () {
        var _this = this;
        this.isUpdatingMiningInfo = true;
        this.heat.api.stopMining(this.user.secretPhrase).then(function (info) {
            _this.updateMiningInfo();
        }).catch(function (reason) {
            _this.isUpdatingMiningInfo = false;
        });
    };
    ServerComponent.prototype.updateMiningInfo = function () {
        var _this = this;
        if (this.user.unlocked) {
            this.heat.api.getMiningInfo(this.user.secretPhrase).then(function (info) {
                _this.isUpdatingMiningInfo = false;
                _this.$scope.$evalAsync(function () {
                    if (info[0]) {
                        _this.isMining = true;
                        _this.miningRemaining = info[0].remaining;
                        var miningHittime = info[0].hitTime;
                        var date = utils.timestampToDate(miningHittime);
                        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                        _this.miningHittime = dateFormat(date, format);
                    }
                    else {
                        _this.isMining = false;
                    }
                });
            }, function () {
                _this.$scope.$evalAsync(function () {
                    _this.isMining = false;
                    _this.isUpdatingMiningInfo = false;
                });
            });
        }
    };
    ServerComponent = __decorate([
        RouteConfig('/server'),
        Component({
            selector: 'server',
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill>\n      <div layout=\"row\" class=\"button-row\">\n\n        <md-button class=\"start-stop\" ng-if=\"vm.isServerAvailable()\" ng-show=\"!vm.serverService.isRunning\" ng-click=\"vm.startServer()\">\n            Start Server</md-button>\n        <md-button class=\"start-stop md-primary\" ng-if=\"vm.isServerAvailable()\" ng-show=\"vm.serverService.isRunning\" ng-click=\"vm.stopServer()\">\n            Stop Server</md-button>\n\n        <md-menu md-position-mode=\"target-right target\" md-offset=\"34px 0px\">\n          <md-button style=\"margin-top: 5px; margin-right: 20px;\" aria-label=\"signout\" class=\"md-icon-button\" ng-click=\"$mdMenu.open($event)\" md-menu-origin >\n            <i><img src=\"assets/sandwich.png\"></i>\n          </md-button>\n          <md-menu-content>\n            <md-menu-item>\n              <md-button class=\"start-stop\" ng-click=\"vm.showInstallFolder()\">\n                <md-tooltip md-direction=\"bottom\">Access your server config files and back them up before updating HEAT server</md-tooltip>\n                <span>Install Dir</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item>\n              <md-button class=\"start-stop\" ng-click=\"vm.showUserDataFolder()\">\n                <md-tooltip md-direction=\"bottom\">Access your user profile</md-tooltip>\n                <span>User Dir</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item>\n              <md-button ng-click=\"vm.editHeatwalletConfig()\">\n                <md-tooltip md-direction=\"bottom\">Edit application config</md-tooltip>\n                <span>Data sources config</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item>\n              <md-button ng-click=\"vm.editHeatledgerConfig()\">\n                <md-tooltip md-direction=\"bottom\">Edit embedded Heatledger server config</md-tooltip>\n                <span>Server config</span>\n              </md-button>\n            </md-menu-item>\n          </md-menu-content>\n        </md-menu>\n\n        <label id=\"failoverUsage\" style=\"margin-left: 11px; margin-right: 9px\">Client API data from:</label>\n        <md-radio-group ng-model=\"vm.connectionWay\" aria-labelledby=\"failoverUsage\" ng-change=\"vm.failoverUsageChanged()\">\n          <md-radio-button value=\"failover\" class=\"md-primary\" style=\"margin-bottom: 7px\">Best server (use failover feature)</md-radio-button>\n          <md-radio-button value=\"localhost\" style=\"margin-bottom: 7px\">Localhost (ignore failover feature)</md-radio-button>\n        </md-radio-group>\n\n        <!--<md-switch ng-model=\"vm.connectedToLocalhost\" aria-label=\"Choose API connection\" ng-change=\"vm.connectToLocalhostChanged()\">\n          <md-tooltip md-direction=\"top\">\n            Connect client API to remotehost or to your local machine\n          </md-tooltip>\n          Client API connected to {{ vm.connectedToLocalhost ? 'localhost' : vm.remotehostDisplay }}\n        </md-switch>-->\n\n        <span flex></span>\n        <div ng-show=\"vm.isMining\" layout=\"row\" layout-align=\"center center\" class=\"mining-stats\">\n          <span>Estimated hit time: </span>\n          <span class=\"mining-stats-val\">{{vm.miningHittime}}</span>\n          <span>({{vm.miningRemaining}} sec)</span>\n        </div>\n        <md-button ng-show=\"vm.user.unlocked && !vm.isMining && !vm.isUpdatingMiningInfo\" ng-disabled=\"!vm.serverService.isReady\" class=\"start-stop\" ng-click=\"vm.startMining()\">Start Mining</md-button>\n        <md-button ng-show=\"vm.user.unlocked && vm.isMining && !vm.isUpdatingMiningInfo\" ng-disabled=\"!vm.serverService.isReady\" class=\"start-stop md-primary\" ng-click=\"vm.stopMining()\">Stop Mining</md-button>\n        <span ng-if=\"vm.user.unlocked && vm.isUpdatingMiningInfo\">Updating Mining Info...</span>\n        <a ng-if=\"vm.isServerAvailable()\" ng-show=\"!vm.user.unlocked\" class=\"start-stop\" href=\"#/login\">Sign in to start mining</a>\n      </div>\n      <div layout=\"column\" flex class=\"console\" layout-fill>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\"\n            virtual-repeat-flex-helper id=\"server-console-container\">\n          <pre md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\">\n            <span ng-if=\"!item.timestamp\">{{item.message}}</span>\n            <span ng-if=\"item.timestamp\">\n              <span class=\"date\">{{item.timestamp}}&nbsp;<span class=\"severity {{item.severity}}\">{{item.severity}}</span>&nbsp;<span class=\"message\">{{item.message}}</span>\n            </span>\n          </pre>\n        </md-virtual-repeat-container>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'server', 'heat', 'user', 'settings', '$mdToast', 'clipboard'),
        __metadata("design:paramtypes", [Object, ServerService,
            HeatService,
            UserService,
            SettingsService, Object, ClipboardService])
    ], ServerComponent);
    return ServerComponent;
}());
var OrdersProviderFactory = (function () {
    function OrdersProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    OrdersProviderFactory.prototype.createProvider = function (currency, asset, account, isAsk) {
        return new OrdersProvider(currency, asset, account, isAsk, this.heat, this.$q);
    };
    OrdersProviderFactory = __decorate([
        Service('ordersProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], OrdersProviderFactory);
    return OrdersProviderFactory;
}());
var OrdersProvider = (function () {
    function OrdersProvider(currency, asset, account, isAsk, heat, $q) {
        this.currency = currency;
        this.asset = asset;
        this.account = account;
        this.isAsk = isAsk;
        this.heat = heat;
        this.$q = $q;
    }
    OrdersProvider.prototype.getPaginatedLength = function () {
        if (this.account) {
            return this.heat.api.getAccountPairOrdersCount(this.account, this.currency, this.asset);
        }
        else if (this.isAsk) {
            return this.heat.api.getAskOrdersCount(this.currency, this.asset);
        }
        return this.heat.api.getBidOrdersCount(this.currency, this.asset);
    };
    OrdersProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (this.account) {
            return this.heat.api.getAccountPairOrders(this.account, this.currency, this.asset, firstIndex, lastIndex);
        }
        else if (this.isAsk) {
            return this.heat.api.getAskOrders(this.currency, this.asset, firstIndex, lastIndex);
        }
        return this.heat.api.getBidOrders(this.currency, this.asset, firstIndex, lastIndex);
    };
    return OrdersProvider;
}());
var TraderBalancesComponent = (function () {
    function TraderBalancesComponent($scope, heat, user, assetInfoService, $q) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.user = user;
        this.assetInfoService = assetInfoService;
        this.$q = $q;
        this.balances = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                var refresh = utils.debounce((angular.bind(_this, _this.loadBalances)), 1 * 1000, false);
                heat.subscriber.balanceChanged({ account: user.account }, refresh, $scope);
                _this.loadBalances();
                unregister.forEach(function (fn) { fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    TraderBalancesComponent.prototype.loadBalances = function () {
        var _this = this;
        this.heat.api.getAccountBalances(this.user.account, "0", 1, 0, 100).then(function (balances) {
            _this.$scope.$evalAsync(function () {
                var promises = [];
                _this.balances = balances;
                balances.forEach(function (balance) {
                    promises.push(_this.assetInfoService.getInfo(balance.id).then(function (info) {
                        _this.$scope.$evalAsync(function () {
                            balance.symbol = info.symbol;
                            balance.name = info.name;
                            balance.certified = info.certified;
                            balance.expired = info.expired;
                        });
                    }));
                    balance.symbol = '*';
                    balance.name = '*';
                    balance.balance = utils.formatQNT(balance.virtualBalance, balance.decimals).replace(/.00000000$/, '');
                    ;
                    if (_this.currencyInfo.id == balance.id)
                        _this.currencyInfo.userBalance = balance.virtualBalance;
                    if (_this.assetInfo.id == balance.id)
                        _this.assetInfo.userBalance = balance.virtualBalance;
                });
                _this.$q.all(promises).then(function () {
                    _this.$scope.$evalAsync(function () {
                        balances.sort(function (a, b) {
                            if (a.certified < b.certified)
                                return 1;
                            if (a.certified > b.certified)
                                return -1;
                            if (a.symbol < b.symbol)
                                return 1;
                            if (a.symbol > b.symbol)
                                return -1;
                            return 0;
                        });
                    });
                });
            });
        });
    };
    TraderBalancesComponent = __decorate([
        Component({
            selector: 'traderBalances',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div layout=\"row\" class=\"trader-component-title\">Account&nbsp;\n      <span flex></span>\n      <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n    </div>\n    <md-list>\n      <md-list-item class=\"header\">\n        <div class=\"truncate-col symbol-col\">Asset</div>\n        <div class=\"truncate-col balance-col right-align\" flex>Balance</div>\n      </md-list-item>\n      <md-virtual-repeat-container  flex layout-fill layout=\"column\" virtual-repeat-flex-helper  class=\"content\">\n        <md-list-item md-virtual-repeat=\"item in vm.balances\">\n          <div class=\"truncate-col symbol-col\" ng-class=\"{certified:item.certified, expired: item.expired}\">{{item.symbol}}</div>\n          <div class=\"truncate-col balance-col right-align\" ng-class=\"{certified:item.certified}\" flex>{{item.balance}}</div>\n        </md-list-item>\n      </md-virtual-repeat-container>\n    </md-list>\n  "
        }),
        Inject('$scope', 'heat', 'user', 'assetInfo', '$q'),
        __metadata("design:paramtypes", [Object, HeatService,
            UserService,
            AssetInfoService, Function])
    ], TraderBalancesComponent);
    return TraderBalancesComponent;
}());
var TraderChartComponent = (function () {
    function TraderChartComponent($scope, heat, $q, $interval, $window) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.$q = $q;
        this.$interval = $interval;
        this.$window = $window;
        this.interval = "HOUR";
        this.filter = 'ALL';
        this.chart = { closeLine: null, close: null, closeArea: null, volumeLine: null, volumeArea: null, data: null, x: null, xAxis: null };
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.subscribeToOrderEvents(_this.currencyInfo.id, _this.assetInfo.id);
                unregister.forEach(function (fn) { return fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        var onresize = utils.debounce(function () { _this.determineElementSize(); }, 50);
        angular.element($window).on('resize', onresize);
        var interval = $interval(function () { _this.checkForFlatline(); }, 2000);
        $scope.$on('$destroy', function () {
            angular.element($window).off('resize', onresize);
            $interval.cancel(interval);
        });
        this.refreshChartDelayed = utils.debounce(function (order) { _this.refreshChart(order); }, 5 * 1000, false);
    }
    TraderChartComponent.prototype.determineElementSize = function () {
        var ohlcchart = document.querySelector('#ohlcchart');
        if (ohlcchart && ohlcchart.offsetWidth > 0 && ohlcchart.offsetHeight > 0) {
            this.fullWidth = ohlcchart.clientWidth;
            this.fullHeight = ohlcchart.clientHeight;
            this.refresh();
            return true;
        }
        return false;
    };
    TraderChartComponent.prototype.getOHLCChartData = function () {
        if (this.filter === 'ONE_DAY' ||
            this.filter === 'ONE_HOUR' ||
            this.filter === 'FIVE_MINUTES' ||
            this.filter === 'ONE_MINUTE') {
            this.interval = 'ONE_MINUTE';
        }
        else {
            this.interval = 'HOUR';
        }
        return this.heat.api.getOHLCChartData(this.currencyInfo.id, this.assetInfo.id, this.interval);
    };
    TraderChartComponent.prototype.subscribeToOrderEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.order({ currency: currency, asset: asset }, function (order) {
            _this.refreshChartDelayed(order);
        }, this.$scope);
    };
    TraderChartComponent.prototype.refreshChart = function (order) {
        if (order.unconfirmed === false) {
            var price = parseInt(order.price);
            var OHLCChartItemData = {
                close: price,
                date: new Date(),
                high: price,
                low: price,
                open: price,
                volume: parseInt(order.quantity)
            };
            this.update(OHLCChartItemData);
        }
    };
    TraderChartComponent.prototype.checkForFlatline = function () {
        if (this.chart.data && this.chart.data.length > 0) {
            var lastDate = this.chart.data[this.chart.data.length - 1].date.getTime();
            var now = new Date().getTime();
            var diff = (now - lastDate) / 1000;
            if (diff > 2) {
                var lastPrice = this.chart.data[this.chart.data.length - 1].close;
                var OHLCChartItemData = {
                    close: lastPrice,
                    date: new Date(),
                    high: lastPrice,
                    low: lastPrice,
                    open: lastPrice,
                    volume: 0
                };
                this.update(OHLCChartItemData);
            }
        }
    };
    TraderChartComponent.prototype.setInterval = function (interval) {
        this.interval = interval;
        this.refresh();
    };
    TraderChartComponent.prototype.setFilter = function (filter) {
        this.filter = filter;
        this.refresh();
    };
    TraderChartComponent.prototype.update = function (OHLCChartItemData) {
        if (!this.chart.data)
            return;
        this.lastTrade = OHLCChartItemData;
        this.chart.data.push(OHLCChartItemData);
        d3.select(".close-line")
            .attr("d", this.chart.closeLine)
            .attr("transform", null)
            .transition();
        d3.select(".close-area")
            .attr("d", this.chart.closeArea)
            .attr("transform", null)
            .transition();
        d3.select(".volume-line")
            .attr("d", this.chart.volumeLine)
            .attr("transform", null)
            .transition();
        d3.select(".volume-area")
            .attr("d", this.chart.volumeArea)
            .attr("transform", null)
            .transition();
        var filterDate = this.getFilterDateTime(this.filter);
        var startDate = new Date(filterDate.valueOf());
        if (this.filter == 'ALL') {
            startDate = this.chart.data[0].date;
        }
        this.chart.x.domain([startDate, new Date()]);
        d3.selectAll("g.x.axis").call(this.chart.xAxis)
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-0.5em")
            .attr("dy", "-0.05em")
            .attr("transform", "rotate(-90)");
        if (this.chart.data[0].date < filterDate) {
            this.chart.data.shift();
        }
    };
    TraderChartComponent.prototype.refresh = function () {
        var _this = this;
        if (!this.currencyInfo || !this.assetInfo)
            return;
        this.getOHLCChartData().then(function (heatChart) {
            var margin = { top: 20, right: 80, bottom: 60, left: 50 }, width = _this.fullWidth - margin.left - margin.right, height = _this.fullHeight - margin.top - margin.bottom;
            var yClose = d3.scaleLinear()
                .range([height, 0]);
            var yVolume = d3.scaleLinear()
                .range([height, 0]);
            var tickFormat;
            if (_this.filter === 'ONE_DAY' ||
                _this.filter === 'ONE_HOUR' ||
                _this.filter === 'FIVE_MINUTES' ||
                _this.filter === 'ONE_MINUTE') {
                tickFormat = '%H:%M:%S';
            }
            else {
                tickFormat = "%m-%d";
            }
            _this.chart.x = d3.scaleTime()
                .range([0, width]);
            var volume = techan.plot.volume()
                .accessor(techan.accessor.ohlc())
                .xScale(_this.chart.x)
                .yScale(yVolume);
            _this.chart.close = techan.plot.close()
                .xScale(_this.chart.x)
                .yScale(yClose);
            _this.chart.xAxis = d3.axisBottom()
                .scale(_this.chart.x)
                .tickSize(-height)
                .tickFormat(d3.timeFormat(tickFormat));
            var yCloseAxis = d3.axisLeft()
                .scale(yClose)
                .ticks(6);
            var yVolumeAxis = d3.axisRight()
                .scale(yVolume)
                .tickFormat(d3.formatPrefix(",.0", 1e6))
                .ticks(6);
            d3.selectAll('svg').remove();
            var svg = d3.select("#ohlcchart").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            var accessor = _this.chart.close.accessor();
            var filterDate = _this.getFilterDateTime(_this.filter);
            _this.chart.data = [];
            heatChart.data.forEach(function (d) {
                var itemDate = utils.timestampToDate(d[0]);
                if (itemDate >= filterDate) {
                    _this.chart.data.push({
                        date: itemDate,
                        open: +d[5],
                        high: +d[3],
                        low: +d[2],
                        close: +d[6],
                        volume: +d[4] / 10
                    });
                }
            });
            _this.chart.data.sort(function (a, b) {
                return d3.ascending(accessor.d(a), accessor.d(b));
            });
            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")");
            svg.append("g")
                .attr("class", "yClose axis");
            svg.append("g")
                .attr("class", "yVolume axis");
            var focus = svg.append("g")
                .attr("class", "focus")
                .style("display", "none");
            focus.append("line").attr("class", "x--line")
                .style("stroke", "#FFFFFF")
                .attr("stroke-width", "1px")
                .attr("y1", -height)
                .attr("y2", 0);
            focus.append("line").attr("class", "y--line")
                .style("stroke", "#FFFFFF")
                .attr("stroke-width", "1px")
                .attr("x1", 0)
                .attr("x2", width);
            focus.append("text")
                .attr('id', 'xyValues')
                .attr("x", 0)
                .attr("y", -15)
                .attr("dy", ".35em")
                .style("fill", "white");
            focus.append("text")
                .attr('id', 'volumeValue')
                .attr("x", 0)
                .attr("y", -5)
                .attr("dy", ".35em")
                .style("fill", "white");
            svg.append("rect").attr("class", "overlay")
                .attr("width", width)
                .attr("height", height)
                .on("mouseover", function () { focus.style("display", null); })
                .on("mouseout", function () { focus.style("display", "none"); })
                .on("mousemove", mousemove);
            var x = _this.chart.x;
            var filter = _this.filter;
            var bisectDate = d3.bisector(function (d) { return d.date; }).left;
            var data = _this.chart.data;
            function mousemove() {
                var x0 = x.invert(d3.mouse(this)[0]), i = bisectDate(data, x0, 1), d0 = data[i - 1], d1 = data[i], d = x0 - d0.date > d1.date - x0 ? d1 : d0;
                var xCoordinate = d.date;
                var yCoordinate = d.close;
                var yCoordinateRightAxis = d.volume / 1000000;
                focus.select(".x--line")
                    .attr("transform", "translate(" + x(d.date) + "," + (height) + ")");
                focus.select(".y--line")
                    .attr("transform", "translate(" + (0) + "," + yClose(yCoordinate) + ")");
                var xText;
                var dd = xCoordinate.getDate();
                var MM = xCoordinate.getMonth();
                var yyyy = xCoordinate.getFullYear();
                var hh = xCoordinate.getHours();
                var mm = xCoordinate.getMinutes();
                var ss = xCoordinate.getSeconds();
                if (dd < 10)
                    dd = '0' + dd;
                if (MM + 1 < 10)
                    MM = '0' + (MM + 1);
                if (hh < 10)
                    hh = '0' + hh;
                if (mm < 10)
                    mm = '0' + mm;
                if (ss < 10)
                    ss = '0' + ss;
                if (filter === 'ONE_DAY' ||
                    filter === 'ONE_HOUR' ||
                    filter === 'FIVE_MINUTES' ||
                    filter === 'ONE_MINUTE') {
                    xText = "".concat(hh, ":").concat(mm, ":").concat(ss);
                }
                else {
                    xText = "".concat(yyyy, "-").concat(MM, "-").concat(dd, " ").concat(hh, ":").concat(mm, ":").concat(ss);
                }
                focus.select("#xyValues").text("".concat(xText, ", ").concat(yCoordinate.toFixed(3)));
                if (yCoordinateRightAxis) {
                    focus.select("#volumeValue").text("Volume: ".concat(yCoordinateRightAxis.toFixed(3)));
                }
            }
            var startDate = new Date(filterDate.valueOf());
            if (_this.filter == 'ALL') {
                startDate = new Date(_this.chart.data[0].date.valueOf());
            }
            yClose.domain(techan.scale.plot.ohlc(_this.chart.data, _this.chart.close.accessor()).domain());
            yVolume.domain(techan.scale.plot.volume(_this.chart.data, _this.chart.close.accessor().v).domain());
            var itemDate;
            if (_this.chart.data.length > 0) {
                _this.lastTrade = _this.chart.data[_this.chart.data.length - 1];
                itemDate = new Date(_this.chart.data[_this.chart.data.length - 1].date.valueOf());
            }
            else {
                itemDate = new Date(startDate.valueOf());
            }
            if (_this.filter === 'ONE_HOUR' ||
                _this.filter === 'FIVE_MINUTES' ||
                _this.filter === 'ONE_MINUTE') {
                var now = new Date();
                while (itemDate <= now) {
                    _this.chart.data.push({
                        date: new Date(itemDate.valueOf()),
                        open: _this.lastTrade.close,
                        high: _this.lastTrade.close,
                        low: _this.lastTrade.close,
                        close: _this.lastTrade.close,
                        volume: 0
                    });
                    itemDate.setSeconds(itemDate.getSeconds() + 2);
                }
                yClose.domain([_this.lastTrade.close - 5000, _this.lastTrade.close + 5000]);
            }
            _this.chart.x.domain([startDate, new Date()]);
            var defs = svg.append("defs");
            _this.chart.volumeArea = d3.area()
                .x(function (d) { return _this.chart.x(d.date); })
                .y0(height)
                .y1(function (d) { return yVolume(d.volume); })
                .curve(d3.curveStep);
            var volumeGradient = defs.append("linearGradient")
                .attr("id", "svgVolumeGradient")
                .attr("x1", "0%")
                .attr("x2", "0%")
                .attr("y1", "100%")
                .attr("y2", "40%");
            volumeGradient.append("stop")
                .attr('class', 'start')
                .attr("offset", "0%")
                .attr("stop-color", "#223141")
                .attr("stop-opacity", 0.1);
            volumeGradient.append("stop")
                .attr('class', 'end')
                .attr("offset", "100%")
                .attr("stop-color", "#4e5fd3")
                .attr("stop-opacity", 0.2);
            svg.append("path")
                .datum(_this.chart.data)
                .attr("class", "volume-area")
                .attr("fill", "url(#svgVolumeGradient)")
                .attr("d", _this.chart.volumeArea);
            _this.chart.volumeLine = d3.line()
                .x(function (d) { return _this.chart.x(d.date); })
                .y(function (d) { return yVolume(d.volume); })
                .curve(d3.curveStep);
            svg.append("path")
                .datum(_this.chart.data)
                .attr("class", "volume-line")
                .attr("fill", "none")
                .attr("stroke", "#4e5fd3")
                .attr("stroke-width", "1px")
                .attr("d", _this.chart.volumeLine);
            _this.chart.closeArea = d3.area()
                .x(function (d) { return _this.chart.x(d.date); })
                .y0(height)
                .y1(function (d) { return yClose(d.close); })
                .curve(d3.curveLinear);
            var closeGradient = defs.append("linearGradient")
                .attr("id", "svgCloseGradient")
                .attr("x1", "0%")
                .attr("x2", "0%")
                .attr("y1", "100%")
                .attr("y2", "40%");
            closeGradient.append("stop")
                .attr('class', 'start')
                .attr("offset", "0%")
                .attr("stop-color", "#223141")
                .attr("stop-opacity", 0.1);
            closeGradient.append("stop")
                .attr('class', 'end')
                .attr("offset", "100%")
                .attr("stop-color", "#ea543d")
                .attr("stop-opacity", 0.2);
            svg.append("path")
                .datum(_this.chart.data)
                .attr("class", "close-area")
                .attr("fill", "url(#svgCloseGradient)")
                .attr("d", _this.chart.closeArea);
            _this.chart.closeLine = d3.line()
                .x(function (d) { return _this.chart.x(d.date); })
                .y(function (d) { return yClose(d.close); })
                .curve(d3.curveLinear);
            svg.append("path")
                .datum(_this.chart.data)
                .attr("class", "close-line")
                .attr("fill", "none")
                .attr("stroke", "#ea543d")
                .attr("stroke-width", "1px")
                .attr("d", _this.chart.closeLine);
            svg.selectAll("g.x.axis").call(_this.chart.xAxis)
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-0.5em")
                .attr("dy", "-0.05em")
                .attr("transform", "rotate(-90)");
            svg.selectAll("g.x.axis")
                .selectAll("line")
                .style("stroke-opacity", "0.4")
                .style('stroke-width', '0.5px');
            svg.selectAll("g.yClose.axis").call(yCloseAxis);
            svg.selectAll("g.yVolume.axis")
                .attr("transform", "translate( " + width + ", 0 )")
                .call(yVolumeAxis);
        });
    };
    TraderChartComponent.prototype.getFilterDateTime = function (filter) {
        var filterDate = new Date();
        switch (filter) {
            case 'ONE_MONTH':
                filterDate.setMonth(filterDate.getMonth() - 1);
                break;
            case 'ONE_WEEK':
                filterDate.setDate(filterDate.getDate() - 7);
                break;
            case 'ONE_DAY':
                filterDate.setDate(filterDate.getDate() - 1);
                break;
            case 'ONE_HOUR':
                filterDate.setHours(filterDate.getHours() - 1);
                break;
            case 'FIVE_MINUTES':
                filterDate.setMinutes(filterDate.getMinutes() - 5);
                break;
            case 'ONE_MINUTE':
                filterDate.setMinutes(filterDate.getMinutes() - 1);
                break;
            default:
                filterDate.setFullYear(filterDate.getFullYear() - 100);
                break;
        }
        return filterDate;
    };
    TraderChartComponent = __decorate([
        Component({
            selector: 'traderChart',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" layout-align=\"end\" class=\"intervals\">\n        <div ng-class=\"{'selected':vm.filter=='ALL'}\" ng-click=\"vm.setFilter('ALL')\">All</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_MONTH'}\" ng-click=\"vm.setFilter('ONE_MONTH')\">1 Month</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_WEEK'}\" ng-click=\"vm.setFilter('ONE_WEEK')\">1 Week</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_DAY'}\" ng-click=\"vm.setFilter('ONE_DAY')\">1 Day</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_HOUR'}\" ng-click=\"vm.setFilter('ONE_HOUR')\">1 Hour</div>\n        <div ng-class=\"{'selected':vm.filter=='FIVE_MINUTES'}\" ng-click=\"vm.setFilter('FIVE_MINUTES')\">5 Minutes</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_MINUTE'}\" ng-click=\"vm.setFilter('ONE_MINUTE')\">1 Minutes</div>\n      </div>\n      <div layout=\"column\" flex layout-fill>\n        <div id=\"ohlcchart\" flex ng-if=\"vm.currencyInfo&&vm.assetInfo\"></div>\n      </div>\n    </div>\n  ",
            link: function (scope, element, attrs, controller) {
                function loop() {
                    if (!controller.determineElementSize()) {
                        setTimeout(loop, 50);
                    }
                }
                setTimeout(loop, 50);
            }
        }),
        Inject('$scope', 'heat', '$q', '$interval', '$window'),
        __metadata("design:paramtypes", [Object, HeatService, Function, Function, Object])
    ], TraderChartComponent);
    return TraderChartComponent;
}());
var TraderInfoAssetDescriptionComponent = (function () {
    function TraderInfoAssetDescriptionComponent($scope, settings, assetInfoService, $q, heat, user, assetWithdraw) {
        var _this = this;
        this.$scope = $scope;
        this.settings = settings;
        this.assetInfoService = assetInfoService;
        this.$q = $q;
        this.heat = heat;
        this.user = user;
        this.assetWithdraw = assetWithdraw;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.$scope.$evalAsync(function () {
                    _this.currencyIssuer = _this.currencyInfo.issuer;
                    _this.currencyIssuerPublicName = _this.currencyInfo.issuerPublicName;
                    _this.currencyLaunched = dateFormat(utils.timestampToDate(_this.currencyInfo.timestamp), format);
                    _this.assetIssuer = _this.assetInfo.issuer;
                    _this.assetIssuerPublicName = _this.assetInfo.issuerPublicName;
                    _this.assetLaunched = dateFormat(utils.timestampToDate(_this.assetInfo.timestamp), format);
                });
                unregister.forEach(function (fn) { return fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    TraderInfoAssetDescriptionComponent.prototype.showDescription = function ($event, info) {
        dialogs.assetInfo($event, info);
    };
    TraderInfoAssetDescriptionComponent.prototype.showDeposit = function ($event, info) {
        dialogs.depositAsset($event, info);
    };
    TraderInfoAssetDescriptionComponent.prototype.showWithdraw = function ($event, info) {
        if (this.currencyInfo.id != '0') {
            this.assetWithdraw.dialog($event, info).then(function (dialog) {
                dialog.show();
            });
        }
    };
    TraderInfoAssetDescriptionComponent = __decorate([
        Component({
            selector: 'traderInfoAssetDescription',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div class=\"asset-container\">\n      <div class=\"asset-description\">\n        <div class=\"col\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Asset name:\n            </div>\n            <div class=\"value\" ng-class=\"{expired: vm.currencyInfo.expired}\">\n              <a ng-click=\"vm.showDescription($event, vm.currencyInfo)\">{{vm.currencyInfo.name}}</a>\n              <span class=\"value\" ng-if=\"vm.currencyInfo.type == 1\">(PRIVATE)</span>\n            </div>\n          </div>\n          <div class=\"col-item issued-by\">\n            <div class=\"title\">\n              Issuer:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/explorer-account/{{vm.currencyIssuer}}/transactions\">{{vm.currencyIssuerPublicName||vm.currencyIssuer}}</a>\n            </div>\n          </div>\n          <div class=\"col-item launched\">\n              <div class=\"title\">Certified:</div>\n              <div class=\"value\">\n                <md-icon ng-class=\"{iscertified:vm.currencyInfo.certified}\" md-font-library=\"material-icons\">{{vm.currencyInfo.certified?'check':'not_interested'}}</md-icon>\n                <span ng-if=\"vm.currencyInfo.certified == true\">Yes</span>\n                <span ng-if=\"vm.currencyInfo.certified == false\">No</span>\n              </div>\n            </div>\n          <div class=\"col-item id\">\n            <div class=\"title\">\n              Launched:\n            </div>\n            <div class=\"value\">\n              {{vm.currencyLaunched}}\n            </div>\n          </div>\n          <div class=\"col-item depositWithdraw\" ng-if=\"vm.currencyInfo.id != '0' && vm.currencyInfo.certified && vm.user.unlocked\">\n            <md-button class=\"md-primary\" ng-click=\"vm.showDeposit($event, vm.currencyInfo)\">Deposit {{vm.currencyInfo.symbol}}</md-button>\n            <md-button class=\"md-warn\" ng-click=\"vm.showWithdraw($event, vm.currencyInfo)\">Withdraw {{vm.currencyInfo.symbol}}</md-button>\n          </div>\n        </div>\n      </div>\n      <div class=\"asset-description\">\n        <div class=\"col\">\n          <div class=\"col-item header\">\n            <div class=\"title\">\n              Asset name:\n            </div>\n            <div class=\"value\" ng-class=\"{expired: vm.assetInfo.expired}\">\n              <a ng-click=\"vm.showDescription($event, vm.assetInfo)\">{{vm.assetInfo.name}}</a>\n              <span class=\"value\" ng-if=\"vm.assetInfo.type == 1\">(PRIVATE)</span>\n            </div>\n          </div>\n          <div class=\"col-item issued-by\">\n            <div class=\"title\">\n              Issuer:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/explorer-account/{{vm.assetIssuer}}/transactions\">{{vm.assetIssuerPublicName||vm.assetIssuer}}</a>\n            </div>\n          </div>\n          <div class=\"col-item launched\">\n            <div class=\"title\">\n              Certified:\n            </div>\n            <div class=\"value\">\n              <md-icon ng-class=\"{iscertified:vm.assetInfo.certified}\" md-font-library=\"material-icons\">{{vm.assetInfo.certified?'check':'not_interested'}}</md-icon>\n              <span ng-if=\"vm.assetInfo.certified===true\">Yes</span>\n              <span ng-if=\"vm.assetInfo.certified===false\">No</span>\n            </div>\n          </div>\n          <div class=\"col-item id\">\n            <div class=\"title\">\n              Launched:\n            </div>\n            <div class=\"value\">\n              {{vm.assetLaunched}}\n            </div>\n          </div>\n          <div class=\"col-item depositWithdraw\" ng-if=\"vm.assetInfo.id != '0' && vm.assetInfo.certified && vm.user.unlocked\">\n            <md-button class=\"md-primary\" ng-click=\"vm.showDeposit($event, vm.assetInfo)\">Deposit {{vm.assetInfo.symbol}}</md-button>\n            <md-button class=\"md-warn\" ng-click=\"vm.showWithdraw($event, vm.assetInfo)\">Withdraw {{vm.assetInfo.symbol}}</md-button>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'settings', 'assetInfo', '$q', 'heat', 'user', 'assetWithdraw'),
        __metadata("design:paramtypes", [Object, SettingsService,
            AssetInfoService, Function, HeatService,
            UserService,
            AssetWithdrawService])
    ], TraderInfoAssetDescriptionComponent);
    return TraderInfoAssetDescriptionComponent;
}());
var TraderInfoComponent = (function () {
    function TraderInfoComponent() {
    }
    TraderInfoComponent = __decorate([
        Component({
            selector: 'traderInfo',
            inputs: ['currencyInfo', 'assetInfo', 'toggleMarkets', 'marketsSidenavOpen'],
            template: "\n    <div>\n      <div class=\"top-row\">\n        <div class=\"market-title\">\n          <span>\n            <md-button class=\"md-icon-button show-hide\" aria-label=\"Show/hide markets\" ng-click=\"vm.toggleMarkets()\">\n              <md-tooltip md-direction=\"bottom\">Show/Hide markets</md-tooltip>\n              <i><img src=\"assets/{{vm.marketsSidenavOpen?'minusIcon':'plusIcon'}}.png\"></i>\n            </md-button>\n          </span>\n          <span class=\"market-title-text\">\n            <span ng-class=\"{certified:vm.currencyInfo.certified, expired: vm.currencyInfo.expired}\">{{vm.currencyInfo.symbol}}</span>\n            /\n            <span ng-class=\"{certified:vm.assetInfo.certified, expired: vm.assetInfo.expired}\">{{vm.assetInfo.symbol}}</span>\n          </span>\n        </div>\n      </div>\n      <trader-info-asset-description currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-info-asset-description>\n    </div>\n  "
        })
    ], TraderInfoComponent);
    return TraderInfoComponent;
}());
var TraderListItemLoadingComponent = (function () {
    function TraderListItemLoadingComponent() {
    }
    TraderListItemLoadingComponent = __decorate([
        Component({
            selector: 'traderListItemLoading',
            template: "\n    <div>\n      <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n    </div>\n  "
        })
    ], TraderListItemLoadingComponent);
    return TraderListItemLoadingComponent;
}());
var TraderMarketsComponent = (function () {
    function TraderMarketsComponent($scope, heat, assetInfo, storage, $q, $mdToast, $interval) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.assetInfo = assetInfo;
        this.storage = storage;
        this.$q = $q;
        this.$mdToast = $mdToast;
        this.$interval = $interval;
        this.sort = 'change';
        this.asc = true;
        this.filter = '';
        this.showCertified = sessionStorage.getItem('trader.markets.showUncertified') != 'true';
        this.preMarkets = [null, null];
        this.markets = [];
        this.showFakeMarketsWarning = true;
        this.filterFunc = function (item) { return _this.filterFuncImpl(item); };
        var refresh = utils.debounce(angular.bind(this, this.loadMarkets), 5 * 1000, false);
        heat.subscriber.trade({}, refresh, $scope);
        this.loadMarkets();
        var interval = $interval(function () {
            _this.loadMarkets();
        }, 20 * 1000, 0, false);
        $scope.$on('$destroy', function () { $interval.cancel(interval); });
    }
    TraderMarketsComponent.prototype.loadMarkets = function () {
        var _this = this;
        this.heat.api.getMarketsAll(this.sort, this.asc, "0", 1, 0, 100).then(function (markets) {
            _this.$scope.$evalAsync(function () {
                if (_this.matchToPreMarkets(markets))
                    return;
                _this.markets = markets;
                var promises = [];
                _this.markets.forEach(function (market) {
                    promises.push(_this.assetInfo.getInfo(market.currency).then(function (info) {
                        _this.$scope.$evalAsync(function () {
                            market.currencyInfo = info;
                        });
                    }));
                    promises.push(_this.assetInfo.getInfo(market.asset).then(function (info) {
                        _this.$scope.$evalAsync(function () {
                            market.assetInfo = info;
                        });
                    }));
                    market.change = "".concat((parseFloat(market.hr24Change) > 0 ? '+' : '')).concat(market.hr24Change, "%");
                    market.price = utils.formatQNT(market.lastPrice, market.currencyDecimals);
                    market.vol = utils.commaFormat(Math.round(parseInt(utils.convertToQNTf(market.hr24AssetVolume))) + '');
                    market.currencyInfo = { symbol: '*' };
                    market.assetInfo = { symbol: '*' };
                });
                _this.$q.all(promises).then(function () {
                    _this.$scope.$evalAsync(function () {
                        _this.markets.sort(function (a, b) {
                            return _this.compareMarket(a, b);
                        });
                    });
                });
                var traderStorage = _this.storage.namespace('trader');
                var mymarkets = traderStorage.enabled ? traderStorage.get('my-markets') : null;
                if (angular.isArray(mymarkets)) {
                    mymarkets = mymarkets.reduce(function (x, y) { return x.findIndex(function (e) { return e.currency.id == y.currency.id && e.asset.id == y.asset.id; }) < 0 ? __spreadArray(__spreadArray([], x, true), [y], false) : x; }, []);
                    mymarkets = mymarkets.filter(function (m) {
                        return !_this.markets.find(function (_m) { return _m.currency == m.currency.id && _m.asset == m.asset.id; });
                    });
                    _this.storage.namespace('trader').put('my-markets', mymarkets);
                    var showWarning = false;
                    mymarkets.forEach(function (m) {
                        if (m.currency && m.asset) {
                            showWarning = true;
                            _this.markets.push({
                                currency: m.currency.id,
                                asset: m.asset.id,
                                change: '*',
                                price: '*',
                                vol: '*',
                                currencyInfo: { symbol: m.currency.symbol },
                                assetInfo: { symbol: m.asset.symbol }
                            });
                        }
                    });
                    if (showWarning && _this.showFakeMarketsWarning) {
                        _this.showFakeMarketsWarning = false;
                        _this.$mdToast.show(_this.$mdToast.simple()
                            .textContent("You must send at least one buy or sell order for the market to become visible in the HEAT network.")
                            .hideDelay(6000));
                    }
                }
            });
        });
    };
    TraderMarketsComponent.prototype.matchToPreMarkets = function (markets) {
        var result = true;
        if (this.preMarkets.length != markets.length) {
            result = false;
        }
        else {
            for (var i = 0; i < markets.length; ++i) {
                var market = markets[i];
                var found = false;
                for (var k = 0; k < this.preMarkets.length; ++k) {
                    var pre = this.preMarkets[k];
                    if (pre != null && market.asset == pre.asset && market.currency == pre.currency) {
                        found = true;
                        if (market.lastPrice != pre.lastPrice || market.hr24Change != pre.hr24Change
                            || market.hr24AssetVolume != pre.hr24AssetVolume || market.hr24CurrencyVolume != pre.hr24CurrencyVolume
                            || market.hr24High != pre.hr24High || market.hr24Low != pre.hr24Low) {
                            result = false;
                            break;
                        }
                    }
                }
                if (!found || !result) {
                    result = false;
                    break;
                }
            }
        }
        this.preMarkets = markets;
        return result;
    };
    TraderMarketsComponent.prototype.isSpecialMarket = function (market) {
        return market.currency == '5592059897546023466' && market.asset == '0';
    };
    TraderMarketsComponent.prototype.compareMarket = function (a, b) {
        var currencyA = a['currencyInfo'];
        var assetA = a['assetInfo'];
        var currencyB = b['currencyInfo'];
        var assetB = b['assetInfo'];
        if (this.isSpecialMarket(a) && !this.isSpecialMarket(b))
            return -1;
        if (!this.isSpecialMarket(a) && this.isSpecialMarket(b))
            return 1;
        var bothCertifiedA = currencyA.certified && assetA.certified;
        var bothCertifiedB = currencyB.certified && assetB.certified;
        if (bothCertifiedA && bothCertifiedB) {
            return this.compareMarketAlphabetical(a, b);
        }
        if (bothCertifiedA != bothCertifiedB) {
            return bothCertifiedA ? -1 : 1;
        }
        var oneCertifiedA = currencyA.certified || assetA.certified;
        var oneCertifiedB = currencyB.certified || assetB.certified;
        if (oneCertifiedA && oneCertifiedB) {
            return this.compareMarketAlphabetical(a, b);
        }
        if (oneCertifiedA != oneCertifiedB) {
            return oneCertifiedA ? -1 : 1;
        }
        return this.compareMarketAlphabetical(a, b);
    };
    TraderMarketsComponent.prototype.compareMarketAlphabetical = function (a, b) {
        var currencyA = a['currencyInfo'];
        var assetA = a['assetInfo'];
        var currencyB = b['currencyInfo'];
        var assetB = b['assetInfo'];
        if (currencyA.symbol < currencyB.symbol)
            return -1;
        if (currencyA.symbol > currencyB.symbol)
            return 1;
        if (assetA.symbol < assetB.symbol)
            return -1;
        if (assetA.symbol > assetB.symbol)
            return 1;
        return 0;
    };
    TraderMarketsComponent.prototype.onFilterChange = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.markets = [].concat(_this.markets);
        });
    };
    TraderMarketsComponent.prototype.toggleShowCertified = function () {
        var _this = this;
        this.showCertified = !this.showCertified;
        sessionStorage.setItem('trader.markets.showUncertified', this.showCertified ? 'false' : 'true');
        this.$scope.$evalAsync(function () {
            _this.markets = [].concat(_this.markets);
        });
    };
    TraderMarketsComponent.prototype.filterFuncImpl = function (market) {
        if (this.filter) {
            var mask = this.filter.toUpperCase();
            if (!(market.assetInfo.symbol.toUpperCase().indexOf(mask) >= 0 ||
                market.assetInfo.name.toUpperCase().indexOf(mask) >= 0 ||
                (market.assetInfo.description !== null && market.assetInfo.description.toUpperCase().indexOf(mask) >= 0) ||
                market.currencyInfo.symbol.toUpperCase().indexOf(mask) >= 0 ||
                market.currencyInfo.name.toUpperCase().indexOf(mask) >= 0 ||
                (market.currencyInfo.description !== null && market.currencyInfo.description.toUpperCase().indexOf(mask) >= 0))) {
                return false;
            }
        }
        if (this.showCertified && !heat.isTestnet) {
            if (market.currency != "0") {
                if (!market.currencyInfo || !market.currencyInfo.certified) {
                    return false;
                }
            }
            if (market.asset != "0") {
                if (!market.assetInfo || !market.assetInfo.certified) {
                    return false;
                }
            }
        }
        return true;
    };
    TraderMarketsComponent = __decorate([
        Component({
            selector: 'traderMarkets',
            template: "\n    <div class=\"trader-component-title\" layout=\"row\">Markets&nbsp;\n      <span flex></span>\n      <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      <a ng-if=\"!isTestnet\" ng-click=\"vm.toggleShowCertified()\" class=\"configure\">Show {{vm.showCertified?'uncertified':'certified only'}}</a>\n    </div>\n    <input type=\"text\" placeholder=\"Search markets\" ng-model=\"vm.filter\" ng-change=\"vm.onFilterChange()\"></input>\n    <md-list flex layout-fill layout=\"column\">\n      <md-list-item>\n        <div class=\"truncate-col market-col\">Market</div>\n        <div class=\"truncate-col change-col\">Change</div>\n        <div class=\"truncate-col price-col\">Price</div>\n        <div class=\"truncate-col vol-col\" flex>Vol</div>\n      </md-list-item>\n      <md-virtual-repeat-container flex layout-fill layout=\"column\"\n          virtual-repeat-flex-helper ng-if=\"vm.markets.length>0\">\n        <md-list-item md-virtual-repeat=\"item in vm.markets | filter: vm.filterFunc\">\n          <div class=\"truncate-col market-col\">\n            <a href=\"#/trader/{{item.currency}}/{{item.asset}}\">\n              <span ng-class=\"{certified:item.currencyInfo.certified, expired: item.currencyInfo.expired}\">\n              {{item.currencyInfo.symbol}}</span>\n              /\n              <span ng-class=\"{certified:item.assetInfo.certified, expired: item.assetInfo.expired}\">\n              {{item.assetInfo.symbol}}</span>\n            </a>\n          </div>\n          <div class=\"truncate-col change-col\">{{item.change}}</div>\n          <div class=\"truncate-col price-col\">{{item.price}}</div>\n          <div class=\"truncate-col vol-col right-align\" flex>{{ item.vol }}</div>\n        </md-list-item>\n      </md-virtual-repeat-container>\n    </md-list>\n  "
        }),
        Inject('$scope', 'heat', 'assetInfo', 'storage', '$q', '$mdToast', '$interval'),
        __metadata("design:paramtypes", [Object, HeatService,
            AssetInfoService,
            StorageService, Function, Object, Function])
    ], TraderMarketsComponent);
    return TraderMarketsComponent;
}());
var TraderOrdersBuyComponent = (function (_super) {
    __extends(TraderOrdersBuyComponent, _super);
    function TraderOrdersBuyComponent($scope, $rootScope, ordersProviderFactory, $q, heat, user) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$rootScope = $rootScope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.heat = heat;
        _this.user = user;
        _this.currencyBalance = "*";
        _this.PAGE_SIZE = 100;
        _this.orders = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, null, false), function (order, context) {
                    order.priceDisplay = utils.formatQNT(order.price, _this.currencyInfo.decimals);
                    order.quantityDisplay = utils.formatQNT(order.unconfirmedQuantity, _this.assetInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.unconfirmedQuantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    _this.orders.push(order);
                }, function (firstIndex, lastIndex, items) {
                    items.forEach(function (order) {
                        if (order['runningTotalQNT']) {
                            order['sum'] = utils.formatQNT(order['sumQNT'].toString(), _this.currencyInfo.decimals);
                            order['runningTotal'] = utils.formatQNT(order['runningTotalQNT'].toString(), _this.assetInfo.decimals);
                        }
                    });
                });
                unregister.forEach(function (fn) { return fn(); });
                _this.subscribeToOrderEvents(_this.currencyInfo.id, _this.assetInfo.id);
                _this.subscribeToTradeEvents(_this.currencyInfo.id, _this.assetInfo.id);
                if (_this.user.unlocked) {
                    _this.updateCurrencyBalance();
                    _this.subscribeToBalanceEvents(_this.user.account, _this.currencyInfo.id);
                }
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 2000, false);
        _this.refreshBalance = utils.debounce(angular.bind(_this, _this.updateCurrencyBalance), 2000, false);
        $scope.$on('balance', function (event, opts) {
            var price = parseInt(_this.orders[0].price);
            var totalQuantity = 0;
            var balance = parseFloat(opts.balance);
            for (var i = 0; i < _this.orders.length; i++) {
                totalQuantity += parseInt(_this.orders[i].quantity);
                if (totalQuantity >= balance) {
                    price = parseInt(_this.orders[i].price);
                    break;
                }
            }
            price = price / 100000000;
            var total = balance * (price);
            _this.$rootScope.$broadcast('price', { price: price, balance: balance, total: total });
        });
        return _this;
    }
    TraderOrdersBuyComponent.prototype.broadcast = function () {
        this.$rootScope.$broadcast('total', { total: this.currencyBalance });
    };
    TraderOrdersBuyComponent.prototype.subscribeToOrderEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.order({ currency: currency, asset: asset }, function (order) {
            if (order.type == 'bid') {
                _this.refreshGrid();
            }
        }, this.$scope);
    };
    TraderOrdersBuyComponent.prototype.subscribeToTradeEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.trade({ currency: currency, asset: asset }, function () {
            _this.refreshGrid();
        }, this.$scope);
    };
    TraderOrdersBuyComponent.prototype.subscribeToBalanceEvents = function (account, currency) {
        this.heat.subscriber.balanceChanged({ account: account, currency: currency }, this.refreshBalance, this.$scope);
    };
    TraderOrdersBuyComponent.prototype.onSelect = function (selectedOrder) {
        this.selectedOrder = selectedOrder;
    };
    TraderOrdersBuyComponent.prototype.updateCurrencyBalance = function () {
        var _this = this;
        this.heat.api.getAccountBalanceVirtual(this.user.account, this.currencyInfo.id, "0", 1).then(function (balance) {
            _this.$scope.$evalAsync(function () {
                _this.currencyBalance = utils.formatQNT(balance.virtualBalance, _this.currencyInfo.decimals);
            });
        }, function () {
            _this.$scope.$evalAsync(function () {
                _this.currencyBalance = "0";
            });
        });
    };
    TraderOrdersBuyComponent = __decorate([
        Component({
            selector: 'traderOrdersBuy',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder'],
            template: "\n    <script type=\"text/ng-template\" id=\"popover.html\">\n      <div class=\"account-popover\">\n        <a href=\"#/explorer-account/{{item.account}}/transactions\">{{item.account||item.accountName}}</a>\n      </div>\n    </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.assetInfo.symbol}} Buyers&nbsp;\n        <span flex></span>\n        <span class=\"balance clickable-text\" ng-click=\"vm.broadcast()\" ng-if=\"vm.user.unlocked\">BALANCE: {{vm.currencyBalance}}&nbsp;{{vm.currencyInfo.symbol}}</span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col total-col\">Total</div>\n          <div class=\"truncate-col sum-col\">Sum ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper  class=\"content\">\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand\n               ng-click=\"vm.select(item)\" aria-label=\"Entry\"\n               ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n            <div class=\"truncate-col info-col\">\n              <div\n                class=\"info\"\n                angular-popover\n                direction=\"right\"\n                template-url=\"popover.html\"\n                mode=\"mouseover\"\n                style=\"position: absolute;\",\n              >\n              </div>\n              <img src=\"assets/info.png\">\n            </div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col sum-col\">{{item.sum}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$rootScope', 'ordersProviderFactory', '$q', 'heat', 'user'),
        __metadata("design:paramtypes", [Object, Object, OrdersProviderFactory, Function, HeatService,
            UserService])
    ], TraderOrdersBuyComponent);
    return TraderOrdersBuyComponent;
}(VirtualRepeatComponent));
var TraderOrdersMyComponent = (function (_super) {
    __extends(TraderOrdersMyComponent, _super);
    function TraderOrdersMyComponent($scope, ordersProviderFactory, $q, user, settings, cancelBidOrder, cancelAskOrder, heat) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.user = user;
        _this.cancelBidOrder = cancelBidOrder;
        _this.cancelAskOrder = cancelAskOrder;
        _this.heat = heat;
        var format = settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, user.account), function (order) {
                    order.typeDisplay = order.type == 'ask' ? 'Sell' : 'Buy';
                    order.market = _this.currencyInfo.symbol + '/' + _this.assetInfo.symbol;
                    order.quantityDisplay = utils.formatQNT(order.quantity, _this.assetInfo.decimals);
                    order.priceDisplay = utils.formatQNT(order.price, _this.currencyInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.quantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    var date = utils.timestampToDate(order.expiration);
                    order.expires = dateFormat(date, format);
                });
                unregister.forEach(function (fn) { return fn(); });
                _this.subscribeToOrderEvents(_this.currencyInfo.id, _this.assetInfo.id);
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 1000, false);
        return _this;
    }
    TraderOrdersMyComponent.prototype.subscribeToOrderEvents = function (currency, asset) {
        var _this = this;
        var filter = { currency: currency, asset: asset, account: this.user.account };
        this.heat.subscriber.order(filter, function (order) {
            _this.refreshGrid();
        }, this.$scope);
    };
    TraderOrdersMyComponent.prototype.onSelect = function (item) { };
    TraderOrdersMyComponent.prototype.cancelOrder = function (order) {
        var dialog = order.type == 'ask' ?
            this.cancelAskOrder.dialog(order.order) :
            this.cancelBidOrder.dialog(order.order);
        if (this.oneClickOrders)
            dialog.send();
        else
            dialog.show();
    };
    TraderOrdersMyComponent = __decorate([
        Component({
            selector: 'traderOrdersMy',
            inputs: ['currencyInfo', 'assetInfo', 'oneClickOrders'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.user.unlocked?'My':'All'}} pending orders&nbsp;\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col type-col\">Type</div>\n          <div class=\"truncate-col market-col\">Market</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col total-col\">Total ({{vm.currencyInfo.symbol}})</div>\n          <div class=\"truncate-col expires-col\" flex>Expires</div>\n          <div class=\"truncate-col cancel-col\" layout=\"row\" layout-align=\"end\" ng-if=\"vm.user.unlocked\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\"\n              ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n            <div class=\"truncate-col type-col\">{{item.typeDisplay}}</div>\n            <div class=\"truncate-col market-col\">{{item.market}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col expires-col\" flex tooltip=\"{{item.expires}}\">{{item.expires}}</div>\n            <div class=\"truncate-col cancel-col\" layout=\"row\" layout-align=\"end\" ng-if=\"vm.user.unlocked\">\n              <a ng-if=\"!item.cancelled && !item.unconfirmed\" ng-click=\"vm.cancelOrder(item)\">Cancel</a>\n            </div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', 'ordersProviderFactory', '$q', 'user', 'settings', 'cancelBidOrder', 'cancelAskOrder', 'heat'),
        __metadata("design:paramtypes", [Object, OrdersProviderFactory, Function, UserService,
            SettingsService,
            CancelBidOrderService,
            CancelAskOrderService,
            HeatService])
    ], TraderOrdersMyComponent);
    return TraderOrdersMyComponent;
}(VirtualRepeatComponent));
var TraderOrdersSellComponent = (function (_super) {
    __extends(TraderOrdersSellComponent, _super);
    function TraderOrdersSellComponent($scope, $rootScope, ordersProviderFactory, $q, heat, user) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$rootScope = $rootScope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.heat = heat;
        _this.user = user;
        _this.assetBalance = "*";
        _this.PAGE_SIZE = 100;
        _this.orders = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, null, true), function (order, context) {
                    order.priceDisplay = utils.formatQNT(order.price, _this.currencyInfo.decimals);
                    order.quantityDisplay = utils.formatQNT(order.unconfirmedQuantity, _this.assetInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.unconfirmedQuantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    _this.orders.push(order);
                }, function (firstIndex, lastIndex, items) {
                    items.forEach(function (order) {
                        if (order['runningTotalQNT']) {
                            order['sum'] = utils.formatQNT(order['sumQNT'].toString(), _this.currencyInfo.decimals);
                            order['runningTotal'] = utils.formatQNT(order['runningTotalQNT'].toString(), _this.assetInfo.decimals);
                        }
                    });
                });
                _this.subscribeToOrderEvents(_this.currencyInfo.id, _this.assetInfo.id);
                _this.subscribeToTradeEvents(_this.currencyInfo.id, _this.assetInfo.id);
                unregister.forEach(function (fn) { return fn(); });
                if (_this.user.unlocked) {
                    _this.updateAssetBalance();
                    _this.subscribeToBalanceEvents(_this.user.account, _this.assetInfo.id);
                }
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 2000, false);
        _this.refreshBalance = utils.debounce(angular.bind(_this, _this.updateAssetBalance), 2000, false);
        $scope.$on('total', function (event, opts) {
            var price = parseInt(_this.orders[0].price);
            var totalQuantity = 0;
            var total = parseFloat(opts.total);
            for (var i = 0; i < _this.orders.length; i++) {
                totalQuantity += (parseFloat(_this.orders[i].quantity) / 100000000);
                if (totalQuantity >= total) {
                    price = parseInt(_this.orders[i].price);
                    break;
                }
            }
            price = price / 100000000;
            var balance = total / price;
            _this.$rootScope.$broadcast('price', { price: price, balance: balance, total: total });
        });
        return _this;
    }
    TraderOrdersSellComponent.prototype.broadcast = function () {
        this.$rootScope.$broadcast('balance', { balance: this.assetBalance });
    };
    TraderOrdersSellComponent.prototype.subscribeToOrderEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.order({ currency: currency, asset: asset }, function (order) {
            if (order.type == 'ask') {
                _this.refreshGrid();
            }
        }, this.$scope);
    };
    TraderOrdersSellComponent.prototype.subscribeToTradeEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.trade({ currency: currency, asset: asset }, function () {
            _this.refreshGrid();
        }, this.$scope);
    };
    TraderOrdersSellComponent.prototype.subscribeToBalanceEvents = function (account, currency) {
        this.heat.subscriber.balanceChanged({ account: account, currency: currency }, this.refreshBalance, this.$scope);
    };
    TraderOrdersSellComponent.prototype.onSelect = function (selectedOrder) {
        this.selectedOrder = selectedOrder;
    };
    TraderOrdersSellComponent.prototype.updateAssetBalance = function () {
        var _this = this;
        this.heat.api.getAccountBalanceVirtual(this.user.account, this.assetInfo.id, "0", 1).then(function (balance) {
            _this.$scope.$evalAsync(function () {
                _this.assetBalance = utils.formatQNT(balance.virtualBalance, _this.assetInfo.decimals);
            });
        }, function () {
            _this.$scope.$evalAsync(function () {
                _this.assetBalance = "0";
            });
        });
    };
    TraderOrdersSellComponent = __decorate([
        Component({
            selector: 'traderOrdersSell',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder'],
            template: "\n    <script type=\"text/ng-template\" id=\"templateId.tml\">\n      <div class=\"account-popover\">\n        <a href=\"#/explorer-account/{{item.account}}/transactions\">{{item.account||item.accountName}}</a>\n      </div>\n    </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.assetInfo.symbol}} Sellers&nbsp;\n        <span flex></span>\n        <span class=\"balance clickable-text\" ng-click=\"vm.broadcast()\" ng-if=\"vm.user.unlocked\">BALANCE: {{vm.assetBalance}}&nbsp;{{vm.assetInfo.symbol}}</span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item  class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col total-col\">Total</div>\n          <div class=\"truncate-col sum-col\">Sum ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper class=\"content\">\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand\n               ng-click=\"vm.select(item)\" aria-label=\"Entry\"\n               ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n           <div class=\"truncate-col info-col\">\n             <div\n              class=\"info\"\n              angular-popover\n              direction=\"right\"\n              template-url=\"templateId.tml\"\n              mode=\"mouseover\"\n              style=\"position: absolute;\">\n             </div>\n             <img src=\"assets/info.png\">\n           </div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col sum-col\">{{item.sum}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$rootScope', 'ordersProviderFactory', '$q', 'heat', 'user'),
        __metadata("design:paramtypes", [Object, Object, OrdersProviderFactory, Function, HeatService,
            UserService])
    ], TraderOrdersSellComponent);
    return TraderOrdersSellComponent;
}(VirtualRepeatComponent));
heat.Loader.directive("maxDecimals", ['$mdToast', function ($mdToast) {
        return {
            require: 'ngModel',
            link: function (scope, elem, attr, ngModel) {
                var decimals;
                var notifyUser = utils.debounce(function () {
                    $mdToast.show($mdToast.simple().textContent("Too many decimals, max ".concat(decimals, " allowed")).hideDelay(3000));
                }, 500, true);
                ngModel.$parsers.unshift(function (value) {
                    decimals = parseInt(attr.maxDecimals);
                    var valid = !utils.hasToManyDecimals(value, decimals);
                    ngModel.$setValidity('decimals', valid);
                    if (!valid) {
                        notifyUser();
                    }
                    return valid ? value : undefined;
                });
            }
        };
    }]);
var TraderQuickBuySellComponent = (function () {
    function TraderQuickBuySellComponent($scope, $q, $mdToast, placeAskOrder, placeBidOrder, user, settings) {
        var _this = this;
        this.$scope = $scope;
        this.$q = $q;
        this.$mdToast = $mdToast;
        this.placeAskOrder = placeAskOrder;
        this.placeBidOrder = placeBidOrder;
        this.user = user;
        this.settings = settings;
        this.quantity = '0';
        this.price = '0';
        this.total = null;
        this.fee = utils.formatQNT(HeatAPI.fee.standard, 8);
        this.EXPIRY_MIN = 3600;
        this.EXPIRY_MAX = 3600 * 24 * 30;
        this.expiryUnitsOptions = {
            'minutes': {
                label: 'Minutes',
                min: Math.round(this.EXPIRY_MIN / 60),
                max: Math.round(this.EXPIRY_MAX / 60),
                delta: 60
            },
            'hours': {
                label: 'Hours',
                min: Math.round(this.EXPIRY_MIN / (60 * 60)),
                max: Math.round(this.EXPIRY_MAX / (60 * 60)),
                delta: 60 * 60
            },
            'days': {
                label: 'Days',
                min: 1,
                max: 30,
                delta: (60 * 60 * 24)
            },
            'weeks': {
                label: 'Weeks',
                min: 1,
                max: 4,
                delta: (60 * 60 * 24 * 7)
            }
        };
        this.expiryUnits = 'days';
        this.expiryUnitsValue = 30;
        this.expiresTooltip = '';
        $scope.$on('price', function (event, opts) {
            _this.price = opts.price.toFixed(8);
            _this.quantity = opts.balance.toFixed(8);
            _this.total = opts.total.toFixed(8);
        });
        $scope.$watch('vm.selectedOrder', function () {
            if (_this.selectedOrder) {
                _this.quantity = _this.selectedOrder['runningTotal'];
                _this.price = utils.formatQNT(_this.selectedOrder.price, _this.currencyInfo.decimals);
                _this.total = _this.selectedOrder['sum'];
                if (_this.selectedOrder.type == 'bid' && angular.isString(_this.assetInfo.userBalance)) {
                    var quantityQNT = new Big(utils.convertToQNT(utils.unformat(_this.quantity), _this.assetInfo.decimals));
                    var balanceQNT = new Big(_this.assetInfo.userBalance);
                    if (balanceQNT.lt(quantityQNT)) {
                        _this.quantity = utils.formatQNT(_this.assetInfo.userBalance, _this.assetInfo.decimals);
                        _this.recalculate();
                    }
                }
                else if (_this.selectedOrder.type == 'ask' && angular.isString(_this.currencyInfo.userBalance)) {
                    var totalQNT = new Big(utils.convertToQNT(utils.unformat(_this.total), _this.currencyInfo.decimals));
                    var balanceQNT = new Big(_this.currencyInfo.userBalance);
                    if (balanceQNT.lt(totalQNT)) {
                        _this.total = utils.formatQNT(_this.currencyInfo.userBalance, _this.currencyInfo.decimals);
                        _this.recalculateTotal();
                    }
                }
            }
        });
        this.isTestnet = heat.isTestnet;
        this.notifyUser = utils.debounce(function (text) {
            $mdToast.show($mdToast.simple().textContent(text).hideDelay(3000));
        }, 500, true);
        this.expiryUnitsValueChanged(true);
    }
    TraderQuickBuySellComponent.prototype.expiryUnitsValueChanged = function (suppressNotification) {
        this.expiry = parseInt(this.expiryUnitsValue + '') * this.expiryUnitsOptions[this.expiryUnits].delta;
        this.expiryValid = false;
        this.expiresTooltip = '';
        if (this.expiry <= this.EXPIRY_MAX && this.expiry >= this.EXPIRY_MIN) {
            this.expiryValid = true;
            var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
            var date = new Date(Date.now() + (this.expiry * 1000));
            var dateFormatted = dateFormat(date, format);
            this.expiresTooltip = "This order will expiry if (even partially) unfilled by ".concat(dateFormatted);
        }
        else {
            var min = this.expiryUnitsOptions[this.expiryUnits].min;
            var max = this.expiryUnitsOptions[this.expiryUnits].max;
            var units = this.expiryUnitsOptions[this.expiryUnits].label;
            this.expiresTooltip = "Min expiry in ".concat(units, " is ").concat(min, ", max expiry in ").concat(units, " is ").concat(max);
            this.notifyUser(this.expiresTooltip);
        }
    };
    TraderQuickBuySellComponent.prototype.quickAsk = function ($event) {
        if (angular.isString(this.assetInfo.userBalance)) {
            var quantityQNT = new Big(utils.convertToQNT(utils.unformat(this.quantity), this.assetInfo.decimals));
            var balanceQNT = new Big(this.assetInfo.userBalance);
            if (balanceQNT.lt(quantityQNT)) {
                this.notifyUser("Insufficient ".concat(this.assetInfo.symbol, " balance"));
                return;
            }
        }
        var dialog = this.placeAskOrder.dialog(this.market, this.currencyInfo, this.assetInfo, utils.unformat(this.price), utils.unformat(this.quantity), parseInt(this.expiry + ''), true, $event);
        if (this.oneClickOrders)
            dialog.send();
        else
            dialog.show();
    };
    TraderQuickBuySellComponent.prototype.quickBid = function ($event) {
        if (angular.isString(this.currencyInfo.userBalance)) {
            var totalQNT = new Big(utils.convertToQNT(utils.unformat(this.total), this.currencyInfo.decimals));
            var balanceQNT = new Big(this.currencyInfo.userBalance);
            if (balanceQNT.lt(totalQNT)) {
                this.notifyUser("Insufficient ".concat(this.currencyInfo.symbol, " balance"));
                return;
            }
        }
        var dialog = this.placeBidOrder.dialog(this.market, this.currencyInfo, this.assetInfo, utils.unformat(this.price), utils.unformat(this.quantity), parseInt(this.expiry + ''), true, $event);
        if (this.oneClickOrders)
            dialog.send();
        else
            dialog.show();
    };
    TraderQuickBuySellComponent.prototype.calculateTotalPrice = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var quantity = utils.unformat(this.quantity) || "0";
            if (price == "0" || quantity == "0") {
                return "";
            }
            else {
                var quantityQNT = utils.convertToQNT(quantity, this.assetInfo.decimals);
                var priceQNT = utils.convertToQNT(price, this.currencyInfo.decimals);
                var totalQNT = utils.calculateTotalOrderPriceQNT(quantityQNT, priceQNT);
                return utils.formatQNT(totalQNT, this.currencyInfo.decimals, true);
            }
        }
        catch (e) {
            return "";
        }
    };
    TraderQuickBuySellComponent.prototype.recalculate = function () {
        this.total = this.calculateTotalPrice();
    };
    TraderQuickBuySellComponent.prototype.recalculateTotal = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var total = utils.unformat(this.total) || "0";
            if (price == "0" || total == "0") {
                this.quantity = "0";
            }
            else {
                this.quantity = new Big(total).div(new Big(price)).toFixed(this.assetInfo.decimals).toString();
            }
        }
        catch (e) {
            console.log(e);
        }
    };
    TraderQuickBuySellComponent = __decorate([
        Component({
            selector: 'traderQuickBuySell',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder', 'oneClickOrders', 'market'],
            template: "\n    <div>\n      <div class=\"trader-component-title\">Buy/Sell&nbsp;<elipses-loading ng-show=\"vm.loading\"></elipses-loading></div>\n      <form name=\"quickBuySellForm\">\n        <div class=\"row\">\n          <div class=\"label\">\n            Unit price\n          </div>\n          <div class=\"input\">\n            <input id=\"trader-quick-buy-sell-price-input\" type=\"text\" ng-model=\"vm.price\" required max-decimals=\"{{vm.currencyInfo.decimals}}\"\n              ng-change=\"vm.recalculate()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.currencyInfo.symbol}} / {{vm.assetInfo.symbol}}\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Amount\n          </div>\n          <div class=\"input\">\n            <input id=\"trader-quick-buy-sell-quantity-input\" type=\"text\" ng-model=\"vm.quantity\" required max-decimals=\"{{vm.assetInfo.decimals}}\"\n              ng-change=\"vm.recalculate()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.assetInfo.symbol}}\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Fees\n          </div>\n          <div class=\"fee input\">\n            {{vm.fee}}\n          </div>\n          <div class=\"label\">\n            HEAT\n          </div>\n        </div>\n\n        <!--<div style=\"margin-top: -13px; color: grey;\">\n            {{vm.market}}\n        </div>-->\n\n        <div ng-if=\"vm.market && vm.market.isIssuerFeePayer\" style=\"margin-top: -13px; color: grey;\">\n            Default fee payer is issuer of the private asset\n        </div>\n\n        <div class=\"row\">\n          <div class=\"label\" ng-class=\"{'expires-invalid': !vm.expiryValid}\">\n            Expires in\n          </div>\n          <div class=\"input\">\n            <input type=\"number\" ng-model=\"vm.expiryUnitsValue\" required name=\"expiry\"\n                      ng-change=\"vm.expiryUnitsValueChanged()\"\n                      min=\"{{vm.expiryUnitsOptions[vm.expiryUnits].min}}\"\n                      max=\"{{vm.expiryUnitsOptions[vm.expiryUnits].max}}\"\n                      ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            <md-menu>\n              <a ng-click=\"$mdMenu.open($event)\">\n                <md-tooltip>{{vm.expiresTooltip}}</md-tooltip>\n                {{vm.expiryUnitsOptions[vm.expiryUnits].label}}\n              </a>\n              <md-menu-content width=\"4\">\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='minutes';vm.expiryUnitsValueChanged()\">Minutes</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='hours';vm.expiryUnitsValueChanged()\">Hours</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='days';vm.expiryUnitsValueChanged()\">Days</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='weeks';vm.expiryUnitsValueChanged()\">Weeks</md-button>\n                </md-menu-item>\n              </md-menu-content>\n            </md-menu>\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Total\n          </div>\n          <div class=\"input\">\n            <input type=\"text\" id=\"trader-quick-buy-sell-total-input\" ng-model=\"vm.total\" required max-decimals=\"{{vm.currencyInfo.decimals}}\"\n              ng-change=\"vm.recalculateTotal()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.currencyInfo.symbol}}\n          </div>\n        </div>\n        <div ng-hide=\"vm.user.unlocked\" class=\"row bottom-row\">\n          <md-button class=\"md-primary\" aria-label=\"Sign in\" href=\"#/login\">\n            Sign in to trade\n          </md-button>\n        </div>\n        <div ng-show=\"vm.user.unlocked\" class=\"row bottom-row\">\n          <div>\n            <md-button class=\"md-primary\" aria-label=\"Buy\" ng-click=\"vm.quickBid($event)\" ng-disabled=\"quickBuySellForm.$invalid||!vm.expiryValid\">\n              BUY\n            </md-button>\n          </div>\n          <div>\n            <md-switch ng-model=\"vm.oneClickOrders\" aria-label=\"1-click orders\" class=\"md-primary\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n              <span ng-show=\"vm.oneClickOrders\"><b>1-click orders enabled</b></span><span ng-hide=\"vm.oneClickOrders\">1-click orders disabled</span>\n            </md-switch>\n          </div>\n          <div>\n            <md-button class=\"md-warn\" aria-label=\"Sell\" ng-click=\"vm.quickAsk($event)\" ng-disabled=\"quickBuySellForm.$invalid||!vm.expiryValid\">\n              SELL\n            </md-button>\n          </div>\n        </div>\n      </form>\n    </div>\n  "
        }),
        Inject('$scope', '$q', '$mdToast', 'placeAskOrder', 'placeBidOrder', 'user', 'settings'),
        __metadata("design:paramtypes", [Object, Function, Object, PlaceAskOrderService,
            PlaceBidOrderService,
            UserService,
            SettingsService])
    ], TraderQuickBuySellComponent);
    return TraderQuickBuySellComponent;
}());
var TraderTradeHistoryComponent = (function (_super) {
    __extends(TraderTradeHistoryComponent, _super);
    function TraderTradeHistoryComponent($scope, $window, tradesProviderFactory, $q, user, settings, heat) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$window = $window;
        _this.tradesProviderFactory = tradesProviderFactory;
        _this.user = user;
        _this.settings = settings;
        _this.heat = heat;
        _this.showTheseTrades = "all";
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.createProvider();
                unregister.forEach(function (fn) { return fn(); });
                var refresh = utils.debounce((angular.bind(_this, _this.determineLength)), 1 * 1000, false);
                heat.subscriber.trade({}, function (trade) {
                    if (trade.currency == _this.currencyInfo.id && trade.asset == _this.assetInfo.id) {
                        var account = _this.showTheseTrades == 'all' ? null : _this.user.account;
                        if (account) {
                            if (trade.seller != account && trade.buyer != account) {
                                return;
                            }
                        }
                        refresh();
                    }
                }, $scope);
                heat.subscriber.blockPopped({}, refresh, $scope);
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        return _this;
    }
    TraderTradeHistoryComponent.prototype.createProvider = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        if (this.$window.innerWidth < 870) {
            format = this.settings.get(SettingsService.TIMEFORMAT_DEFAULT);
        }
        var account = this.showTheseTrades == 'all' ? null : this.user.account;
        this.initializeVirtualRepeat(this.tradesProviderFactory.createProvider(this.currencyInfo.id, this.assetInfo.id, account), function (trade) {
            var date = utils.timestampToDate(trade.timestamp);
            trade.time = dateFormat(date, format);
            if (account) {
                trade.type = trade.seller == account ? 'Sell' : 'Buy';
            }
            else {
                trade.type = trade.isBuy ? 'Buy' : 'Sell';
            }
            trade.priceDisplay = utils.formatQNT(trade.price, _this.currencyInfo.decimals);
            trade.quantityDisplay = utils.formatQNT(trade.quantity, _this.assetInfo.decimals);
            var totalQNT = utils.calculateTotalOrderPriceQNT(trade.quantity, trade.price);
            trade.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
            trade.virtual = trade.block == "0";
        });
    };
    TraderTradeHistoryComponent.prototype.onSelect = function (item) { };
    TraderTradeHistoryComponent.prototype.updateView = function () {
        if (this.currencyInfo && this.assetInfo) {
            this.createProvider();
        }
    };
    TraderTradeHistoryComponent.prototype.onResize = function () {
        this.updateView();
    };
    TraderTradeHistoryComponent = __decorate([
        Component({
            selector: 'traderTradeHistory',
            inputs: ['currencyInfo', 'assetInfo', 'oneClickOrders'],
            template: "\n  <script type=\"text/ng-template\" id=\"popoverHistory.html\">\n    <div class=\"account-popover\">\n      <div>Buyer: <a href=\"#/explorer-account/{{item.buyer}}/transactions\">{{item.buyerName||item.buyer}}</a></div>\n      <div>Seller: <a href=\"#/explorer-account/{{item.seller}}/transactions\">{{item.sellerName||item.seller}}</a></div>\n    </div>\n  </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">Past trades&nbsp;\n        <span flex></span>\n        <span layout=\"row\" ng-if=\"vm.user.unlocked\" class=\"selector\">\n          <label>\n            <input type=\"radio\" name=\"trader-show-trades\" value=\"all\" ng-model=\"vm.showTheseTrades\" ng-change=\"vm.updateView()\">\n            <i>Show all trades</i>\n          </label>\n          <label>\n            <input type=\"radio\" name=\"trader-show-trades\" value=\"my\" ng-model=\"vm.showTheseTrades\" ng-change=\"vm.updateView()\">\n            <i>Show my trades</i>\n          </label>\n        </span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col type-col\">Type</div>\n          <div class=\"truncate-col time-col\" flex>Time</div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">{{vm.assetInfo.symbol}}</div>\n          <div class=\"truncate-col total-col\" flex>Total ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" ng-class=\"{'virtual': item.virtual}\">\n            <div class=\"truncate-col info-col\">\n              <div\n                class=\"info\"\n                angular-popover\n                direction=\"right\"\n                template-url=\"popoverHistory.html\"\n                mode=\"mouseover\"\n                style=\"position: absolute;\">\n              </div>\n              <img src=\"assets/info.png\">\n            </div>\n            <div class=\"truncate-col type-col\">{{item.type}}</div>\n            <div class=\"truncate-col time-col\" flex>{{item.time}}</div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\" flex>{{item.total}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$window', 'tradesProviderFactory', '$q', 'user', 'settings', 'heat'),
        __metadata("design:paramtypes", [Object, Object, TradesProviderFactory, Function, UserService,
            SettingsService,
            HeatService])
    ], TraderTradeHistoryComponent);
    return TraderTradeHistoryComponent;
}(VirtualRepeatComponent));
var TraderTrollboxComponent = (function () {
    function TraderTrollboxComponent($q, $scope, trollbox, $timeout, user) {
        var _this = this;
        this.$q = $q;
        this.$scope = $scope;
        this.trollbox = trollbox;
        this.$timeout = $timeout;
        this.user = user;
        this.messages = [];
        this.nameRegexp = /^(.+)\s\[(\d+)\]$/;
        trollbox.getMessages().forEach(function (promise) {
            promise.then(function (messages) {
                $scope.$evalAsync(function () {
                    var ar = messages.map(function (message) {
                        return _this.augmentMessage(message);
                    });
                    _this.messages = _this.messages.concat(ar);
                });
            });
        });
        trollbox.subscribe(function (event) {
            $scope.$evalAsync(function () {
                if (angular.isObject(event) && angular.isString(event.username) && angular.isString(event.text)) {
                    if (event.username.length > 0 && event.text.length > 0) {
                        _this.messages.push(_this.augmentMessage(event));
                    }
                }
            });
        }, $scope);
        if (angular.isString(user.accountName)) {
            this.name = user.accountName.replace(/@heatwallet.com$/, "");
        }
    }
    TraderTrollboxComponent.prototype.augmentMessage = function (message) {
        if (message.username) {
            var match = message.username.match(this.nameRegexp);
            if (match) {
                message['name'] = match[1];
                message['account'] = match[2];
            }
        }
        try {
            message['text'] = decodeURIComponent(message['text']);
        }
        catch (e) { }
        return message;
    };
    TraderTrollboxComponent.prototype.joinChat = function () {
        this.trollbox.join(this.name);
    };
    TraderTrollboxComponent.prototype.onTextAreaKeyPress = function ($event) {
        var _this = this;
        if ($event.keyCode == 13 && !$event.shiftKey && utils.emptyToNull(this.messageText)) {
            this.trollbox.sendMessage(this.messageText);
            this.$scope.$evalAsync(function () {
                _this.messageText = null;
            });
        }
    };
    TraderTrollboxComponent = __decorate([
        Component({
            selector: 'traderTrollbox',
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div class=\"trader-component-title\">Trollbox&nbsp;\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n<!--\n        <a href=\"https://t.me/joinchat/Bs91sA3agGFXqLaZwWMogg\" target=\"_blank\" rel=\"noopener noreferrer\">Join Telegram!\n          <md-tooltip md-direction=\"bottom\">\n            This trollbox is connected to our Telegram #trollbox channel, post either here or on #trollbox and chat in realtime.\n          </md-tooltip>\n        </a>\n-->\n<!--\n        <a href=\"https://heat-slack.herokuapp.com\" target=\"_blank\" rel=\"noopener noreferrer\">Join Slack!\n          <md-tooltip md-direction=\"bottom\">\n            This trollbox is connected to our Slack #trollbox channel, post either here or on #trollbox and chat in realtime.\n          </md-tooltip>\n        </a>\n-->\n      </div>\n      <div layout=\"row\">\n        <div flex>\n          <input type=\"text\" placeholder=\"Type your name here\" ng-model=\"vm.name\"\n                  ng-disabled=\"!vm.user.unlocked\"></input>\n        </div>\n        <div>\n          <button class=\"md-primary md-button md-ink-ripple\" ng-click=\"vm.joinChat()\" ng-disabled=\"!vm.name || vm.trollbox.name\">Join</button>\n        </div>\n      </div>\n      <div layout=\"column\" flex>\n        <ul class=\"display\" scroll-glue>\n          <li ng-repeat=\"item in vm.messages\">\n            <span><a ng-if=\"item.account\" href=\"#/explorer-account/{{item.account}}/transactions\">{{item.name}}</a>\n            <b ng-if=\"!item.account\">{{item.username}}</b>: {{item.text}}</span>\n          </li>\n        </ul>\n      </div>\n      <div layout=\"row\">\n        <textarea rows=\"2\" ng-keypress=\"vm.onTextAreaKeyPress($event)\"\n          ng-disabled=\"!vm.user.unlocked || !vm.trollbox.name\"\n          placeholder=\"ENTER to send, SHIFT+ENTER for new line\" ng-model=\"vm.messageText\"></textarea>\n      </div>\n    </div>\n  "
        }),
        Inject('$q', '$scope', 'trollbox', '$timeout', 'user'),
        __metadata("design:paramtypes", [Function, Object, TrollboxService, Function, UserService])
    ], TraderTrollboxComponent);
    return TraderTrollboxComponent;
}());
var TraderVolumeComponent = (function () {
    function TraderVolumeComponent($scope, heat, $interval) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.$interval = $interval;
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                unregister.forEach(function (fn) { return fn(); });
                _this.loadMarket();
                var interval_1 = $interval(function () {
                    _this.loadMarket();
                }, 10 * 1000, 0, false);
                $scope.$on('$destroy', function () { $interval.cancel(interval_1); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    TraderVolumeComponent.prototype.loadMarket = function () {
        var _this = this;
        this.heat.api.getMarket(this.currencyInfo.id, this.assetInfo.id, "0", 1).then(function (market) {
            _this.$scope.$evalAsync(function () {
                _this.hr24Change = "".concat((parseFloat(market.hr24Change) > 0 ? '+' : '')).concat(market.hr24Change, "%");
                _this.hr24High = utils.formatQNT(market.hr24High, market.currencyDecimals);
                _this.hr24Low = utils.formatQNT(market.hr24Low, market.currencyDecimals);
                _this.hr24CurrencyVolume = utils.formatQNT(market.hr24CurrencyVolume, market.currencyDecimals) + ' ' + _this.currencyInfo.symbol;
                _this.hr24AssetVolume = utils.formatQNT(market.hr24AssetVolume, market.assetDecimals) + ' ' + _this.assetInfo.symbol;
            });
        });
    };
    TraderVolumeComponent = __decorate([
        Component({
            selector: 'traderVolume',
            inputs: ['market', 'currencyInfo', 'assetInfo'],
            template: "\n    <div layout=\"row\" flex layout-fill layout-align=\"end\">\n      <div class=\"label\">24h change</div>\n      <div class=\"value\">{{vm.hr24Change}}</div>\n      <div class=\"label\">24h high</div>\n      <div class=\"value\">{{vm.hr24High}}</div>\n      <div class=\"label\">24h low</div>\n      <div class=\"value\">{{vm.hr24Low}}</div>\n      <div class=\"label\">24h vol</div>\n      <div class=\"value\">{{vm.hr24CurrencyVolume}}</div>\n      <div class=\"label\">24h vol</div>\n      <div>{{vm.hr24AssetVolume}}</div>\n    </div>\n  "
        }),
        Inject('$scope', 'heat', '$interval'),
        __metadata("design:paramtypes", [Object, HeatService, Function])
    ], TraderVolumeComponent);
    return TraderVolumeComponent;
}());
var TraderComponent = (function () {
    function TraderComponent($scope, user, heatService, $timeout, assetInfoService, $mdSidenav) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.heatService = heatService;
        this.$timeout = $timeout;
        this.assetInfoService = assetInfoService;
        this.$mdSidenav = $mdSidenav;
        this.marketCurrency = "0";
        this.marketSort = "change";
        this.marketAsc = "false";
        this.marketsSidenavOpen = true;
        this.marketsSidenavLockedOpen = true;
        this.showMarketNotCertified = undefined;
        this.toggleMarkets = function () {
            var sidenav = _this.$mdSidenav("trader-markets-sidenav");
            if (sidenav.isOpen()) {
                _this.marketsSidenavLockedOpen = false;
                sidenav.close();
            }
            else {
                _this.marketsSidenavLockedOpen = true;
                sidenav.open();
            }
        };
    }
    TraderComponent.prototype.$onInit = function () {
        var _this = this;
        this.assetInfoService.getInfo(this.currency).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.currencyInfo = info;
            });
        });
        this.assetInfoService.getInfo(this.asset).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.assetInfo = info;
            });
        });
        this.heatService.api.getMarket(this.currency, this.asset, "0", 1).then(function (market) {
            _this.$scope.$evalAsync(function () {
                _this.market = market;
            });
        });
        this.user.account = this.user.account || "";
        this.isTestnet = heat.isTestnet;
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.showMarketNotCertified = !_this.currencyInfo.certified || !_this.assetInfo.certified;
                unregister.forEach(function (fn) {
                    fn();
                });
            }
        };
        var unregister = [this.$scope.$watch('vm.currencyInfo', ready), this.$scope.$watch('vm.assetInfo', ready)];
        setTimeout(function () {
            if (!angular.isDefined(_this.showMarketNotCertified)) {
                _this.$scope.$evalAsync(function () {
                    _this.showMarketNotCertified = true;
                });
            }
        }, 2000);
    };
    TraderComponent = __decorate([
        RouteConfig('/trader/:currency/:asset'),
        Component({
            selector: 'trader',
            inputs: ['currency', 'asset'],
            template: "\n    <div layout=\"row\">\n      <!--\n      <div>\n        <md-button class=\"md-icon-button show-hide\" aria-label=\"Show/hide markets\" ng-click=\"vm.toggleMarkets()\">\n          <md-tooltip md-direction=\"bottom\">Show/Hide markets</md-tooltip>\n          <i><img src=\"assets/{{vm.marketsSidenavOpen?'minusIcon':'plusIcon'}}.png\"></i>\n        </md-button>\n      </div>\n      -->\n      <span flex></span>\n      <trader-volume class=\"trader-component\" market=\"vm.market\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\" layout=\"column\"></trader-volume>\n    </div>\n    <div layout=\"row\" flex layout-fill>\n      <md-sidenav class=\"md-sidenav-left\" md-component-id=\"trader-markets-sidenav\"\n          md-is-locked-open=\"vm.marketsSidenavLockedOpen\" md-is-open=\"vm.marketsSidenavOpen\"\n          md-disable-backdrop flex layout-fill>\n        <div class=\"sidenav-container\">\n          <trader-balances currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\" ng-if=\"vm.user.unlocked\"></trader-balances>\n          <trader-markets></trader-markets>\n        </div>\n      </md-sidenav>\n      <div layout=\"column\" flex layout-fill class=\"main-display\">\n        <div>\n          <div ng-if=\"vm.showMarketNotCertified\">\n            <div class=\"top-warning\">CAUTION: This market comprises of unverified assets.</div>\n          </div>\n          <div class=\"trader-row top\">\n              <trader-info class=\"trader-component\" toggle-markets=\"vm.toggleMarkets\" markets-sidenav-open=\"vm.marketsSidenavOpen\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-info>\n              <trader-chart class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-chart>\n          </div>\n          <div class=\"trader-row middle\">\n            <trader-orders-buy class=\"trader-component\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-orders-buy>\n            <trader-quick-buy-sell class=\"trader-component\" one-click-orders=\"vm.oneClickOrders\"\n                selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\"\n                asset-info=\"vm.assetInfo\" market=\"vm.market\"></trader-quick-buy-sell>\n            <trader-orders-sell class=\"trader-component\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"l></trader-orders-sell>\n          </div>\n          <div class=\"trader-row bottom\">\n            <trader-trade-history class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-trade-history>\n            <trader-orders-my ng-if=\"vm.user.unlocked\" class=\"trader-component\" one-click-orders=\"vm.oneClickOrders\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-orders-my>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'user', 'heat', '$timeout', 'assetInfo', '$mdSidenav'),
        __metadata("design:paramtypes", [Object, UserService,
            HeatService, Function, AssetInfoService, Function])
    ], TraderComponent);
    return TraderComponent;
}());
var TradesProviderFactory = (function () {
    function TradesProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    TradesProviderFactory.prototype.createProvider = function (currency, asset, account) {
        return new TradesProvider(currency, asset, account, this.heat, this.$q);
    };
    TradesProviderFactory = __decorate([
        Service('tradesProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], TradesProviderFactory);
    return TradesProviderFactory;
}());
var TradesProvider = (function () {
    function TradesProvider(currency, asset, account, heat, $q) {
        this.currency = currency;
        this.asset = asset;
        this.account = account;
        this.heat = heat;
        this.$q = $q;
    }
    TradesProvider.prototype.getPaginatedLength = function () {
        if (this.account) {
            return this.heat.api.getAccountTradesCount(this.account, this.currency, this.asset);
        }
        return this.heat.api.getTradesCount(this.currency, this.asset);
    };
    TradesProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (this.account) {
            return this.heat.api.getAccountTrades(this.account, this.currency, this.asset, firstIndex, lastIndex);
        }
        return this.heat.api.getTrades(this.currency, this.asset, firstIndex, lastIndex);
    };
    return TradesProvider;
}());
function createARDRAccount($event, walletComponent) {
    var walletEntries = walletComponent.walletEntries;
    if (walletEntries.length == 0)
        return;
    function DialogController2($scope, $mdDialog) {
        this.data = {
            selectedWalletEntry: walletEntries[0],
            selected: walletEntries[0].account,
            walletEntries: walletEntries,
            password: ''
        };
        this.copySeed = function () {
            walletComponent.clipboard.copyText(document.getElementById('wallet-secret-textarea')['value'], 'Copied seed to clipboard');
        };
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function ($event) {
            var walletEntry = this.data.selectedWalletEntry;
            var success = false;
            if (walletEntry) {
                var node_1 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'ARDOR'; });
                if (!node_1) {
                    var storage = heat.$inject.get('storage');
                    var $rootScope = heat.$inject.get('$rootScope');
                    var store = storage.namespace('wallet', $rootScope, true);
                    var currencies = store.get(walletEntry.account);
                    if (!(currencies instanceof Array))
                        currencies = [];
                    currencies.push('ARDR');
                    store.put(walletEntry.account, currencies.filter(function (value, index, walletComponent) { return walletComponent.indexOf(value) === index; }));
                    walletComponent.initWalletEntry(walletEntry);
                }
                var interval = setInterval(function () {
                    node_1 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'ARDOR'; });
                    if (node_1) {
                        success = node_1.createARDRAddress(walletEntry);
                        walletEntry.toggle(true);
                        $mdDialog.hide(null).then(function () {
                            if (!success) {
                                dialogs.alert($event, 'Unable to Create Address', 'ARDR address already created for this account');
                                success = true;
                            }
                        });
                        clearInterval(interval);
                    }
                }, 0);
                setTimeout(function () {
                    $mdDialog.hide(null).then(function () {
                        if (!success) {
                            dialogs.alert($event, 'Unable to Create Address', 'Something went wrong. Please try again later.');
                        }
                    });
                    clearInterval(interval);
                }, 5000);
            }
        };
        this.selectedWalletEntryChanged = function () {
            var _this = this;
            this.data.password = '';
            this.data.selectedWalletEntry = walletEntries.find(function (w) { return _this.data.selected == w.account; });
        };
        this.passwordChanged = function () {
            var password = this.data.password;
            var account = this.data.selected;
            var walletEntry = walletEntries.find(function (w) { return w.account == account; });
            try {
                var key = walletComponent.localKeyStore.load(account, password);
                if (key) {
                    walletComponent.localKeyStore.rememberPassword(walletEntry.account, password);
                    walletEntry.pin = password;
                    walletEntry.secretPhrase = key.secretPhrase;
                    walletEntry.bip44Compatible = walletComponent.lightwalletService.validSeed(key.secretPhrase);
                    walletEntry.unlocked = true;
                    walletComponent.initWalletEntry(walletEntry);
                    walletEntry.toggle(true);
                }
            }
            catch (e) { }
        };
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController2,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create ARDR Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new ARDR address, please choose the master HEAT account you want to attach the new ARDR address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Put In Password -->\n\n                <div flex layout=\"column\" ng-if=\"vm.data.selectedWalletEntry && !vm.data.selectedWalletEntry.unlocked\">\n                  <p>\n                    Please first unlock this account by entering your password below\n                  </p>\n                  <md-input-container flex >\n                    <label>Password</label>\n                    <input type=\"password\" ng-model=\"vm.data.password\" ng-change=\"vm.passwordChanged()\">\n                  </md-input-container>\n                </div>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  ARDR wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your ARDR address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your ARDR.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea id=\"wallet-secret-textarea\" rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
function createBCHAccount($event, walletComponent) {
    var walletEntries = walletComponent.walletEntries;
    if (walletEntries.length == 0)
        return;
    function DialogController2($scope, $mdDialog) {
        this.data = {
            selectedWalletEntry: walletEntries[0],
            selected: walletEntries[0].account,
            walletEntries: walletEntries,
            password: ''
        };
        this.copySeed = function () {
            walletComponent.clipboard.copyText(document.getElementById('wallet-secret-textarea')['value'], 'Copied seed to clipboard');
        };
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function ($event) {
            var walletEntry = this.data.selectedWalletEntry;
            var success = false;
            if (walletEntry) {
                var node_2 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'BitcoinCash'; });
                if (!node_2) {
                    var storage = heat.$inject.get('storage');
                    var $rootScope = heat.$inject.get('$rootScope');
                    var store = storage.namespace('wallet', $rootScope, true);
                    var currencies = store.get(walletEntry.account);
                    if (!(currencies instanceof Array))
                        currencies = [];
                    currencies.push('BCH');
                    store.put(walletEntry.account, currencies.filter(function (value, index, walletComponent) { return walletComponent.indexOf(value) === index; }));
                    walletComponent.initWalletEntry(walletEntry);
                }
                setTimeout(function () {
                    node_2 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'BitcoinCash'; });
                    success = node_2.createBchAddress(walletEntry);
                    walletEntry.toggle(true);
                    $mdDialog.hide(null).then(function () {
                        if (!success) {
                            dialogs.alert($event, 'Unable to Create Address', 'Make sure you use the previous address first before you can create a new address');
                        }
                    });
                }, 0);
            }
        };
        this.selectedWalletEntryChanged = function () {
            var _this = this;
            this.data.password = '';
            this.data.selectedWalletEntry = walletEntries.find(function (w) { return _this.data.selected == w.account; });
        };
        this.passwordChanged = function () {
            var password = this.data.password;
            var account = this.data.selected;
            var walletEntry = walletEntries.find(function (w) { return w.account == account; });
            try {
                var key = walletComponent.localKeyStore.load(account, password);
                if (key) {
                    walletComponent.localKeyStore.rememberPassword(walletEntry.account, password);
                    walletEntry.pin = password;
                    walletEntry.secretPhrase = key.secretPhrase;
                    walletEntry.bip44Compatible = walletComponent.lightwalletService.validSeed(key.secretPhrase);
                    walletEntry.unlocked = true;
                    walletComponent.initWalletEntry(walletEntry);
                    walletEntry.toggle(true);
                }
            }
            catch (e) { }
        };
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController2,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create Bitcoin Cash Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new Bitcoin Cash address, please choose the master HEAT account you want to attach the new Bitcoin Cash address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Put In Password -->\n\n                <div flex layout=\"column\" ng-if=\"vm.data.selectedWalletEntry && !vm.data.selectedWalletEntry.unlocked\">\n                  <p>\n                    Please first unlock this account by entering your password below\n                  </p>\n                  <md-input-container flex >\n                    <label>Password</label>\n                    <input type=\"password\" ng-model=\"vm.data.password\" ng-change=\"vm.passwordChanged()\">\n                  </md-input-container>\n                </div>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  Btc wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your Bitcoin Cash address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your Bitcoin Cash.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span id=\"wallet-secret-textarea\" style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
function createBtcAccount($event, walletComponent) {
    var walletEntries = walletComponent.walletEntries;
    if (walletEntries.length == 0)
        return;
    function DialogController2($scope, $mdDialog) {
        this.data = {
            selectedWalletEntry: walletEntries[0],
            selected: walletEntries[0].account,
            walletEntries: walletEntries,
            password: ''
        };
        this.copySeed = function () {
            walletComponent.clipboard.copyText(document.getElementById('wallet-secret-textarea')['value'], 'Copied seed to clipboard');
        };
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function ($event) {
            var walletEntry = this.data.selectedWalletEntry;
            var success = false;
            if (walletEntry) {
                var node_3 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'Bitcoin'; });
                if (!node_3) {
                    var storage = heat.$inject.get('storage');
                    var $rootScope = heat.$inject.get('$rootScope');
                    var store = storage.namespace('wallet', $rootScope, true);
                    var currencies = store.get(walletEntry.account);
                    if (!(currencies instanceof Array))
                        currencies = [];
                    currencies.push('BTC');
                    store.put(walletEntry.account, currencies.filter(function (value, index, walletComponent) { return walletComponent.indexOf(value) === index; }));
                    walletComponent.initWalletEntry(walletEntry);
                }
                setTimeout(function () {
                    node_3 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'Bitcoin'; });
                    success = node_3.createBtcAddress(walletEntry);
                    walletEntry.toggle(true);
                    $mdDialog.hide(null).then(function () {
                        if (!success) {
                            dialogs.alert($event, 'Unable to Create Address', 'Make sure you use the previous address first before you can create a new address');
                        }
                    });
                }, 0);
            }
        };
        this.selectedWalletEntryChanged = function () {
            var _this = this;
            this.data.password = '';
            this.data.selectedWalletEntry = walletEntries.find(function (w) { return _this.data.selected == w.account; });
        };
        this.passwordChanged = function () {
            var password = this.data.password;
            var account = this.data.selected;
            var walletEntry = walletEntries.find(function (w) { return w.account == account; });
            try {
                var key = walletComponent.localKeyStore.load(account, password);
                if (key) {
                    walletComponent.localKeyStore.rememberPassword(walletEntry.account, password);
                    walletEntry.pin = password;
                    walletEntry.secretPhrase = key.secretPhrase;
                    walletEntry.bip44Compatible = walletComponent.lightwalletService.validSeed(key.secretPhrase);
                    walletEntry.unlocked = true;
                    walletComponent.initWalletEntry(walletEntry);
                    walletEntry.toggle(true);
                }
            }
            catch (e) { }
        };
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController2,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create Bitcoin Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new Bitcoin address, please choose the master HEAT account you want to attach the new Bitcoin address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Put In Password -->\n\n                <div flex layout=\"column\" ng-if=\"vm.data.selectedWalletEntry && !vm.data.selectedWalletEntry.unlocked\">\n                  <p>\n                    Please first unlock this account by entering your password below\n                  </p>\n                  <md-input-container flex >\n                    <label>Password</label>\n                    <input type=\"password\" ng-model=\"vm.data.password\" ng-change=\"vm.passwordChanged()\">\n                  </md-input-container>\n                </div>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  Btc wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your Bitcoin address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your Bitcoin.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea id=\"wallet-secret-textarea\" rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
function createEthAccount($event, walletComponent) {
    var walletEntries = walletComponent.walletEntries;
    if (walletEntries.length == 0)
        return;
    function DialogController2($scope, $mdDialog) {
        this.data = {
            selectedWalletEntry: walletEntries[0],
            selected: walletEntries[0].account,
            walletEntries: walletEntries,
            password: ''
        };
        this.copySeed = function () {
            walletComponent.clipboard.copyText(document.getElementById('wallet-secret-textarea')['value'], 'Copied seed to clipboard');
        };
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function ($event) {
            var walletEntry = this.data.selectedWalletEntry;
            if (walletEntry) {
                var success_1 = false;
                if (walletEntry) {
                    var node = walletEntry.findAddressCreate(wlt.CURRENCIES.Ethereum.symbol);
                    if (!node) {
                        var storage = heat.$inject.get('storage');
                        var $rootScope = heat.$inject.get('$rootScope');
                        var store = storage.namespace('wallet', $rootScope, true);
                        var currencies = store.get(walletEntry.account);
                        if (!(currencies instanceof Array))
                            currencies = [];
                        currencies.push('ETH');
                        store.put(walletEntry.account, currencies.filter(function (value, index, walletComponent) { return walletComponent.indexOf(value) === index; }));
                        walletComponent.initWalletEntry(walletEntry);
                    }
                    setTimeout(function () {
                        var node = walletEntry.currencies.find(function (c) {
                            return c.isCurrencyAddressCreate && c.name == 'Ethereum';
                        });
                        success_1 = node ? node.createEthAddress(walletEntry) : false;
                        walletEntry.toggle(true);
                        $mdDialog.hide(null).then(function () {
                            if (!success_1) {
                                dialogs.alert($event, 'Unable to Create Address', 'Make sure you use the previous address first before you can create a new address');
                            }
                        });
                    }, 0);
                }
            }
        };
        this.selectedWalletEntryChanged = function () {
            var _this = this;
            this.data.password = '';
            this.data.selectedWalletEntry = walletEntries.find(function (w) { return _this.data.selected == w.account; });
        };
        this.passwordChanged = function () {
            var password = this.data.password;
            var account = this.data.selected;
            var walletEntry = walletEntries.find(function (w) { return w.account == account; });
            try {
                var key = walletComponent.localKeyStore.load(account, password);
                if (key) {
                    walletComponent.localKeyStore.rememberPassword(walletEntry.account, password);
                    walletEntry.pin = password;
                    walletEntry.secretPhrase = key.secretPhrase;
                    walletEntry.bip44Compatible = walletComponent.lightwalletService.validSeed(key.secretPhrase);
                    walletEntry.unlocked = true;
                    walletComponent.initWalletEntry(walletEntry);
                    walletEntry.toggle(true);
                }
            }
            catch (e) { }
        };
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController2,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create Ethereum Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new Ethereum address, please choose the master HEAT account you want to attach the new Ethereum address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Put In Password -->\n\n                <div flex layout=\"column\" ng-if=\"vm.data.selectedWalletEntry && !vm.data.selectedWalletEntry.unlocked\">\n                  <p>\n                    Please first unlock this account by entering your password below\n                  </p>\n                  <md-input-container flex >\n                    <label>Password</label>\n                    <input type=\"password\" ng-model=\"vm.data.password\" ng-change=\"vm.passwordChanged()\">\n                  </md-input-container>\n                </div>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  Eth wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your Ethereum address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your Ethereum.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea id=\"wallet-secret-textarea\" rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
function createFIMKAccount($event, walletComponent) {
    var walletEntries = walletComponent.walletEntries;
    if (walletEntries.length == 0)
        return;
    function DialogController2($scope, $mdDialog) {
        this.data = {
            selectedWalletEntry: walletEntries[0],
            selected: walletEntries[0].account,
            walletEntries: walletEntries,
            password: ''
        };
        this.copySeed = function () {
            walletComponent.clipboard.copyText(document.getElementById('wallet-secret-textarea')['value'], 'Copied seed to clipboard');
        };
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function ($event) {
            var walletEntry = this.data.selectedWalletEntry;
            var success = false;
            if (walletEntry) {
                var node_4 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'FIMK'; });
                if (!node_4) {
                    var storage = heat.$inject.get('storage');
                    var $rootScope = heat.$inject.get('$rootScope');
                    var store = storage.namespace('wallet', $rootScope, true);
                    var currencies = store.get(walletEntry.account);
                    if (!(currencies instanceof Array))
                        currencies = [];
                    currencies.push('FIM');
                    store.put(walletEntry.account, currencies.filter(function (value, index, walletComponent) { return walletComponent.indexOf(value) === index; }));
                    walletComponent.initWalletEntry(walletEntry);
                }
                var interval = setInterval(function () {
                    node_4 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'FIMK'; });
                    if (node_4) {
                        success = node_4.createFIMKAddress(walletEntry);
                        walletEntry.toggle(true);
                        $mdDialog.hide(null).then(function () {
                            if (!success) {
                                dialogs.alert($event, 'Unable to Create Address', 'FIMK address already created for this account');
                                success = true;
                            }
                        });
                        clearInterval(interval);
                    }
                }, 0);
                setTimeout(function () {
                    $mdDialog.hide(null).then(function () {
                        if (!success) {
                            dialogs.alert($event, 'Unable to Create Address', 'Something went wrong. Please try again later.');
                        }
                    });
                    clearInterval(interval);
                }, 5000);
            }
        };
        this.selectedWalletEntryChanged = function () {
            var _this = this;
            this.data.password = '';
            this.data.selectedWalletEntry = walletEntries.find(function (w) { return _this.data.selected == w.account; });
        };
        this.passwordChanged = function () {
            var password = this.data.password;
            var account = this.data.selected;
            var walletEntry = walletEntries.find(function (w) { return w.account == account; });
            try {
                var key = walletComponent.localKeyStore.load(account, password);
                if (key) {
                    walletComponent.localKeyStore.rememberPassword(walletEntry.account, password);
                    walletEntry.pin = password;
                    walletEntry.secretPhrase = key.secretPhrase;
                    walletEntry.bip44Compatible = walletComponent.lightwalletService.validSeed(key.secretPhrase);
                    walletEntry.unlocked = true;
                    walletComponent.initWalletEntry(walletEntry);
                    walletEntry.toggle(true);
                }
            }
            catch (e) { }
        };
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController2,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create FIMK Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new FIMK address, please choose the master HEAT account you want to attach the new FIMK address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Put In Password -->\n\n                <div flex layout=\"column\" ng-if=\"vm.data.selectedWalletEntry && !vm.data.selectedWalletEntry.unlocked\">\n                  <p>\n                    Please first unlock this account by entering your password below\n                  </p>\n                  <md-input-container flex >\n                    <label>Password</label>\n                    <input type=\"password\" ng-model=\"vm.data.password\" ng-change=\"vm.passwordChanged()\">\n                  </md-input-container>\n                </div>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  FIMK wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your FIMK address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your FIMK.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea id=\"wallet-secret-textarea\" rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
function createHEATAccount($event, walletComponent) {
    function DialogController2($scope, $mdDialog) {
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function () {
            var mnemonic = this.heatSeed;
            var pin = this.pin;
            var account = heat.crypto.getAccountId(mnemonic);
            var publicKey = heat.crypto.secretPhraseToPublicKey(mnemonic);
            var key = {
                account: account,
                secretPhrase: mnemonic,
                pincode: pin,
                name: '',
                publicKey: publicKey
            };
            walletComponent.localKeyStore.put(key);
            $scope.$evalAsync(function () {
                walletComponent.initLocalKeyStore();
            });
            $mdDialog.cancel();
        };
        this.generateSeed = function () {
            var _this = this;
            this.heatSeed = walletComponent.lightwalletService.generateRandomSeed();
            walletComponent.$scope.$evalAsync(function () {
                _this.calculatedAccountId = heat.crypto.getAccountId(_this.heatSeed);
            });
        };
        this.generateSeed();
        this.copySeed = function () {
            walletComponent.clipboard.copyText(document.getElementById('wallet-secret-textarea')['value'], 'Copied seed to clipboard');
        };
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController2,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n      <md-dialog>\n        <form name=\"dialogForm\">\n          <md-toolbar>\n            <div class=\"md-toolbar-tools\"><h2>Create HEAT Address</h2></div>\n          </md-toolbar>\n          <md-dialog-content style=\"min-width:500px;max-width:700px\" layout=\"column\" layout-padding>\n            <div flex layout=\"column\">\n              <p>This is your HEAT address seed.\n                Please store it in a safe place or you may lose access to your HEAT.\n                <a ng-click=\"vm.copySeed()\">Copy Seed</a>\n              </p>\n              <md-input-container flex>\n                <textarea id=\"wallet-secret-textarea\" rows=\"3\" flex ng-model=\"vm.heatSeed\" readonly ng-trim=\"false\"\n                    style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n              </md-input-container>\n              <span style=\"display:none\">{{vm.heatSeed}}</span>\n              <label style=\"color: grey; margin: -25px 0px 20px 0px;\">Account {{vm.calculatedAccountId}}</label>\n              <md-input-container flex>\n                <label>Desired Heatwallet PIN / password</label>\n                <input type=\"password\" ng-model=\"vm.pin\" required name=\"pin\">\n              </md-input-container>\n            </div>\n          </md-dialog-content>\n          <md-dialog-actions>\n            <md-button class=\"md-primary md-raised\" ng-disabled=\"!vm.pin\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"=Ok\">Ok</md-button>\n            <md-button class=\"md-primary md-raised\" ng-click=\"vm.generateSeed($event)\" aria-label=\"Generate New\">Generate New</md-button>\n            <md-button class=\"md-warn md-raised\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n          </md-dialog-actions>\n        </form>\n      </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
function createIotaAccount($event, walletComponent) {
    var walletEntries = walletComponent.walletEntries;
    if (walletEntries.length == 0)
        return;
    function DialogController2($scope, $mdDialog) {
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function () {
            $mdDialog.cancel();
        };
        this.generateSeed = function () {
            var length = 81;
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ9";
            var randomValues = new Uint32Array(length);
            var result = new Array(length);
            window.crypto.getRandomValues(randomValues);
            var cursor = 0;
            for (var i = 0; i < randomValues.length; i++) {
                cursor += randomValues[i];
                result[i] = chars[cursor % chars.length];
            }
            this.iotaSeed = result.join('');
        };
        this.generateSeed();
        this.copySeed = function () {
            walletComponent.clipboard.copyText(document.getElementById('wallet-secret-textarea')['value'], 'Copied seed to clipboard');
        };
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController2,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n      <md-dialog>\n        <form name=\"dialogForm\">\n          <md-toolbar>\n            <div class=\"md-toolbar-tools\"><h2>Create IOTA Address</h2></div>\n          </md-toolbar>\n          <md-dialog-content style=\"min-width:500px;max-width:700px\" layout=\"column\" layout-padding>\n            <div flex layout=\"column\">\n              <p>This is your IOTA address seed.\n                Please store it in a safe place or you may lose access to your IOTA.\n                <a ng-click=\"vm.copySeed()\">Copy Seed</a>\n              </p>\n              <p>\n                Proceed to <b>IMPORT SEED/ PRIVATE KEY</b> to import this seed to your wallet.\n              </p>\n              <md-input-container flex>\n                <textarea id=\"wallet-secret-textarea\" rows=\"3\" flex ng-model=\"vm.iotaSeed\" readonly ng-trim=\"false\"\n                    style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n              </md-input-container>\n              <span style=\"display:none\">{{vm.iotaSeed}}</span>\n            </div>\n          </md-dialog-content>\n          <md-dialog-actions>\n            <md-button class=\"md-primary md-raised\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"=Ok\">Ok</md-button>\n            <md-button class=\"md-primary md-raised\" ng-click=\"vm.generateSeed($event)\" aria-label=\"Generate New\">Generate New</md-button>\n            <md-button class=\"md-warn md-raised\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n          </md-dialog-actions>\n        </form>\n      </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
function createLtcAccount($event, walletComponent) {
    var walletEntries = walletComponent.walletEntries;
    if (walletEntries.length == 0)
        return;
    function DialogController2($scope, $mdDialog) {
        this.data = {
            selectedWalletEntry: walletEntries[0],
            selected: walletEntries[0].account,
            walletEntries: walletEntries,
            password: ''
        };
        this.copySeed = function () {
            walletComponent.clipboard.copyWithUI(document.getElementById('wallet-secret-textarea'), 'Copied seed to clipboard');
        };
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function ($event) {
            var walletEntry = this.data.selectedWalletEntry;
            var success = false;
            if (walletEntry) {
                var node_5 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'Litecoin'; });
                if (!node_5) {
                    var storage = heat.$inject.get('storage');
                    var $rootScope = heat.$inject.get('$rootScope');
                    var store = storage.namespace('wallet', $rootScope, true);
                    var currencies = store.get(walletEntry.account);
                    if (!(currencies instanceof Array))
                        currencies = [];
                    currencies.push('LTC');
                    store.put(walletEntry.account, currencies.filter(function (value, index, walletComponent) { return walletComponent.indexOf(value) === index; }));
                    walletComponent.initWalletEntry(walletEntry);
                }
                setTimeout(function () {
                    node_5 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'Litecoin'; });
                    success = node_5.createLtcAddress(walletEntry);
                    walletEntry.toggle(true);
                    $mdDialog.hide(null).then(function () {
                        if (!success) {
                            dialogs.alert($event, 'Unable to Create Address', 'Make sure you use the previous address first before you can create a new address');
                        }
                    });
                }, 0);
            }
        };
        this.selectedWalletEntryChanged = function () {
            var _this = this;
            this.data.password = '';
            this.data.selectedWalletEntry = walletEntries.find(function (w) { return _this.data.selected == w.account; });
        };
        this.passwordChanged = function () {
            var password = this.data.password;
            var account = this.data.selected;
            var walletEntry = walletEntries.find(function (w) { return w.account == account; });
            try {
                var key = walletComponent.localKeyStore.load(account, password);
                if (key) {
                    walletComponent.localKeyStore.rememberPassword(walletEntry.account, password);
                    walletEntry.pin = password;
                    walletEntry.secretPhrase = key.secretPhrase;
                    walletEntry.bip44Compatible = walletComponent.lightwalletService.validSeed(key.secretPhrase);
                    walletEntry.unlocked = true;
                    walletComponent.initWalletEntry(walletEntry);
                    walletEntry.toggle(true);
                }
            }
            catch (e) { }
        };
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController2,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create Litecoin Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new Litecoin address, please choose the master HEAT account you want to attach the new Litecoin address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Put In Password -->\n\n                <div flex layout=\"column\" ng-if=\"vm.data.selectedWalletEntry && !vm.data.selectedWalletEntry.unlocked\">\n                  <p>\n                    Please first unlock this account by entering your password below\n                  </p>\n                  <md-input-container flex >\n                    <label>Password</label>\n                    <input type=\"password\" ng-model=\"vm.data.password\" ng-change=\"vm.passwordChanged()\">\n                  </md-input-container>\n                </div>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  LTC wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your Litecoin address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your Litecoin.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span id=\"wallet-secret-textarea\" style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
function createNXTAccount($event, walletComponent) {
    var walletEntries = walletComponent.walletEntries;
    if (walletEntries.length == 0)
        return;
    function DialogController2($scope, $mdDialog) {
        this.data = {
            selectedWalletEntry: walletEntries[0],
            selected: walletEntries[0].account,
            walletEntries: walletEntries,
            password: ''
        };
        this.copySeed = function () {
            walletComponent.clipboard.copyText(document.getElementById('wallet-secret-textarea')['value'], 'Copied seed to clipboard');
        };
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function ($event) {
            var walletEntry = this.data.selectedWalletEntry;
            var success = false;
            if (walletEntry) {
                var node_6 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'NXT'; });
                if (!node_6) {
                    var storage = heat.$inject.get('storage');
                    var $rootScope = heat.$inject.get('$rootScope');
                    var store = storage.namespace('wallet', $rootScope, true);
                    var currencies = store.get(walletEntry.account);
                    if (!(currencies instanceof Array))
                        currencies = [];
                    currencies.push('NXT');
                    store.put(walletEntry.account, currencies.filter(function (value, index, walletComponent) { return walletComponent.indexOf(value) === index; }));
                    walletComponent.initWalletEntry(walletEntry);
                }
                var interval = setInterval(function () {
                    node_6 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'NXT'; });
                    if (node_6) {
                        success = node_6.createNXTAddress(walletEntry);
                        walletEntry.toggle(true);
                        $mdDialog.hide(null).then(function () {
                            if (!success) {
                                dialogs.alert($event, 'Unable to Create Address', 'NXT address already created for this account');
                                success = true;
                            }
                        });
                        clearInterval(interval);
                    }
                }, 0);
                setTimeout(function () {
                    $mdDialog.hide(null).then(function () {
                        if (!success) {
                            dialogs.alert($event, 'Unable to Create Address', 'Something went wrong. Please try again later.');
                        }
                    });
                    clearInterval(interval);
                }, 5000);
            }
        };
        this.selectedWalletEntryChanged = function () {
            var _this = this;
            this.data.password = '';
            this.data.selectedWalletEntry = walletEntries.find(function (w) { return _this.data.selected == w.account; });
        };
        this.passwordChanged = function () {
            var password = this.data.password;
            var account = this.data.selected;
            var walletEntry = walletEntries.find(function (w) { return w.account == account; });
            try {
                var key = walletComponent.localKeyStore.load(account, password);
                if (key) {
                    walletComponent.localKeyStore.rememberPassword(walletEntry.account, password);
                    walletEntry.pin = password;
                    walletEntry.secretPhrase = key.secretPhrase;
                    walletEntry.bip44Compatible = walletComponent.lightwalletService.validSeed(key.secretPhrase);
                    walletEntry.unlocked = true;
                    walletComponent.initWalletEntry(walletEntry);
                    walletEntry.toggle(true);
                }
            }
            catch (e) { }
        };
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController2,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create NXT Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new NXT address, please choose the master HEAT account you want to attach the new NXT address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Put In Password -->\n\n                <div flex layout=\"column\" ng-if=\"vm.data.selectedWalletEntry && !vm.data.selectedWalletEntry.unlocked\">\n                  <p>\n                    Please first unlock this account by entering your password below\n                  </p>\n                  <md-input-container flex >\n                    <label>Password</label>\n                    <input type=\"password\" ng-model=\"vm.data.password\" ng-change=\"vm.passwordChanged()\">\n                  </md-input-container>\n                </div>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  NXT wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your NXT address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your NXT.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea id=\"wallet-secret-textarea\" rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
function promptSecretPlusPassword($event, walletComponent) {
    function DialogController($scope, $mdDialog) {
        var _this = this;
        this.cancelButtonClick = function () {
            $mdDialog.cancel();
        };
        this.okButtonClick = function () {
            var secretResult = this.data.secretPhraseProcessed || this.data.secretPhrase;
            $mdDialog.hide({
                password: this.data.password1,
                secretPhrase: secretResult,
            });
            importWallet(secretResult, this.data.selectedImport);
        };
        var emptyValidator = function () { return null; };
        var bip44CompatibleValidator = function () {
            return walletComponent.lightwalletService.validSeed(_this.data.secretPhrase)
                ? null
                : "Seed of the chosen currency must be compatible with BIP44";
        };
        var ethereumValidator = function () {
            var bip44Invalid = bip44CompatibleValidator();
            if (bip44Invalid) {
                var s = _this.data.secretPhrase || "";
                _this.data.secretPhraseProcessed = s = s.startsWith("0x") ? s.substring(2) : s;
                if (utils.isHex(s) && s.length == 64)
                    return;
                return "Private key is not valid or " + bip44Invalid;
            }
        };
        var bitcoinValidator = function () {
            var bip44Invalid = bip44CompatibleValidator();
            if (bip44Invalid) {
                var s = _this.data.secretPhrase || "";
                _this.data.secretPhraseProcessed = s = s.startsWith("0x") ? s.substring(2) : s;
                if (utils.isHex(s) && s.length == 64)
                    return;
                var regex = /^[5KL][1-9A-HJ-NP-Za-km-z]{50,51}$/;
                if (regex.test(s))
                    return;
                return "Private key is not valid or " + bip44Invalid;
            }
        };
        this.currencyList = [
            { name: 'HEAT', symbol: 'HEAT', validate: emptyValidator },
            { name: 'Ethereum', symbol: 'ETH', validate: ethereumValidator },
            { name: 'Bitcoin', symbol: 'BTC', validate: bitcoinValidator },
            { name: 'FIMK', symbol: 'FIM', validate: emptyValidator },
            { name: 'NXT', symbol: 'NXT', validate: emptyValidator },
            { name: 'ARDOR', symbol: 'ARDR', validate: emptyValidator },
            { name: 'IOTA', symbol: 'IOTA', validate: emptyValidator },
            { name: 'Litecoin', symbol: 'LTC', validate: bip44CompatibleValidator },
            { name: 'BitcoinCash', symbol: 'BCH', validate: bip44CompatibleValidator }
        ];
        this.data = {
            password1: '',
            password2: '',
            secretPhrase: '',
            secretPhraseProcessed: '',
            bip44Compatible: false,
            selectedImport: null
        };
        this.secretChanged = function () {
            this.data.bip44Compatible = walletComponent.lightwalletService.validSeed(this.data.secretPhrase);
        };
        this.invalidParameters = function () {
            var _a, _b;
            var searchingSymbol = typeof this.data.selectedImport == "string"
                ? (_a = JSON.parse(this.data.selectedImport)) === null || _a === void 0 ? void 0 : _a.symbol
                : (_b = this.data.selectedImport) === null || _b === void 0 ? void 0 : _b.symbol;
            var selectedCurrency = this.currencyList.find(function (item) { return item.symbol == searchingSymbol; });
            if (selectedCurrency) {
                var validateResult = selectedCurrency.validate();
                if (validateResult)
                    return validateResult;
                if (this.data.password1 != this.data.password2)
                    return "PINs are not equal";
                return null;
            }
            return "  ";
        };
    }
    function importWallet(secret, selectedImport) {
        if (typeof selectedImport == "string")
            selectedImport = JSON.parse(selectedImport);
        var storage = heat.$inject.get('storage');
        var $rootScope = heat.$inject.get('$rootScope');
        var store = storage.namespace('wallet', $rootScope, true);
        var accountId = heat.crypto.getAccountId(secret);
        var currencies = store.get(accountId) || [];
        currencies.push(selectedImport.symbol);
        var distinctValues = function (value, index, walletComponent) {
            return walletComponent.indexOf(value) === index;
        };
        store.put(accountId, currencies.filter(distinctValues));
        var n = 0;
        var interval = setInterval(function () {
            n++;
            if (n > 50)
                clearInterval(interval);
            var wc = WalletComponent.instance;
            if (wc != walletComponent) {
                var entry = wc.entries.find(function (w) { return w instanceof wlt.WalletEntry && w.account == accountId; });
                if (entry) {
                    var v = entry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == selectedImport.name; });
                    if (v) {
                        v.createAddressByName();
                    }
                }
                clearInterval(interval);
            }
        }, 200);
    }
    var deferred = walletComponent.$q.defer();
    walletComponent.$mdDialog.show({
        controller: DialogController,
        parent: angular.element(document.body),
        targetEvent: $event,
        clickOutsideToClose: false,
        controllerAs: 'vm',
        template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Import Seed/Private Key</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>Select currency to import</p>\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selectedImport\" placeholder=\"Select currency\" auto-focus>\n                    <md-option style=\"height: 30px;\" ng-repeat=\"entry in vm.currencyList\" value=\"{{entry}}\">{{entry.symbol}}</md-option>\n                  </md-select>\n                </md-input-container>\n                <p>Enter your Private Key / Secret Phrase / Wallet Seed and provide a Password (or PIN)</p>\n                <md-input-container flex>\n                  <label>Private key / secret phrase</label>\n                  <textarea rows=\"2\" flex ng-model=\"vm.data.secretPhrase\" name=\"secretPhrase\" required ng-trim=\"false\" ng-change=\"vm.secretChanged() \"></textarea>\n                </md-input-container>\n                <md-input-container flex>\n                  <label>Desired Heatwallet PIN / password</label>\n                  <input type=\"password\" ng-model=\"vm.data.password1\" required name=\"password1\">\n                </md-input-container>\n                <md-input-container flex>\n                  <label>Desired Heatwallet PIN / password (confirm)</label>\n                  <input type=\"password\" ng-model=\"vm.data.password2\" required name=\"password2\">\n                </md-input-container>\n                <span>BIP44 compatible = <b>{{vm.data.bip44Compatible?'TRUE':'FALSE'}}</b></span>\n                <p>{{vm.invalidParameters()}}</p>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button type=\"submit\" ng-disabled=\"dialogForm.$invalid || vm.invalidParameters() != null\" class=\"md-primary\"\n                  ng-click=\"vm.okButtonClick()\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
    }).then(deferred.resolve, deferred.reject);
    return deferred.promise;
}
var wltStandalone;
(function (wltStandalone) {
    function exportWallet(onlyData) {
        var _this = this;
        var accountCurrencies = new Map();
        this.entries.forEach(function (entry) {
            if (entry instanceof wlt.WalletEntry) {
                var currencies = _this.store.get(entry.account);
                if (currencies)
                    accountCurrencies.set(entry.account, currencies);
            }
        });
        var accountAddressesArray = Object.entries(wlt.createdAddresses);
        var accountAddresses = accountAddressesArray
            .map(function (item) { return [item[0], Array.from(item[1])]; })
            .filter(function (v) { var _a; return ((_a = v[1]) === null || _a === void 0 ? void 0 : _a.length) > 0; });
        var exported = exportInternal(accountCurrencies, accountAddresses);
        var paymentMessages = wlt.exportPaymentMessages();
        exported = Object.assign(exported, { paymentMessages: paymentMessages });
        var encoded = this.walletFile.encode(exported);
        var blob = new Blob([encoded], { type: "text/plain;charset=utf-8" });
        if (onlyData)
            return blob;
        wlt.saveFile(blob, "heat.wallet");
    }
    wltStandalone.exportWallet = exportWallet;
    function exportInternal(accountCurrencies, accountAddresses) {
        var walletFileData = {
            version: 2,
            entries: [],
            accountAddresses: accountAddresses
        };
        var store = this.storage.namespace('wallet-address', this.$rootScope, true);
        this.listLocalKeyEntries().forEach(function (entry) {
            var cryptoAddresses;
            wlt.CURRENCIES_LIST.forEach(function (c) {
                var encryptedAddresses = store.get("".concat(c.symbol, "-").concat(entry.account));
                if (encryptedAddresses) {
                    cryptoAddresses = cryptoAddresses || {};
                    cryptoAddresses[c.symbol] = encryptedAddresses;
                }
            });
            var item = {
                account: entry.account,
                contents: entry.contents,
                isTestnet: entry.isTestnet,
                name: entry.name,
                visibleLabel: wlt.getEntryVisibleLabel(entry.account),
                currencies: accountCurrencies.get(entry.account)
            };
            if (cryptoAddresses)
                item.cryptoAddresses = cryptoAddresses;
            walletFileData.entries.push(item);
        });
        return walletFileData;
    }
    function initLocalKeyStore() {
        var _this = this;
        var walletEntries = [];
        this.localKeyStore.list().map(function (account) {
            var name = _this.localKeyStore.getName(account);
            var walletEntry = new wlt.WalletEntry(account, name, _this);
            walletEntries.push(walletEntry);
        });
        walletEntries.sort(function (a, b) {
            return a.account.localeCompare(b.account);
        });
        walletEntries.forEach(function (walletEntry) {
            var password = _this.localKeyStore.getPasswordForAccount(walletEntry.account);
            if (password) {
                try {
                    var key = _this.localKeyStore.load(walletEntry.account, password);
                    if (key && !walletEntry["cached"]) {
                        walletEntry.secretPhrase = key.secretPhrase;
                        walletEntry.bip44Compatible = _this.lightwalletService.validSeed(key.secretPhrase);
                        walletEntry.unlocked = true;
                        walletEntry.pin = password;
                        walletEntry.label = key.label;
                        _this.initWalletEntry(walletEntry);
                    }
                }
                catch (e) {
                    console.log(e);
                }
            }
        });
        this.flatten();
        this.fetchCryptoAddresses('BTC');
    }
})(wltStandalone || (wltStandalone = {}));
var wlt;
(function (wlt) {
    wlt.CURRENCIES = {
        HEAT: { name: 'HEAT', symbol: 'HEAT', multiAddress: true },
        Ethereum: { name: 'Ethereum', symbol: 'ETH', multiAddress: true },
        Bitcoin: { name: 'Bitcoin', symbol: 'BTC', multiAddress: true },
        FIMK: { name: 'FIMK', symbol: 'FIM', multiAddress: false },
        NXT: { name: 'NXT', symbol: 'NXT', multiAddress: false },
        ARDOR: { name: 'ARDOR', symbol: 'ARDR', multiAddress: false },
        IOTA: { name: 'IOTA', symbol: 'IOTA', multiAddress: false },
        Litecoin: { name: 'Litecoin', symbol: 'LTC', multiAddress: true },
        BitcoinCash: { name: 'BitcoinCash', symbol: 'BCH', multiAddress: true }
    };
    wlt.CURRENCIES_LIST = Object.keys(wlt.CURRENCIES).map(function (k) { return wlt.CURRENCIES[k]; });
    wlt.CURRENCIES_MAP = new Map(Object.entries(wlt.CURRENCIES));
    wlt.DISPLAYED_MAX_EMPTY_ADDRESSES = 4;
    wlt.createdAddresses = {};
    wlt.HASH_PREFIX = "XYZ";
    wlt.SATOSHI_PER_BTC = new Big(100000000);
    var storageMap = new Map();
    var UNCONFIRMED_CURRENCY_BALANCE_LIFETIME = 3000 * 60;
    window.addEventListener("beforeunload", function (e) {
        if (wlt.shouldBeSaved) {
            try {
                saveFile(wlt.shouldBeSaved);
            }
            catch (e) {
                console.error(e);
            }
            e.returnValue = "\o/";
        }
    });
    var distinctValues = function (value, index, self) {
        return self.indexOf(value) === index;
    };
    function getStore(namespace) {
        if (namespace === void 0) { namespace = "wallet"; }
        var store = storageMap.get(namespace);
        if (store)
            return store;
        var storage = heat.$inject.get('storage');
        var $rootScope = heat.$inject.get('$rootScope');
        store = storage.namespace(namespace, $rootScope, true);
        storageMap.set(namespace, store);
        return store;
    }
    wlt.getStore = getStore;
    function saveCurrencyBalance(address, currencySymbol, balance, unconfirmedBalance) {
        var hash = heat.crypto.hash(address).substring(0, 16);
        var key = "balance-".concat(currencySymbol, "-").concat(hash);
        var r = getStore().get(key);
        if (r) {
            r.b = balance;
            if (unconfirmedBalance) {
                r.ub = unconfirmedBalance;
                r.t = Date.now();
            }
            getStore().put(key, r);
        }
        else {
            getStore().put(key, { b: balance, ub: unconfirmedBalance, t: Date.now() });
        }
    }
    wlt.saveCurrencyBalance = saveCurrencyBalance;
    function getSavedCurrencyBalance(address, currencySymbol, balance) {
        var hash = heat.crypto.hash(address).substring(0, 16);
        var key = "balance-".concat(currencySymbol, "-").concat(hash);
        var r = getStore().get(key);
        if (r) {
            if (r.ub && r.t + UNCONFIRMED_CURRENCY_BALANCE_LIFETIME < Date.now()) {
                return { confirmed: r.b };
            }
            return { confirmed: r.b, unconfirmed: r.ub };
        }
        return { confirmed: balance };
    }
    wlt.getSavedCurrencyBalance = getSavedCurrencyBalance;
    function getEntryVisibleLabel(account) {
        return getStore().get("label." + account);
    }
    wlt.getEntryVisibleLabel = getEntryVisibleLabel;
    function updateEntryVisibleLabel(account, visibleLabel) {
        var storeKey = "label." + account;
        if (visibleLabel) {
            getStore().put(storeKey, visibleLabel);
        }
        else {
            getStore().remove(storeKey);
        }
    }
    wlt.updateEntryVisibleLabel = updateEntryVisibleLabel;
    function updateEntryCurrencies(account, currencies) {
        if (currencies) {
            var mergedCurrencies = getStore().get(account) || [];
            mergedCurrencies.push.apply(mergedCurrencies, currencies);
            getStore().put(account, mergedCurrencies.filter(distinctValues));
        }
    }
    wlt.updateEntryCurrencies = updateEntryCurrencies;
    function initCreatedAddresses() {
        var removingKeys = [];
        var addingItems = [];
        var addingValues = [];
        wlt.createdAddresses = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var origKey = window.localStorage.key(i);
            if (origKey.startsWith("addresscreated-") || origKey.startsWith("eth-address-created")) {
                var key = tryClearKey(origKey, removingKeys, addingValues);
                var s = key.substring(key.indexOf("-") + 1);
                var acc = s.substring(0, s.indexOf("-"));
                var addr = s.substring(s.indexOf("-") + 1);
                var addresses = wlt.createdAddresses[acc] || new Map();
                var value = window.localStorage.getItem(key);
                var balance = (value === null || value === void 0 ? void 0 : value.startsWith("balance")) ? value.substring(7) : "";
                var addrHash = addr.startsWith(wlt.HASH_PREFIX) ? addr : null;
                if (!addrHash) {
                    addrHash = wlt.HASH_PREFIX + heat.crypto.hash(addr);
                    addingItems.push([acc, addrHash, balance]);
                    removingKeys.push(origKey);
                }
                addresses.set(addrHash, balance);
                wlt.createdAddresses[acc] = addresses;
            }
        }
        for (var _i = 0, removingKeys_1 = removingKeys; _i < removingKeys_1.length; _i++) {
            var key = removingKeys_1[_i];
            var v = window.localStorage.getItem(key);
            window.localStorage.setItem("[obsolete]" + key, v);
            window.localStorage.removeItem(key);
        }
        for (var _a = 0, addingItems_1 = addingItems; _a < addingItems_1.length; _a++) {
            var item = addingItems_1[_a];
            rememberAddressCreated(item[0], item[1], item[2]);
        }
        for (var _b = 0, addingValues_1 = addingValues; _b < addingValues_1.length; _b++) {
            var item = addingValues_1[_b];
            window.localStorage.setItem(item[0], item[1]);
        }
    }
    wlt.initCreatedAddresses = initCreatedAddresses;
    function tryClearKey(key, removingKeys, addingValues) {
        if (key.indexOf(wlt.HASH_PREFIX) > -1)
            return key;
        var s = key.replace("eth-address-created", "addresscreated");
        s = s.replace("address-created:", "");
        s = s.replace(":", "-");
        s = s.replace("bitcoincash-", "bitcoincash:");
        var i = s.indexOf(",");
        if (i > -1)
            s = s.substring(0, i);
        if (key != s) {
            var value = window.localStorage.getItem(key);
            addingValues.push([s, value]);
            removingKeys.push(key);
        }
        return s;
    }
    function rememberCryptoAddressCreated(walletEntry, currencySymbol, address) {
        var cryptoAddresses = getCryptoAddresses(walletEntry, currencySymbol);
        if (!cryptoAddresses)
            return null;
        var foundAddress = cryptoAddresses.addresses.find(function (a) { return a.address == address; });
        if (!foundAddress)
            return null;
        if (!foundAddress.created) {
            foundAddress.created = true;
            saveCryptoAddresses(walletEntry, currencySymbol, cryptoAddresses);
        }
        return foundAddress;
    }
    wlt.rememberCryptoAddressCreated = rememberCryptoAddressCreated;
    function rememberAddressCreated(account, addressHash, balance) {
        wlt.createdAddresses[account] = wlt.createdAddresses[account] || new Map();
        wlt.createdAddresses[account].set(addressHash, balance || "");
        window.localStorage.setItem("addresscreated-".concat(account, "-").concat(addressHash), balance ? "balance" + balance : "1");
    }
    wlt.rememberAddressCreated = rememberAddressCreated;
    function getCurrencyBalances(walletEntry, currencyName) {
        return walletEntry.currencies.filter(function (c) { return c['isCurrencyBalance'] && c.name == currencyName; });
    }
    wlt.getCurrencyBalances = getCurrencyBalances;
    function isLimitReached(currencyBalances) {
        var emptyBalanceCounter = 0;
        currencyBalances.forEach(function (value) {
            if (value.isZeroBalance())
                emptyBalanceCounter++;
        });
        return emptyBalanceCounter >= wlt.DISPLAYED_MAX_EMPTY_ADDRESSES;
    }
    wlt.isLimitReached = isLimitReached;
    var TokenBalance = (function () {
        function TokenBalance(name, symbol, address) {
            this.name = name;
            this.symbol = symbol;
            this.address = address;
            this.isTokenBalance = true;
            this.visible = false;
        }
        return TokenBalance;
    }());
    wlt.TokenBalance = TokenBalance;
    var CurrencyBalance = (function () {
        function CurrencyBalance(name, symbol, address, secretPhrase, index) {
            this.name = name;
            this.symbol = symbol;
            this.address = address;
            this.secretPhrase = secretPhrase;
            this.index = index;
            this.isCurrencyBalance = true;
            this.inUse = false;
            this.tokens = [];
            this.visible = false;
            this.hidden = false;
            this.formatBalance = function (balance) {
                return balance;
            };
        }
        Object.defineProperty(CurrencyBalance.prototype, "balance", {
            get: function () {
                var result;
                if (this.isCurrencyBalance && this.symbol) {
                    var r = getSavedCurrencyBalance(this.address, this.symbol, this._balance);
                    result = r === null || r === void 0 ? void 0 : r.confirmed;
                }
                else {
                    result = this._balance;
                }
                return this.formatBalance(result);
            },
            set: function (value) {
                this._balance = value;
            },
            enumerable: false,
            configurable: true
        });
        CurrencyBalance.prototype.unlock = function (noPathChange) {
            var user = heat.$inject.get('user');
            var $location = heat.$inject.get('$location');
            var lightwalletService = heat.$inject.get('lightwalletService');
            var bip44Compatible = lightwalletService.validSeed(this.secretPhrase);
            var currency = null;
            if (this.name == 'Ethereum') {
                currency = new ETHCurrency(this.walletEntry.secretPhrase, this.secretPhrase, this.address);
            }
            else if (this.name == 'Bitcoin') {
                currency = new BTCCurrency(this.walletEntry.secretPhrase, this.secretPhrase, this.address);
            }
            else if (this.name == 'FIMK') {
                currency = new FIMKCurrency(this.walletEntry.secretPhrase, this.secretPhrase, this.address);
            }
            else if (this.name == 'NXT') {
                currency = new NXTCurrency(this.walletEntry.secretPhrase, this.secretPhrase, this.address);
            }
            else if (this.name == 'Iota') {
                currency = new IOTACurrency(this.walletEntry.secretPhrase, this.secretPhrase, this.address);
            }
            else if (this.name == 'ARDOR') {
                currency = new ARDRCurrency(this.walletEntry.secretPhrase, this.secretPhrase, this.address);
            }
            else if (this.name == 'Litecoin') {
                currency = new LTCCurrency(this.walletEntry.secretPhrase, this.secretPhrase, this.address);
            }
            else if (this.name == 'BitcoinCash') {
                currency = new BCHCurrency(this.walletEntry.secretPhrase, this.secretPhrase, this.address);
            }
            else {
                currency = new HEATCurrency(this.walletEntry ? this.walletEntry.secretPhrase : this.secretPhrase, this.secretPhrase, this.address);
            }
            user.unlock(this.secretPhrase, null, bip44Compatible, currency).then(function () {
                if (!noPathChange) {
                    $location.path(currency.homePath);
                    heat.fullApplicationScopeReload();
                }
            });
        };
        CurrencyBalance.prototype.isZeroBalance = function () {
            return !CurrencyBalance.hasNoZeroDigit.test(this._balance);
        };
        CurrencyBalance.prototype.hasDigit = function () {
            return CurrencyBalance.hasDigit.test(this._balance);
        };
        CurrencyBalance.hasNoZeroDigit = /[1-9]/;
        CurrencyBalance.hasDigit = /[0-9]/;
        return CurrencyBalance;
    }());
    wlt.CurrencyBalance = CurrencyBalance;
    var CurrencyAddressLoading = (function () {
        function CurrencyAddressLoading(name) {
            var _a;
            this.name = name;
            this.isCurrencyAddressLoading = true;
            this.visible = false;
            this.currencySymbol = (_a = wlt.CURRENCIES_MAP.get(name)) === null || _a === void 0 ? void 0 : _a.symbol;
        }
        return CurrencyAddressLoading;
    }());
    wlt.CurrencyAddressLoading = CurrencyAddressLoading;
    var CurrencyAddressCreate = (function () {
        function CurrencyAddressCreate(name, wallet, walletEntry, component) {
            var _a;
            this.name = name;
            this.wallet = wallet;
            this.walletEntry = walletEntry;
            this.component = component;
            this.isCurrencyAddressCreate = true;
            this.visible = false;
            this.hidden = true;
            this.walletEntry = walletEntry;
            this.currencySymbol = (_a = wlt.CURRENCIES_MAP.get(name)) === null || _a === void 0 ? void 0 : _a.symbol;
            isLimitReached(getCurrencyBalances(this.walletEntry, this.name));
        }
        CurrencyAddressCreate.prototype.getCurrencies = function (account) {
            var currencies = getStore().get(account);
            return currencies || [];
        };
        CurrencyAddressCreate.prototype.registerCurrency = function (account, currency) {
            var currencies = this.getCurrencies(account);
            if (currencies.indexOf(currency) > -1)
                return;
            currencies.push(currency);
            getStore().put(account, currencies.filter(distinctValues));
        };
        CurrencyAddressCreate.prototype.removeIsDeleted = function (entry) {
            var currencySymbol = entry.symbol;
            var account = entry.walletEntry.account;
            var walletType = getCryptoAddresses(entry.walletEntry, currencySymbol);
            walletType.addresses.forEach(function (walletAddress) {
                if (walletAddress.address === entry.address)
                    delete walletAddress['isDeleted'];
            });
            saveCryptoAddresses(entry.walletEntry, currencySymbol, walletType);
        };
        CurrencyAddressCreate.prototype.createAddressByName = function () {
            var walletEntry = this.findWalletEntry(this);
            if (this.name == "Bitcoin")
                return this.createBtcAddress(walletEntry);
            if (this.name == "Ethereum")
                return this.createEthAddress(walletEntry);
            if (this.name == "FIMK")
                return this.createFIMKAddress(walletEntry);
            if (this.name == "NXT")
                return this.createNXTAddress(walletEntry);
            if (this.name == "ARDOR")
                return this.createARDRAddress(walletEntry);
            if (this.name == "Litecoin")
                return this.createLtcAddress(walletEntry);
            if (this.name == "BitcoinCash")
                return this.createBchAddress(walletEntry);
        };
        CurrencyAddressCreate.prototype.findWalletEntry = function (entry) {
            while (entry && !entry.isWalletEntry) {
                entry = entry.walletEntry || entry.parent;
            }
            return (entry === null || entry === void 0 ? void 0 : entry.isWalletEntry) ? entry : null;
        };
        CurrencyAddressCreate.prototype.findNextAddress = function (currencySymbol, addresses, lastAddress, component, walletEntry) {
            var i = lastAddress
                ? addresses.addresses.findIndex(function (value) { return value.address == lastAddress; }) + 1
                : 0;
            if (i < addresses.addresses.length) {
                var nextAddress = addresses.addresses[i];
                if (nextAddress.isDeleted) {
                    nextAddress.isDeleted = false;
                    saveCryptoAddresses(walletEntry, currencySymbol, addresses);
                }
                return nextAddress;
            }
            return null;
        };
        CurrencyAddressCreate.prototype.createEthAddress = function (entry) {
            return this.createAddress(entry, 'Ethereum', 'ETH');
        };
        CurrencyAddressCreate.prototype.createBtcAddress = function (entry) {
            return this.createAddress(entry, 'Bitcoin', 'BTC');
        };
        CurrencyAddressCreate.prototype.createLtcAddress = function (entry) {
            return this.createAddress(entry, 'Litecoin', 'LTC');
        };
        CurrencyAddressCreate.prototype.createBchAddress = function (entry) {
            return this.createAddress(entry, 'BitcoinCash', 'BCH');
        };
        CurrencyAddressCreate.prototype.createFIMKAddress = function (entry) {
            return this.createAddress(entry, 'FIMK', 'FIM');
        };
        CurrencyAddressCreate.prototype.createNXTAddress = function (entry) {
            return this.createAddress(entry, 'NXT', 'NXT');
        };
        CurrencyAddressCreate.prototype.createARDRAddress = function (entry) {
            return this.createAddress(entry, 'ARDOR', 'ARDR');
        };
        CurrencyAddressCreate.prototype.createAddress = function (entry, currencyName, currencySymbol) {
            var _this = this;
            var component = entry.component;
            var currencies = this.walletEntry.currencies;
            var currencyBalances = getCurrencyBalances(this.walletEntry, this.name);
            if (isLimitReached(currencyBalances)) {
                component.showMessage("Limit of empty addresses is reached");
                return false;
            }
            var lastAddress = currencyBalances.length == 0
                ? null
                : currencyBalances[currencyBalances.length - 1]['address'];
            var nextAddress = this.findNextAddress(currencySymbol, this.wallet, lastAddress, component, entry);
            if (nextAddress) {
                nextAddress.isDeleted = false;
                var newCurrencyBalance = new CurrencyBalance(currencyName, currencySymbol, nextAddress.address, nextAddress.privateKey, nextAddress.index);
                newCurrencyBalance.walletEntry = component.walletEntries.find(function (c) { return c.account == _this.walletEntry.account; });
                rememberCryptoAddressCreated(this.walletEntry, currencySymbol, nextAddress.address);
                newCurrencyBalance.visible = this.walletEntry.expanded;
                var currencyAddressCreate = currencies.find(function (c) { return c['isCurrencyAddressCreate'] && c.name == _this.name; });
                var index = currencyAddressCreate
                    ? currencies.indexOf(currencyAddressCreate)
                    : currencies.indexOf(currencyBalances[currencyBalances.length - 1]);
                index = index == -1 ? currencies.length - 1 : index;
                currencies.splice(index, 0, newCurrencyBalance);
                this.registerCurrency(this.walletEntry.account, currencySymbol);
                this.flatten();
                wlt.shouldBeSaved = component.exportWallet(true);
                return true;
            }
            return false;
        };
        return CurrencyAddressCreate;
    }());
    wlt.CurrencyAddressCreate = CurrencyAddressCreate;
    function getCryptoAddresses(walletEntry, currencySymbol) {
        var result = walletEntry.getCryptoAddresses(currencySymbol);
        if (result)
            return result;
        var record = getStore('wallet-address').get("".concat(currencySymbol, "-").concat(walletEntry.account));
        var decrypted = heat.crypto.decryptMessage(record.data, record.nonce, walletEntry.account, walletEntry.secretPhrase);
        result = JSON.parse(decrypted);
        return result;
    }
    wlt.getCryptoAddresses = getCryptoAddresses;
    function saveCryptoAddresses(walletEntry, currencySymbol, addresses) {
        var encrypted = heat.crypto.encryptMessage(JSON.stringify(addresses), walletEntry.account, walletEntry.secretPhrase);
        getStore('wallet-address').put("".concat(currencySymbol, "-").concat(walletEntry.account), encrypted);
    }
    wlt.saveCryptoAddresses = saveCryptoAddresses;
    function saveFile(blob, fileName) {
        if (fileName) {
            saveAs(blob, fileName);
        }
        else {
            var version = parseInt(getStore().get("fileVersion")) || 0;
            version++;
            if (version > 99)
                version = 1;
            saveAs(blob, "heat.backup.v".concat(version, ".wallet"));
            getStore().put("fileVersion", version);
        }
        wlt.shouldBeSaved = null;
    }
    wlt.saveFile = saveFile;
})(wlt || (wlt = {}));
var wlt;
(function (wlt) {
    wlt.walletEntriesCache = new Map();
    var WalletComponentAbstract = (function () {
        function WalletComponentAbstract() {
            this.entries = [];
            this.walletEntries = [];
        }
        WalletComponentAbstract.prototype.initLocalKeyStore = function () {
            var _this = this;
            this.entries = [];
            this.walletEntries = [];
            this.localKeyStore.list().map(function (account) {
                var name = _this.localKeyStore.getName(account);
                var walletEntry = wlt.walletEntriesCache.get(account);
                if (walletEntry) {
                    walletEntry.setWalletComponent(_this);
                    walletEntry["cached"] = true;
                }
                else {
                    walletEntry = new wlt.WalletEntry(account, name, _this);
                }
                _this.walletEntries.push(walletEntry);
            });
            this.walletEntries.sort(function (a, b) {
                return a.account.localeCompare(b.account);
            });
            this.walletEntries.forEach(function (walletEntry) {
                var password = _this.localKeyStore.getPasswordForAccount(walletEntry.account);
                if (password) {
                    try {
                        var key = _this.localKeyStore.load(walletEntry.account, password);
                        if (key && !walletEntry["cached"]) {
                            walletEntry.secretPhrase = key.secretPhrase;
                            walletEntry.bip44Compatible = _this.lightwalletService.validSeed(key.secretPhrase);
                            walletEntry.unlocked = true;
                            walletEntry.pin = password;
                            walletEntry.label = key.label;
                            _this.initWalletEntry(walletEntry);
                        }
                    }
                    catch (e) {
                        console.log(e);
                    }
                }
            });
            this.flatten();
            this.fetchCryptoAddresses('BTC');
        };
        WalletComponentAbstract.prototype.fetchCryptoAddresses = function (currency) {
            var p2pContactsUtils = heat.$inject.get('contactService');
            var p2pMessaging = heat.$inject.get('P2PMessaging');
            p2pMessaging.p2pContactStore.forEach(function (key, contact) {
                console.log("fetching ".concat(currency, " of p2p contact: ").concat(contact.account));
                p2pContactsUtils.fetchCryptoAddress(contact, currency);
            });
        };
        WalletComponentAbstract.prototype.checkCreatedAddress = function (address, walletEntry, currencySymbol) {
            var result = { wasCreated: false, cachedBalance: undefined };
            var foundAddress;
            var addresses = wlt.getCryptoAddresses(walletEntry, currencySymbol);
            if (addresses) {
                foundAddress = addresses.addresses.find(function (v) { return v.address == address; });
                if (foundAddress) {
                    if (!foundAddress.hasOwnProperty("created")) {
                        var compatibleToPre = this.obsoleteCheckCreatedAddress(address, walletEntry, currencySymbol);
                        if (compatibleToPre) {
                            foundAddress.created = compatibleToPre.wasCreated;
                        }
                    }
                    result.wasCreated = foundAddress.created;
                }
            }
            return result;
        };
        WalletComponentAbstract.prototype.obsoleteCheckCreatedAddress = function (address, walletEntry, currencySymbol) {
            var a = wlt.createdAddresses[walletEntry.account];
            if (!a)
                return { wasCreated: false };
            var result = { wasCreated: a.has(address), cachedBalance: null };
            if (address.startsWith("bitcoincash:")) {
                result.cachedBalance = a.get(address) || a.get(address.split(":")[1]);
            }
            else {
                result.cachedBalance = a.get(address);
            }
            return result;
        };
        WalletComponentAbstract.prototype.loadNXTAddresses = function (walletEntry) {
            var createBalance = function (address) {
                var nxtCurrencyBalance = new wlt.CurrencyBalance('NXT', 'NXT', address.address, address.privateKey);
                nxtCurrencyBalance.balance = address.balance ? address.balance + "" : "0";
                if (address.tokensBalances) {
                    address.tokensBalances.forEach(function (balance) {
                        var tokenBalance = new wlt.TokenBalance(balance.name, balance.symbol, balance.address);
                        tokenBalance.balance = utils.commaFormat(balance.balance);
                        tokenBalance.visible = walletEntry.expanded;
                        nxtCurrencyBalance.tokens.push(tokenBalance);
                    });
                }
                return nxtCurrencyBalance;
            };
            this.loadAddresses(walletEntry, wlt.CURRENCIES.NXT, this.nxtCryptoService.refreshBalances, createBalance);
        };
        WalletComponentAbstract.prototype.loadARDORAddresses = function (walletEntry) {
            var createBalance = function (address) {
                var ardrCurrencyBalance = new wlt.CurrencyBalance('ARDOR', 'ARDR', address.address, address.privateKey);
                ardrCurrencyBalance.balance = address.balance ? address.balance + "" : "0";
                if (address.tokensBalances) {
                    address.tokensBalances.forEach(function (balance) {
                        var tokenBalance = new wlt.TokenBalance(balance.name, balance.symbol, balance.address);
                        tokenBalance.balance = utils.commaFormat(balance.balance);
                        tokenBalance.visible = walletEntry.expanded;
                        ardrCurrencyBalance.tokens.push(tokenBalance);
                    });
                }
                return ardrCurrencyBalance;
            };
            this.loadAddresses(walletEntry, wlt.CURRENCIES.ARDOR, this.ardorCryptoService.refreshBalances, createBalance);
        };
        WalletComponentAbstract.prototype.loadFIMKAddresses = function (walletEntry) {
            var createBalance = function (address) {
                var fimkCurrencyBalance = new wlt.CurrencyBalance('FIMK', 'FIM', address.address, address.privateKey);
                fimkCurrencyBalance.balance = address.balance ? address.balance + "" : "0";
                if (address.tokensBalances) {
                    address.tokensBalances.forEach(function (balance) {
                        var tokenBalance = new wlt.TokenBalance(balance.name, balance.symbol, balance.address);
                        tokenBalance.balance = utils.commaFormat(balance.balance);
                        tokenBalance.visible = walletEntry.expanded;
                        fimkCurrencyBalance.tokens.push(tokenBalance);
                    });
                }
                return fimkCurrencyBalance;
            };
            this.loadAddresses(walletEntry, wlt.CURRENCIES.FIMK, this.fimkCryptoService.refreshBalances, createBalance);
        };
        WalletComponentAbstract.prototype.loadEthereumAddresses = function (walletEntry) {
            var createBalance = function (address) {
                var ethCurrencyBalance = new wlt.CurrencyBalance('Ethereum', 'ETH', address.address, address.privateKey, address.index);
                if (address.balance) {
                    ethCurrencyBalance.balance = Big(address.balance).toFixed();
                }
                if (address.tokensBalances) {
                    address.tokensBalances.forEach(function (balance) {
                        var tokenBalance = new wlt.TokenBalance(balance.name, balance.symbol, balance.address);
                        tokenBalance.balance = balance.balance;
                        tokenBalance.visible = walletEntry.expanded;
                        ethCurrencyBalance.tokens.push(tokenBalance);
                    });
                }
                return ethCurrencyBalance;
            };
            this.loadAddresses(walletEntry, wlt.CURRENCIES.Ethereum, this.lightwalletService.refreshBalances, createBalance);
        };
        WalletComponentAbstract.prototype.loadIotaAddresses = function (walletEntry) {
            var createBalance = function (address) {
                var iotaCurrencyBalance = new wlt.CurrencyBalance('Iota', 'i', address.address, address.privateKey);
                iotaCurrencyBalance.balance = Number(address.balance + "").toFixed(0);
                return iotaCurrencyBalance;
            };
            this.loadAddresses(walletEntry, wlt.CURRENCIES.IOTA, this.iotaCoreService.refreshBalances, createBalance);
        };
        WalletComponentAbstract.prototype.loadBitcoinAddresses = function (walletEntry) {
            var createBalance = function (address) {
                var btcCurrencyBalance = new wlt.CurrencyBalance('Bitcoin', 'BTC', address.address, address.privateKey, address.index);
                btcCurrencyBalance.balance = address.balance ? new Big(address.balance).times(new Big(100000000)).toString() : "";
                btcCurrencyBalance.formatBalance = function (balance) {
                    if (balance) {
                        return new Big(balance).div(wlt.SATOSHI_PER_BTC).toString();
                    }
                    return balance;
                };
                return btcCurrencyBalance;
            };
            this.loadAddresses(walletEntry, wlt.CURRENCIES.Bitcoin, this.bitcoreService.refreshBalances, createBalance);
        };
        WalletComponentAbstract.prototype.loadBitcoinCashAddresses = function (walletEntry) {
            var createBalance = function (address) {
                var bchCurrencyBalance = new wlt.CurrencyBalance('BitcoinCash', 'BCH', address.address, address.privateKey, address.index);
                bchCurrencyBalance.balance = address.balance + "";
                return bchCurrencyBalance;
            };
            this.loadAddresses(walletEntry, wlt.CURRENCIES.BitcoinCash, this.bchCryptoService.refreshBalances, createBalance);
        };
        WalletComponentAbstract.prototype.loadLtcAddresses = function (walletEntry) {
            var createBalance = function (address) {
                var ltcCurrencyBalance = new wlt.CurrencyBalance('Litecoin', 'LTC', address.address, address.privateKey, address.index);
                ltcCurrencyBalance.balance = address.balance + "";
                return ltcCurrencyBalance;
            };
            this.loadAddresses(walletEntry, wlt.CURRENCIES.Litecoin, this.ltcCryptoService.refreshBalances, createBalance);
        };
        WalletComponentAbstract.prototype.loadAddresses = function (walletEntry, currencyDescriptor, requestAddresses, createBalance) {
            var _this = this;
            var _a;
            var addressLoading = walletEntry.findAddressLoading(currencyDescriptor.symbol);
            if (!addressLoading)
                return;
            var cryptoAddresses = (_a = walletEntry.getCryptoAddresses(currencyDescriptor.symbol)) === null || _a === void 0 ? void 0 : _a.addresses;
            if (!cryptoAddresses || cryptoAddresses.length == 0)
                return;
            var ca = wlt.createdAddresses[walletEntry.account];
            var upgraded = false;
            if ((ca === null || ca === void 0 ? void 0 : ca.size) > 0) {
                cryptoAddresses.forEach(function (a) {
                    var hashedAddr = wlt.HASH_PREFIX + heat.crypto.hash(a.address);
                    if (ca.has(hashedAddr)) {
                        a.created = true;
                        upgraded = true;
                        ca.delete(hashedAddr);
                        window.localStorage.removeItem("addresscreated-".concat(walletEntry.account, "-").concat(hashedAddr));
                    }
                });
            }
            if (upgraded) {
                wlt.saveCryptoAddresses(walletEntry, currencyDescriptor.symbol, walletEntry.getCryptoAddresses(currencyDescriptor.symbol));
            }
            var actualWalletAddresses = {
                addresses: cryptoAddresses.filter(function (a) {
                    if (a.isDeleted)
                        return false;
                    var info = _this.checkCreatedAddress(a.address, walletEntry, currencyDescriptor.symbol);
                    return a.inUse || info.wasCreated || !currencyDescriptor.multiAddress;
                })
            };
            if (actualWalletAddresses.addresses.length == 0) {
                addressLoading.visible = false;
                return;
            }
            utils.timeoutPromise(requestAddresses(actualWalletAddresses, addressLoading), 8000).then(function (success) {
                _this.createBalanceEntries(walletEntry, addressLoading, actualWalletAddresses, createBalance, success || success == null);
            }).catch(function (reason) {
                _this.createBalanceEntries(walletEntry, addressLoading, actualWalletAddresses, createBalance, false);
                _this.showMessage("Error. Cannot connect to ".concat(currencyDescriptor.symbol, " server."));
            });
        };
        WalletComponentAbstract.prototype.createBalanceEntries = function (walletEntry, addressLoading, actualWalletAddresses, createBalance, successLoaded) {
            var _this = this;
            if (!walletEntry.currencies.find(function (c) { return c['isCurrencyAddressLoading']; }))
                return;
            var index = walletEntry.currencies.indexOf(addressLoading);
            var counter = 0;
            actualWalletAddresses.addresses.forEach(function (address) {
                var createdAddress = _this.checkCreatedAddress(address.address, walletEntry, addressLoading.currencySymbol);
                if (counter >= wlt.DISPLAYED_MAX_EMPTY_ADDRESSES && !address.inUse)
                    return;
                var currencyBalance = createBalance(address);
                currencyBalance.visible = walletEntry.expanded;
                currencyBalance.inUse = !createdAddress.wasCreated;
                currencyBalance.walletEntry = walletEntry;
                if (successLoaded) {
                    if (createdAddress.wasCreated && currencyBalance.balance && /[0-9]/.test(currencyBalance.balance)) {
                    }
                }
                else {
                    currencyBalance.stateMessage = "No Connection" + (currencyBalance.balance ? ". Cached value" : "");
                }
                walletEntry.currencies.splice(index, 0, currencyBalance);
                index++;
                if (!currencyBalance.balance)
                    counter++;
            });
            walletEntry.currencies = walletEntry.currencies.filter(function (c) { return c != addressLoading; });
            this.flatten();
        };
        return WalletComponentAbstract;
    }());
    wlt.WalletComponentAbstract = WalletComponentAbstract;
})(wlt || (wlt = {}));
var WalletComponent = (function (_super) {
    __extends(WalletComponent, _super);
    function WalletComponent($scope, $q, localKeyStore, walletFile, $window, lightwalletService, heat, assetInfo, ethplorer, $mdToast, $mdDialog, clipboard, user, bitcoreService, fimkCryptoService, nxtCryptoService, ardorCryptoService, ltcCryptoService, ltcBlockExplorerService, bchCryptoService, bchBlockExplorerService, nxtBlockExplorerService, ardorBlockExplorerService, mofoSocketService, iotaCoreService, storage, $rootScope) {
        var _this = _super.call(this) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.walletFile = walletFile;
        _this.$window = $window;
        _this.heat = heat;
        _this.assetInfo = assetInfo;
        _this.ethplorer = ethplorer;
        _this.$mdToast = $mdToast;
        _this.$mdDialog = $mdDialog;
        _this.clipboard = clipboard;
        _this.user = user;
        _this.mofoSocketService = mofoSocketService;
        _this.storage = storage;
        _this.$rootScope = $rootScope;
        _this.selectAll = true;
        _this.allLocked = true;
        _this.displayUnlocked = false;
        _this.chains = [{ name: 'HEAT', disabled: false }, { name: 'ETH', disabled: false }, { name: 'BTC', disabled: false },
            { name: 'FIMK', disabled: false }, { name: 'NXT', disabled: true }, { name: 'ARDR', disabled: true },
            { name: 'IOTA', disabled: false }, { name: 'LTC', disabled: false }, { name: 'BCH', disabled: false }];
        _this.selectedChain = '';
        _this.localKeyStore = localKeyStore;
        _this.iotaCoreService = iotaCoreService;
        _this.lightwalletService = lightwalletService;
        _this.fimkCryptoService = fimkCryptoService;
        _this.ardorBlockExplorerService = ardorBlockExplorerService;
        _this.nxtBlockExplorerService = nxtBlockExplorerService;
        _this.bchBlockExplorerService = bchBlockExplorerService;
        _this.bchCryptoService = bchCryptoService;
        _this.ltcBlockExplorerService = ltcBlockExplorerService;
        _this.ltcCryptoService = ltcCryptoService;
        _this.ardorCryptoService = ardorCryptoService;
        _this.nxtCryptoService = nxtCryptoService;
        _this.bitcoreService = bitcoreService;
        WalletComponent_1.instance = _this;
        _this.store = wlt.getStore();
        _this.displayUnlocked = WalletComponent_1.displayUnlocked;
        $scope.$on('$destroy', function () { return WalletComponent_1.displayUnlocked = _this.displayUnlocked; });
        nxtBlockExplorerService.getBlockchainStatus().then(function () {
            var nxtChain = { name: 'NXT', disabled: false };
            var index = _this.chains.findIndex(function (entry) { return entry.name === nxtChain.name; });
            _this.chains[index] = nxtChain;
        });
        ardorBlockExplorerService.getBlockchainStatus().then(function () {
            var ardorChain = { name: 'ARDR', disabled: false };
            var index = _this.chains.findIndex(function (entry) { return entry.name === ardorChain.name; });
            _this.chains[index] = ardorChain;
        });
        _this.initLocalKeyStore();
        wlt.initCreatedAddresses();
        return _this;
    }
    WalletComponent_1 = WalletComponent;
    WalletComponent.prototype.enterEntryLabel = function (entry) {
        var _this = this;
        var p = [
            { label: "Visible label", value: entry.visibleLabel },
            { label: "Invisible label until login", value: entry.label }
        ];
        dialogs.simplePrompt(null, 'Enter Label', "Enter label for account ".concat(entry.identifier, " or enter empty value to delete the label"), p).then(function (labels) {
            var _a, _b;
            entry.visibleLabel = (_a = labels[0]) === null || _a === void 0 ? void 0 : _a.trim();
            wlt.updateEntryVisibleLabel(entry.account, entry.visibleLabel);
            entry.label = (_b = labels[1]) === null || _b === void 0 ? void 0 : _b.trim();
            var password = _this.localKeyStore.getPasswordForAccount(entry.account);
            if (password) {
                try {
                    var key = _this.localKeyStore.load(entry.account, password);
                    if (key) {
                        key.label = entry.label || null;
                        _this.localKeyStore.put(key);
                    }
                }
                catch (e) {
                    console.error(e);
                }
            }
        });
    };
    WalletComponent.prototype.showSecret = function (secret, currencySymbol) {
        this.clipboard.showSecret(secret, currencySymbol);
    };
    WalletComponent.prototype.deleteEntry = function (entry) {
        var _this = this;
        if (!entry.address || !entry.walletEntry)
            return;
        var removingAddress = entry.address;
        dialogs.confirm("Remove ".concat(entry.symbol, " Address"), "This will remove ".concat(entry.symbol, " ").concat(removingAddress, " from your device.\n      Please make sure you have saved the private key or you will lose access to the address.")).then(function () {
            if (!entry.walletEntry)
                return;
            var walletEntry = entry.walletEntry;
            walletEntry.currencies = walletEntry.currencies
                .filter(function (currency) { return !(currency instanceof wlt.CurrencyBalance && removingAddress == currency.address); });
            var currencySymbol = entry.symbol;
            var walletType = wlt.getCryptoAddresses(walletEntry, currencySymbol);
            var addressToDelete;
            if (['FIM',].indexOf(entry.symbol) !== -1) {
                addressToDelete = walletType.addresses[0];
            }
            else {
                var address = walletType.addresses.find(function (address) { return address.address == removingAddress; });
                if (address)
                    addressToDelete = address;
            }
            if (addressToDelete) {
                addressToDelete.isDeleted = true;
                wlt.saveCryptoAddresses(walletEntry, currencySymbol, walletType);
            }
            _this.flatten();
        });
    };
    WalletComponent.prototype.restoreAddresses = function (walletEntry, currencyName) {
        var _this = this;
        dialogs.confirm("Restore ".concat(currencyName, " Addresses"), "This will try to restore removed addresses")
            .then(function () {
            var resetAddressesPromise;
            if (currencyName === 'Ethereum') {
                resetAddressesPromise = _this.lightwalletService.unlock(walletEntry.secretPhrase, "");
            }
            else if (currencyName === 'Bitcoin') {
                resetAddressesPromise = _this.bitcoreService.unlock(walletEntry.secretPhrase);
            }
            else if (currencyName === 'FIMK') {
            }
            else if (currencyName === 'NXT') {
            }
            else if (currencyName === 'ARDOR') {
            }
            else if (currencyName === 'IOTA') {
            }
            else if (currencyName === 'Litecoin') {
                resetAddressesPromise = _this.ltcCryptoService.unlock(walletEntry.secretPhrase);
            }
            else if (currencyName === 'BitcoinCash') {
                resetAddressesPromise = _this.bchCryptoService.unlock(walletEntry.secretPhrase);
            }
            else if (currencyName === 'HEAT') {
            }
            if (resetAddressesPromise) {
                resetAddressesPromise.then(function (cryptoAddresses) {
                    var forceWasCreated = true;
                    cryptoAddresses.addresses.forEach(function (a) {
                        if (a.created)
                            forceWasCreated = false;
                        if (forceWasCreated)
                            a.created = true;
                        a.isDeleted = false;
                    });
                    wlt.saveCryptoAddresses(walletEntry, wlt.CURRENCIES_MAP.get(currencyName).symbol, cryptoAddresses);
                    walletEntry.currencies = [];
                    _this.initWalletEntry(walletEntry);
                    walletEntry.toggle();
                }, function (reason) {
                    console.warn("Currency ".concat(currencyName, " is not reset: ") + reason);
                });
            }
        });
    };
    WalletComponent.prototype.getSelectedCurrencies = function (walletEntry) {
        var selectedCurrencies = this.store.get(walletEntry.account) || [];
        return selectedCurrencies;
    };
    WalletComponent.prototype.createAddress = function (walletEntry, currencyName) {
        var node = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == currencyName; });
        var success;
        if (currencyName == "Bitcoin")
            success = node.createBtcAddress(walletEntry);
        if (currencyName == "Ethereum")
            success = node.createEthAddress(walletEntry);
        if (currencyName == "FIMK")
            success = node.createFIMKAddress(walletEntry);
        if (currencyName == "NXT")
            success = node.createNXTAddress(walletEntry);
        if (currencyName == "ARDOR")
            success = node.createARDRAddress(walletEntry);
        if (currencyName == "Litecoin")
            success = node.createLtcAddress(walletEntry);
        if (currencyName == "BitcoinCash")
            success = node.createBchAddress(walletEntry);
        walletEntry.toggle(true);
    };
    WalletComponent.prototype.createAccount = function ($event) {
        var selected = this.$scope['vm'].selectedChain;
        if (selected === 'ETH') {
            createEthAccount($event, this);
        }
        else if (selected === 'BTC') {
            createBtcAccount($event, this);
        }
        else if (selected === 'FIMK') {
            createFIMKAccount($event, this);
        }
        else if (selected === 'NXT') {
            createNXTAccount($event, this);
        }
        else if (selected === 'ARDR') {
            createARDRAccount($event, this);
        }
        else if (selected === 'IOTA') {
            createIotaAccount($event, this);
        }
        else if (selected === 'LTC') {
            createLtcAccount($event, this);
        }
        else if (selected === 'BCH') {
            createBCHAccount($event, this);
        }
        else if (selected === 'HEAT') {
            createHEATAccount($event, this);
            wlt.shouldBeSaved = this.exportWallet(true);
        }
        this.$scope['vm'].selectedChain = null;
    };
    WalletComponent.prototype.flatten = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.entries = [];
            _this.walletEntries.forEach(function (walletEntry) {
                _this.entries.push(walletEntry);
                walletEntry.currencies = walletEntry.currencies.filter(function (currency, index, self) {
                    if (!currency.hasOwnProperty('address') && (currency.hasOwnProperty('isCurrencyAddressCreate') || currency.hasOwnProperty('isCurrencyAddressLoading'))) {
                        return true;
                    }
                    return index === self.findIndex(function (t) { return (t.name === currency.name && t.address === currency.address); });
                });
                walletEntry.currencies.forEach(function (curr) {
                    var currencyBalance = curr;
                    _this.entries.push(currencyBalance);
                    if (currencyBalance.tokens) {
                        currencyBalance.tokens.forEach(function (tokenBalance) {
                            _this.entries.push(tokenBalance);
                        });
                    }
                });
            });
        });
    };
    WalletComponent.prototype.shareCurrencyAddressesWithP2pContacts = function (currency, address) {
        var p2pContactsUtils = heat.$inject.get('contactService');
        var p2pMessaging = heat.$inject.get('P2PMessaging');
        p2pMessaging.p2pContactStore.forEach(function (key, contact) {
            console.log("sharing key ".concat(address, " of currency ").concat(currency, " with p2p contact: ").concat(contact.account));
            p2pContactsUtils.shareCryptoAddress(contact, currency, address);
        });
    };
    WalletComponent.prototype.showMessage = function (message) {
        this.$mdToast.show(this.$mdToast.simple().textContent(message).hideDelay(5000));
    };
    WalletComponent.prototype.pageAddAddSecretPhrase = function ($event) {
        var _this = this;
        promptSecretPlusPassword($event, this).then(function (data) {
            var account = heat.crypto.getAccountId(data.secretPhrase);
            var publicKey = heat.crypto.secretPhraseToPublicKey(data.secretPhrase);
            var key = {
                account: account,
                secretPhrase: data.secretPhrase,
                pincode: data.password,
                name: '',
                publicKey: publicKey
            };
            _this.localKeyStore.put(key);
            _this.$scope.$evalAsync(function () {
                _this.initLocalKeyStore();
            });
        });
    };
    WalletComponent.prototype.pageAddFileInputChange = function (files) {
        var _this = this;
        if (files && files[0]) {
            var reader_2 = new FileReader();
            reader_2.onload = function () {
                _this.$scope.$evalAsync(function () {
                    var fileContents = reader_2.result;
                    var data = _this.walletFile.parseJSON(fileContents);
                    var resultMessage = "Nothing imported";
                    if (data && data["heatwallet-raw-data"]) {
                        resultMessage = _this.walletFile.importRawData(data);
                        resultMessage += ".  The app will now restart...";
                        setTimeout(function () { return window.location.reload(); }, 4000);
                    }
                    else {
                        var wallet = _this.walletFile.createFromText(data);
                        if (wallet) {
                            var addedKeys = _this.localKeyStore.import(wallet);
                            _this.$scope.$evalAsync(function () {
                                _this.initLocalKeyStore();
                                wlt.initCreatedAddresses();
                            });
                            var isBig = addedKeys.length > 8;
                            var report = (isBig ? addedKeys.filter(function (value, index) { return index < 7; }) : addedKeys)
                                .map(function (v) { return v.account + (v.name ? "[" + v.name + "]" : ""); })
                                .join(", ");
                            if (isBig)
                                report = report + "\n...";
                            resultMessage = "Imported ".concat(addedKeys.length, " keys into this device: \n ").concat(report);
                        }
                    }
                    _this.$mdToast.show(_this.$mdToast.simple().textContent(resultMessage).hideDelay(7000));
                });
            };
            reader_2.readAsText(files[0]);
        }
    };
    WalletComponent.prototype.remove = function ($event, entry) {
        var _this = this;
        dialogs.prompt($event, 'Remove Wallet Entry', "This completely removes the wallet entry from your device.\n       Please enter your Password (or Pin Code) to confirm you wish to remove this entry", '').then(function (pin) {
            if (pin == entry.pin) {
                _this.localKeyStore.remove(entry.account);
                _this.initLocalKeyStore();
                if (entry.account === _this.user.account) {
                    _this.heat.api.getKeystoreEntryCountByAccount(entry.account).then(function (count) {
                        if (count > 0) {
                            _this.shareCurrencyAddressesWithP2pContacts('BTC', '');
                        }
                    });
                }
            }
            else {
                _this.$mdToast.show(_this.$mdToast.simple().textContent('Incorrect Password (or Pin Code). Wallet Entry not removed.').hideDelay(5000));
            }
        });
    };
    WalletComponent.prototype.unlock = function ($event, selectedWalletEntry) {
        var _this = this;
        dialogs.prompt($event, 'Enter Password (or Pin)', 'Please enter your Password (or Pin Code) to unlock', '').then(function (pin) {
            var count = 0;
            _this.walletEntries.forEach(function (walletEntry) {
                if (!walletEntry.secretPhrase) {
                    var key = _this.localKeyStore.load(walletEntry.account, pin);
                    if (key) {
                        count += 1;
                        _this.localKeyStore.rememberPassword(walletEntry.account, pin);
                        walletEntry.pin = pin;
                        walletEntry.secretPhrase = key.secretPhrase;
                        walletEntry.bip44Compatible = _this.lightwalletService.validSeed(key.secretPhrase);
                        walletEntry.label = key.label;
                        walletEntry.unlocked = true;
                        wlt.walletEntriesCache.set(walletEntry.account, walletEntry);
                        _this.initWalletEntry(walletEntry);
                    }
                }
            });
            var message = "Unlocked ".concat(count ? count : 'NO', " entries");
            _this.$mdToast.show(_this.$mdToast.simple().textContent(message).hideDelay(5000));
            selectedWalletEntry === null || selectedWalletEntry === void 0 ? void 0 : selectedWalletEntry.toggle(true);
            if (!_this.user.unlocked) {
                if (selectedWalletEntry === null || selectedWalletEntry === void 0 ? void 0 : selectedWalletEntry.unlocked) {
                    for (var i = 0; i < selectedWalletEntry.currencies.length; i++) {
                        var balance = selectedWalletEntry.currencies[i];
                        if (balance.isCurrencyBalance) {
                            balance.unlock(true);
                            return;
                        }
                    }
                }
                for (var i = 0; i < _this.entries.length; i++) {
                    var entry = _this.entries[i];
                    if (entry.unlocked) {
                        for (var k = 0; k < entry.currencies.length; k++) {
                            var balance = entry.currencies[k];
                            if (balance.isCurrencyBalance) {
                                balance.unlock(true);
                                return;
                            }
                        }
                    }
                }
            }
        });
    };
    WalletComponent.prototype.initWalletEntry = function (walletEntry) {
        var _this = this;
        this.allLocked = false;
        var heatAccount = heat.crypto.getAccountIdFromPublicKey(heat.crypto.secretPhraseToPublicKey(walletEntry.secretPhrase));
        var heatCurrencyBalance = new wlt.CurrencyBalance('HEAT', 'HEAT', heatAccount, walletEntry.secretPhrase);
        heatCurrencyBalance.walletEntry = walletEntry;
        heatCurrencyBalance.visible = walletEntry.expanded;
        heatCurrencyBalance.pubKey = heat.crypto.secretPhraseToPublicKey(walletEntry.secretPhrase);
        walletEntry.currencies.push(heatCurrencyBalance);
        this.flatten();
        this.heat.api.getAccountByNumericId(heatAccount).then(function (account) {
            _this.$scope.$evalAsync(function () {
                heatCurrencyBalance.balance = utils.formatQNT(account.unconfirmedBalance, 8);
            });
            _this.getAccountAssets(heatAccount).then(function (assetInfos) {
                heatCurrencyBalance.tokens = [];
                assetInfos.forEach(function (assetInfo) {
                    var tokenBalance = new wlt.TokenBalance(assetInfo.name, assetInfo.symbol, assetInfo.id);
                    tokenBalance.balance = utils.formatQNT(assetInfo.userBalance, assetInfo.decimals);
                    tokenBalance.visible = walletEntry.expanded;
                    heatCurrencyBalance.tokens.push(tokenBalance);
                });
                _this.flatten();
            });
        }, function () {
            _this.$scope.$evalAsync(function () {
                heatCurrencyBalance.balance = "Address is unused";
            });
        });
        var selectedCurrencies = this.store.get(walletEntry.account) || [];
        if (selectedCurrencies.indexOf('BTC') > -1)
            this.bitcoreService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                if (wallet !== undefined) {
                    walletEntry.initBTC(_this, wallet, _this.user);
                }
            }).catch(function (reason) { console.log(reason); });
        if (selectedCurrencies.indexOf('ETH') > -1)
            this.lightwalletService.unlock(walletEntry.secretPhrase, "").then(function (wallet) {
                walletEntry.initEth(_this, wallet);
            }).catch(function (reason) { console.log(reason); });
        if (selectedCurrencies.indexOf('IOTA') > -1)
            this.iotaCoreService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                walletEntry.initIota(_this, wallet);
            }).catch(function (reason) { console.log(reason); });
        if (selectedCurrencies.indexOf('FIM') > -1)
            this.fimkCryptoService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                walletEntry.initFIMK(_this, wallet);
            }).catch(function (reason) { console.log(reason); });
        if (selectedCurrencies.indexOf('NXT') > -1)
            this.nxtCryptoService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                walletEntry.initNXT(_this, wallet);
            }).catch(function (reason) { console.log(reason); });
        if (selectedCurrencies.indexOf('ARDR') > -1)
            this.ardorCryptoService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                walletEntry.initARDOR(_this, wallet);
            }).catch(function (reason) { console.log(reason); });
        if (selectedCurrencies.indexOf('LTC') > -1)
            this.ltcCryptoService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                if (wallet !== undefined) {
                    walletEntry.initLTC(_this, wallet);
                }
            }).catch(function (reason) { console.log(reason); });
        if (selectedCurrencies.indexOf('BCH') > -1)
            this.bchCryptoService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                if (wallet !== undefined) {
                    walletEntry.initBCH(_this, wallet);
                }
            }).catch(function (reason) { console.log(reason); });
    };
    WalletComponent.prototype.getAccountAssets = function (account) {
        var _this = this;
        var deferred = this.$q.defer();
        this.heat.api.getAccountBalances(account, "0", 1, 0, 100).then(function (balances) {
            var assetInfos = [];
            var promises = [];
            balances.forEach(function (balance) {
                if (balance.id != '0') {
                    promises.push(_this.assetInfo.getInfo(balance.id).then(function (info) {
                        assetInfos.push(angular.extend({}, info, {
                            userBalance: balance.virtualBalance
                        }));
                    }));
                }
            });
            if (promises.length > 0) {
                _this.$q.all(promises).then(function () {
                    assetInfos.sort(function (a, b) {
                        var textA = a.symbol.toUpperCase();
                        var textB = b.symbol.toUpperCase();
                        return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;
                    });
                    var zero = new Big(0);
                    assetInfos = assetInfos.filter(function (v) { return !new Big(v.userBalance || 0).eq(zero); });
                    deferred.resolve(assetInfos);
                }, deferred.reject);
            }
            else {
                deferred.resolve([]);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    WalletComponent.prototype.importSeed = function ($event) {
        var _this = this;
        promptSecretPlusPassword($event, this).then(function (data) {
            var account = heat.crypto.getAccountId(data.secretPhrase);
            var publicKey = heat.crypto.secretPhraseToPublicKey(data.secretPhrase);
            var key = {
                account: account,
                secretPhrase: data.secretPhrase,
                pincode: data.password,
                name: '',
                publicKey: publicKey
            };
            _this.localKeyStore.put(key);
            var message = "Seed was successfully imported under HEAT account ".concat(account);
            _this.$mdToast.show(_this.$mdToast.simple().textContent(message).hideDelay(5000));
            _this.user.unlock(data.secretPhrase, key, _this.lightwalletService.validSeed(data.secretPhrase))
                .then(function () { return heat.fullApplicationScopeReload(); });
        });
    };
    WalletComponent.prototype.exportWallet = function (onlyData) {
        var _this = this;
        var accountCurrencies = new Map();
        this.entries.forEach(function (entry) {
            if (entry instanceof wlt.WalletEntry) {
                var currencies = _this.store.get(entry.account);
                if (currencies)
                    accountCurrencies.set(entry.account, currencies);
            }
        });
        var accountAddressesArray = Object.entries(wlt.createdAddresses);
        var accountAddresses = accountAddressesArray
            .map(function (item) { return [item[0], Array.from(item[1])]; })
            .filter(function (v) { var _a; return ((_a = v[1]) === null || _a === void 0 ? void 0 : _a.length) > 0; });
        var exported = this.localKeyStore.export(accountCurrencies, accountAddresses);
        var paymentMessages = wlt.exportPaymentMessages();
        exported = Object.assign(exported, { paymentMessages: paymentMessages });
        var encoded = this.walletFile.encode(exported);
        var blob = new Blob([encoded], { type: "text/plain;charset=utf-8" });
        if (onlyData)
            return blob;
        wlt.saveFile(blob, "heat.wallet");
    };
    var WalletComponent_1;
    WalletComponent.displayUnlocked = false;
    WalletComponent = WalletComponent_1 = __decorate([
        RouteConfig('/wallet'),
        Component({
            selector: 'wallet',
            template: "\n   <!--  layout-align=\"start center\" -->\n    <div layout=\"column\"  flex layout-padding>\n      <div layout=\"row\">\n\n        <!-- Open File input is hidden -->\n        <md-button class=\"md-primary md-raised\">\n          <md-tooltip md-direction=\"bottom\">Open wallet file, adds all contents</md-tooltip>\n          <label for=\"walet-input-file\">\n            Import File\n          </label>\n        </md-button>\n        \n        <input type=\"file\" onchange=\"angular.element(this).scope().vm.pageAddFileInputChange(this.files); angular.element(this).val(null)\" class=\"ng-hide\" id=\"walet-input-file\">\n\n        <!-- Adds a wallet seed (heat secret phrase or bip44 eth/btc seed) -->\n        <md-button class=\"md-primary md-raised\" ng-click=\"vm.importSeed()\" aria-label=\"Import Seed\">\n          <md-tooltip md-direction=\"bottom\">Import Seed</md-tooltip>\n          Import Seed/Private Key\n        </md-button>\n\n        <!-- Export Wallet to File -->\n        <md-button class=\"md-warn md-raised\" ng-click=\"vm.exportWallet()\" aria-label=\"Export Wallet\" ng-if=\"!vm.allLocked\">\n          <md-tooltip md-direction=\"bottom\">Export Wallet File</md-tooltip>\n          Export Wallet File\n        </md-button>\n\n        <md-select class=\"wallet-dropdown md-warn md-raised\" placeholder=\"Create Address\" ng-change=\"vm.createAccount($event)\" ng-model=\"vm.selectedChain\">\n          <md-option style=\"height: 30px;\"ng-repeat=\"entry in vm.chains\" value=\"{{entry.name}}\" ng-disabled=\"{{entry.disabled}}\">{{entry.name}}</md-option>\n        </md-select>\n        \n        <md-checkbox ng-model=\"vm.displayUnlocked\" style=\"margin: 8px 26px 0 auto;\">\n          Display unlocked only\n        </md-checkbox>\n        \n        <md-button ng-click=\"vm.unlock($event)\" class=\"md-primary md-raised\" aria-label=\"Unlock account\">\n          Unlock\n        </md-button>\n      </div>\n\n      <div layout=\"column\" layout-fill  flex>\n        <div layout-fill layout=\"column\" class=\"wallet-entries\" flex>\n\n          <!-- Build a wallet structure that contains ::\n                - wallet entries\n                - per entry currency balances\n                - per currency token balances  -->\n\n          <md-list layout-fill layout=\"column\" flex>\n            <md-list-item ng-repeat=\"entry in vm.entries\" ng-if=\"entry.visible && !entry.hidden\" ng-hide=\"entry.isWalletEntry && !entry.unlocked && vm.displayUnlocked\">\n\n              <!-- Wallet entry -->\n              <div ng-if=\"entry.isWalletEntry\" layout=\"row\" class=\"wallet-entry\" flex>\n                <!--\n                <md-checkbox ng-model=\"entry.selected\">\n                  <md-tooltip md-direction=\"bottom\">\n                    Check this to include in wallet export\n                  </md-tooltip>\n                </md-checkbox>\n                -->\n                <md-button class=\"md-icon-button left\" ng-click=\"entry.toggle()\">\n                  <md-icon md-font-library=\"material-icons\">{{entry.expanded?'expand_less':'expand_more'}}</md-icon>\n                </md-button>\n\n                <div flex ng-if=\"entry.secretPhrase\" class=\"identifier\"><a ng-click=\"entry.toggle()\">{{entry.identifier}}</a>\n                  <span class=\"visibleLabel\">{{entry.visibleLabel}}</span>\n                  <span class=\"label\">{{entry.label}}</span>\n                </div>\n                <div flex ng-if=\"!entry.secretPhrase\" class=\"identifier\">\n                  <span>{{entry.identifier}}</span>\n                  <span class=\"visibleLabel\">{{entry.visibleLabel}}</span>\n                </div>\n\n                <md-menu md-position-mode=\"target-right target\" md-offset=\"34px 34px\" ng-if=\"entry.unlocked\">\n                  <md-button aria-label=\"user menu\" class=\"md-icon-button right\" ng-click=\"$mdMenu.open($event)\" md-menu-origin >\n                    <md-icon md-font-library=\"material-icons\">more_horiz</md-icon>\n                  </md-button>\n                  <md-menu-content width=\"4\">\n                    <!--<span>Account {{entry.account}}</span>-->\n                    <md-menu-item>\n                      <md-button aria-label=\"explorer\" ng-click=\"vm.enterEntryLabel(entry)\">\n                        <md-icon md-font-library=\"material-icons\">label</md-icon>\n                        Enter label\n                      </md-button>\n                    </md-menu-item>\n                    <md-menu-item>\n                      <md-button aria-label=\"explorer\" ng-click=\"vm.showSecret(entry.secretPhrase, entry.symbol)\">\n                        <md-icon md-font-library=\"material-icons\">file_copy</md-icon>\n                        Show private key\n                      </md-button>\n                    </md-menu-item>\n                    <md-menu-item>\n                      <md-button aria-label=\"explorer\" ng-click=\"vm.remove($event, entry)\">\n                        <md-icon md-font-library=\"material-icons\">delete_forever</md-icon>\n                        Remove account\n                      </md-button>\n                    </md-menu-item>\n                    \n                    <md-menu-divider></md-menu-divider>\n\n                    <md-menu-item>\n                      <md-menu>\n                          <md-button ng-click=\"$mdMenu.open()\" style=\"text-transform: none;\">\n                            <md-icon md-font-library=\"material-icons\" style=\"margin-right: 16px;\">restore</md-icon>\n                            Restore addresses\n                          </md-button>\n                          <md-menu-content>\n                            <md-menu-item>\n                              <md-button ng-click=\"vm.restoreAddresses(entry, 'Bitcoin')\">BTC</md-button>\n                            </md-menu-item>\n                            <md-menu-item>\n                              <md-button ng-click=\"vm.restoreAddresses(entry, 'Ethereum')\">ETH</md-button>\n                            </md-menu-item>\n                            <md-menu-item>\n                              <md-button ng-click=\"vm.restoreAddresses(entry, 'Litecoin')\">LTC</md-button>\n                            </md-menu-item>\n                            <md-menu-item>\n                              <md-button ng-click=\"vm.restoreAddresses(entry, 'BitcoinCash')\">BCH</md-button>\n                            </md-menu-item>\n                          </md-menu-content>\n                      </md-menu>\n                    </md-menu-item>\n                    \n                  </md-menu-content>\n                </md-menu>\n              </div>\n\n              <!-- Currency Balance -->\n              <div ng-if=\"entry.isCurrencyBalance\" layout=\"row\" class=\"currency-balance\" flex>\n                <div class=\"name\">{{entry.name}} <span ng-if=\"entry.index!=undefined\">#{{entry.index}}</span></div>&nbsp;\n                <div class=\"identifier\" flex><a ng-click=\"entry.unlock()\">{{entry.address}}</a></div>&nbsp;\n                <div class=\"balance\" ng-class=\"{'empty':entry.isZeroBalance()}\">\n                  <span class=\"state-message\" ng-if=\"entry.stateMessage\">{{entry.stateMessage}}</span>\n                  <span>{{entry.balance}}</span>\n                  <span ng-if=\"entry.hasDigit()\">&nbsp;&nbsp;&nbsp;{{entry.symbol}}</span>\n                </div>\n                <md-menu md-position-mode=\"target-right target\" md-offset=\"34px 34px\">\n                  <md-button aria-label=\"user menu\" class=\"md-icon-button right\" ng-click=\"$mdMenu.open($event)\" md-menu-origin >\n                    <md-icon md-font-library=\"material-icons\">more_horiz</md-icon>\n                  </md-button>\n                  <md-menu-content width=\"4\">\n                    <md-menu-item style=\"height: 26px; min-height: 26px\">\n                      <span style=\"text-align: center\">{{entry.name}}  address: {{entry.address}}</span>\n                    </md-menu-item>\n                    <md-menu-item ng-if=\"entry.pubKey\">\n                      <span style=\"font-size: x-small\">Public key:<br>{{entry.pubKey}}</span>\n                    </md-menu-item>\n                    <md-menu-item>\n                      <md-button aria-label=\"explorer\" ng-click=\"vm.showSecret(entry.secretPhrase, entry.symbol)\">\n                        <md-icon md-font-library=\"material-icons\">file_copy</md-icon>\n                        Show private key\n                      </md-button>\n                    </md-menu-item>\n                    <md-menu-item ng-hide=\"entry.symbol==='HEAT'\" ng-if=\"entry.index!=undefined\">\n                      <md-button aria-label=\"explorer\" ng-click=\"vm.createAddress(entry.walletEntry, entry.name)\">\n                        <md-icon md-font-library=\"material-icons\">add</md-icon>\n                        Create {{entry.symbol}} address\n                      </md-button>\n                    </md-menu-item>\n                    <md-menu-item>\n                      <md-button aria-label=\"explorer\" ng-hide=\"entry.symbol==='HEAT'\" ng-click=\"vm.deleteEntry(entry)\">\n                        <md-icon md-font-library=\"material-icons\">delete_forever</md-icon>\n                        Remove address  <span class=\"name\">{{entry.name}} <span ng-if=\"entry.index!=undefined\">#{{entry.index}}</span></span>\n                      </md-button>\n                    </md-menu-item>\n                  </md-menu-content>\n                </md-menu>\n              </div>\n\n              <!-- Currency Address Loading -->\n              <div ng-if=\"entry.isCurrencyAddressLoading\" layout=\"row\" class=\"currency-balance\" flex>\n                <div class=\"name\">{{entry.name}}</div>&nbsp;\n                <div class=\"identifier\" flex>{{entry.address || ''}}  loading ..</div>\n              </div>\n\n              <!-- Currency Address Create -->\n              <div ng-if=\"entry.isCurrencyAddressCreate\" layout=\"row\" class=\"currency-balance\" flex>\n                <div class=\"name\">{{entry.name}}</div>&nbsp;\n                <md-button ng-click=\"entry.createAddressByName(entry)\">Create New</md-button>\n                <md-menu ng-hide=\"entry.symbol==='HEAT'\" md-position-mode=\"target-right target\" md-offset=\"34px 34px\">\n                  <md-button aria-label=\"user menu\" class=\"md-icon-button right\" ng-click=\"$mdMenu.open($event)\" md-menu-origin >\n                    <md-icon md-font-library=\"material-icons\">menu</md-icon>\n                  </md-button>\n                  <md-menu-content width=\"4\">\n                    <md-menu-item>\n                      <md-button aria-label=\"explorer\" ng-click=\"vm.restoreAddresses(entry)\">\n                        Restore addresses\n                      </md-button>\n                    </md-menu-item>\n                  </md-menu-content>\n                </md-menu>\n                <!--<md-button class=\"name\" ng-click=\"entry.restoreAddresses(entry.component)\">Restore addresses</md-button>-->\n              </div>\n\n              <!-- Token Balance -->\n              <div ng-if=\"entry.isTokenBalance\" layout=\"row\" class=\"token-balance\" flex>\n                <div class=\"name\">{{entry.name}}</div>&nbsp;\n                <div class=\"identifier\" flex>{{entry.address}}</div>&nbsp;\n                <div class=\"balance\">{{entry.balance}}&nbsp;{{entry.symbol}}</div>\n              </div>\n\n            </md-list-item>\n          </md-list>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'localKeyStore', 'walletFile', '$window', 'lightwalletService', 'heat', 'assetInfo', 'ethplorer', '$mdToast', '$mdDialog', 'clipboard', 'user', 'bitcoreService', 'fimkCryptoService', 'nxtCryptoService', 'ardorCryptoService', 'ltcCryptoService', 'ltcBlockExplorerService', 'bchCryptoService', 'bchBlockExplorerService', 'nxtBlockExplorerService', 'ardorBlockExplorerService', 'mofoSocketService', 'iotaCoreService', 'storage', '$rootScope'),
        __metadata("design:paramtypes", [Object, Function, LocalKeyStoreService,
            WalletFileService, Object, LightwalletService,
            HeatService,
            AssetInfoService,
            EthplorerService, Object, Object, ClipboardService,
            UserService,
            BitcoreService,
            FIMKCryptoService,
            NXTCryptoService,
            ARDORCryptoService,
            LTCCryptoService,
            LtcBlockExplorerService,
            BCHCryptoService,
            BchBlockExplorerService,
            NxtBlockExplorerService,
            ArdorBlockExplorerService,
            MofoSocketService,
            IotaCoreService,
            StorageService, Object])
    ], WalletComponent);
    return WalletComponent;
}(wlt.WalletComponentAbstract));
var wlt;
(function (wlt) {
    var WalletEntry = (function () {
        function WalletEntry(account, name, component) {
            this.account = account;
            this.name = name;
            this.component = component;
            this.isWalletEntry = true;
            this.selected = true;
            this.currencies = [];
            this.unlocked = false;
            this.visible = true;
            this.expanded = false;
            this.btcWalletAddressIndex = 0;
            this.identifier = name ? "".concat(account, " | ").concat(name) : account;
            this.visibleLabel = wlt.getEntryVisibleLabel(this.account);
        }
        WalletEntry.prototype.setWalletComponent = function (component) {
            this.component = component;
        };
        WalletEntry.prototype.toggle = function (forceVisible) {
            var _this = this;
            this.expanded = forceVisible || !this.expanded;
            this.currencies.forEach(function (curr) {
                var currency = curr;
                currency.visible = _this.expanded;
                if (currency.tokens) {
                    currency.tokens.forEach(function (token) {
                        token.visible = _this.expanded;
                    });
                }
            });
            if (this.expanded) {
                this.component.loadEthereumAddresses(this);
                this.component.loadBitcoinAddresses(this);
                this.component.loadFIMKAddresses(this);
                this.component.loadNXTAddresses(this);
                this.component.loadARDORAddresses(this);
                this.component.loadIotaAddresses(this);
                this.component.loadLtcAddresses(this);
                this.component.loadBitcoinCashAddresses(this);
            }
        };
        WalletEntry.prototype.createEntries = function (currencyName, walletComponent, wallet) {
            var addressLoading = new wlt.CurrencyAddressLoading(currencyName);
            addressLoading.visible = this.expanded;
            addressLoading.wallet = wallet;
            this.currencies.push(addressLoading);
            var currencyAddressCreate = this.currencies.find(function (c) { return c['isCurrencyAddressCreate'] && c.name == currencyName; });
            if (!currencyAddressCreate) {
                currencyAddressCreate = new wlt.CurrencyAddressCreate(currencyName, wallet, this, walletComponent);
                currencyAddressCreate.flatten = walletComponent.flatten.bind(walletComponent);
                this.currencies.push(currencyAddressCreate);
            }
        };
        WalletEntry.prototype.findAddressLoading = function (currencySymbol) {
            var result = this.currencies
                .find(function (c) {
                var cal = c;
                return cal.isCurrencyAddressLoading && cal.currencySymbol == currencySymbol;
            });
            return result;
        };
        WalletEntry.prototype.findAddressCreate = function (currencySymbol) {
            var result = this.currencies
                .find(function (c) {
                var cal = c;
                return cal.isCurrencyAddressCreate && cal.currencySymbol == currencySymbol;
            });
            return result;
        };
        WalletEntry.prototype.getCryptoAddresses = function (currencySymbol) {
            var _a, _b;
            return ((_a = this.findAddressLoading(currencySymbol)) === null || _a === void 0 ? void 0 : _a.wallet) || ((_b = this.findAddressCreate(currencySymbol)) === null || _b === void 0 ? void 0 : _b.wallet);
        };
        WalletEntry.prototype.initBTC = function (walletComponent, wallet, user) {
            this.createEntries('Bitcoin', walletComponent, wallet);
            walletComponent.flatten();
            if (user.account === this.account) {
                walletComponent.shareCurrencyAddressesWithP2pContacts('BTC', wallet.addresses[0].address);
            }
            if (this.expanded) {
                walletComponent.loadBitcoinAddresses(this);
            }
        };
        WalletEntry.prototype.initEth = function (walletComponent, wallet) {
            this.createEntries('Ethereum', walletComponent, wallet);
            walletComponent.flatten();
            if (this.expanded) {
                walletComponent.loadEthereumAddresses(this);
            }
        };
        WalletEntry.prototype.initIota = function (walletComponent, wallet) {
            this.createEntries('Iota', walletComponent, wallet);
            walletComponent.flatten();
            if (this.expanded) {
                walletComponent.loadIotaAddresses(this);
            }
        };
        WalletEntry.prototype.initFIMK = function (walletComponent, wallet) {
            this.createEntries('FIMK', walletComponent, wallet);
            walletComponent.flatten();
            if (this.expanded) {
                walletComponent.loadFIMKAddresses(this);
            }
        };
        WalletEntry.prototype.initNXT = function (walletComponent, wallet) {
            this.createEntries('NXT', walletComponent, wallet);
            if (this.expanded) {
                walletComponent.loadNXTAddresses(this);
            }
        };
        WalletEntry.prototype.initARDOR = function (walletComponent, wallet) {
            this.createEntries('ARDOR', walletComponent, wallet);
            if (this.expanded) {
                walletComponent.loadARDORAddresses(this);
            }
        };
        WalletEntry.prototype.initLTC = function (walletComponent, wallet) {
            this.createEntries('Litecoin', walletComponent, wallet);
            walletComponent.flatten();
            if (this.expanded) {
                walletComponent.loadLtcAddresses(this);
            }
        };
        WalletEntry.prototype.initBCH = function (walletComponent, wallet) {
            this.createEntries('BitcoinCash', walletComponent, wallet);
            walletComponent.flatten();
            if (this.expanded) {
                walletComponent.loadBitcoinCashAddresses(this);
            }
        };
        return WalletEntry;
    }());
    wlt.WalletEntry = WalletEntry;
})(wlt || (wlt = {}));
var DialogFieldBuilder = (function () {
    function DialogFieldBuilder($scope) {
        this.$scope = $scope;
    }
    DialogFieldBuilder.prototype.money = function (name, _default) { return new DialogFieldMoney(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.account = function (name, _default) { return new DialogFieldAccount(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.asset = function (name, _default) { return new DialogFieldAsset(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.text = function (name, _default) { return new DialogFieldText(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.hidden = function (name, _default) { return new DialogFieldHidden(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.staticText = function (name, _default) { return new DialogFieldStatic(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.switcher = function (name, _default) { return new DialogFieldSwitcher(this.$scope, name, _default); };
    return DialogFieldBuilder;
}());
var AbstractDialogField = (function () {
    function AbstractDialogField($scope, name, value) {
        this.$scope = $scope;
        this.name = name;
        this.value = value;
        this._onchange = [];
        this.parsers = [];
        this.formatters = [];
        this.validators = [];
        this.asyncValidators = [];
        this.errorMessages = [];
        this._required = false;
        this._readonly = false;
        this._disabled = false;
        this._visible = true;
        this._previousValue = value;
    }
    AbstractDialogField.prototype.setValue = function (value) {
        this.value = value;
        return this;
    };
    AbstractDialogField.prototype.changed = function (force) {
        var _this = this;
        if (force || this.value != this._previousValue) {
            this._onchange.forEach(function (fn) {
                fn(_this.value, _this._previousValue);
            });
            this._previousValue = this.value;
        }
    };
    AbstractDialogField.prototype.selector = function (selector) {
        this._selector = selector;
    };
    AbstractDialogField.prototype.parse = function (parser) {
        this.parsers = this.parsers.concat(parser);
        return this;
    };
    AbstractDialogField.prototype.formatter = function (formatter) {
        this.formatters = this.formatters.concat(formatter);
        return this;
    };
    AbstractDialogField.prototype.validate = function (message, validator) {
        this.validators.push({
            validator: validator,
            message: message
        });
        return this;
    };
    AbstractDialogField.prototype.asyncValidate = function (message, validator) {
        this.asyncValidators.push({
            validator: validator,
            message: message
        });
        return this;
    };
    AbstractDialogField.prototype.onchange = function (fn) {
        this._onchange.push(fn);
        return this;
    };
    AbstractDialogField.prototype.required = function (required) {
        this._required = angular.isDefined(required) ? required : true;
        return this;
    };
    AbstractDialogField.prototype.readonly = function (readonly) {
        this._readonly = angular.isDefined(readonly) ? readonly : true;
        return this;
    };
    AbstractDialogField.prototype.label = function (label) {
        this._label = label;
        return this;
    };
    AbstractDialogField.prototype.disabled = function (disabled) {
        this._disabled = disabled;
        return this;
    };
    AbstractDialogField.prototype.visible = function (visible) {
        this._visible = visible;
        return this;
    };
    return AbstractDialogField;
}());
var Field = (function () {
    function Field() {
    }
    Field = __decorate([
        Component({
            selector: 'field',
            inputs: ['label', 'value', 'changed', 'f'],
            styles: ["\n    field .async-validator-pending md-progress-linear,\n    field .async-validator-pending md-progress-linear * {\n      height: 3px !important;\n    }\n    field .async-validator-pending .md-input:focus {\n      border-width: 0px !important;\n    }\n  "],
            link: function (scope, element, attrs, controller) {
                var h = [];
                h.push('<', attrs.selector, ' label="vm.label" value="vm.value" changed="vm.changed" f="vm.f">');
                h.push('</', attrs.selector, '>');
                element.html(h.join(''));
                element.injector().get('$compile')(element.contents())(scope);
            }
        })
    ], Field);
    return Field;
}());
heat.Loader.directive('fieldValidator', function () {
    return {
        require: '^ngModel',
        link: function (scope, elm, attrs, ngModel) {
            elm.bind('blur', function () {
                if (!ngModel.$valid) {
                    return;
                }
                var viewValue = ngModel.$modelValue;
                var formatters = ngModel.$formatters;
                for (var i = formatters.length - 1; i >= 0; --i) {
                    viewValue = formatters[i](viewValue);
                }
                ngModel.$viewValue = viewValue;
                ngModel.$render();
            });
            var field = scope.$eval(attrs.fieldValidator);
            if (!field) {
                return;
            }
            field.formatters.forEach(function (fn) { ngModel.$formatters.unshift(fn); });
            field.parsers.forEach(function (fn) { ngModel.$parsers.push(fn); });
            field.validators.forEach(function (validator, index) {
                ngModel.$validators["validator_".concat(index)] = function (modelValue, viewValue) {
                    return validator.validator(modelValue, viewValue);
                };
                field.errorMessages.push({
                    type: "validator_".concat(index),
                    text: validator.message
                });
            });
            field.asyncValidators.forEach(function (validator, index) {
                ngModel.$asyncValidators["async_validator_".concat(index)] = function (modelValue, viewValue) {
                    return validator.validator(modelValue, viewValue);
                };
                field.errorMessages.push({
                    type: "async_validator_".concat(index),
                    text: validator.message
                });
            });
        }
    };
});
var DialogFieldAccount = (function (_super) {
    __extends(DialogFieldAccount, _super);
    function DialogFieldAccount($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this.heat = heat.$inject.get('heat');
        _this.settings = heat.$inject.get('settings');
        _this.user = heat.$inject.get('user');
        _this.$q = heat.$inject.get('$q');
        _this.numbersOnly = /^[0-9]+$/;
        _this.selector('field-account');
        return _this;
    }
    DialogFieldAccount.prototype.search = function (query) {
        var _this = this;
        var deferred = this.$q.defer();
        this.heat.api.searchAccounts(query, 0, 100).then(function (accounts) {
            accounts = accounts ? accounts : [];
            accounts.forEach(function (account) {
                if (_this.numbersOnly.test(account.publicName)) {
                    account.publicName = '';
                }
            });
            if (accounts.length > 0) {
                deferred.resolve(accounts);
            }
            else if (_this.numbersOnly.test(query)) {
                _this.heat.api.getAccountByNumericId(query, true).then(function (account) {
                    deferred.resolve(account ? [account] : []);
                }, deferred.reject);
            }
            else {
                _this.heat.api.findAccountByName(query, true).then(function (account) {
                    if (!account) {
                        deferred.resolve([]);
                        return;
                    }
                    if (account.publicName == account.id) {
                        account["calculatedName"] = query;
                    }
                    deferred.resolve([account]);
                }, deferred.reject);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    DialogFieldAccount.prototype.setSearchText = function (value) {
        this.searchText = value;
    };
    return DialogFieldAccount;
}(AbstractDialogField));
var DialogFieldAccountComponent = (function () {
    function DialogFieldAccountComponent() {
    }
    DialogFieldAccountComponent.prototype.$onInit = function () {
        this.f.searchText = this.f.value;
    };
    DialogFieldAccountComponent.prototype.selectedItemChange = function () {
        this.f.value = this.selectedItem ? this.selectedItem.id : '';
    };
    DialogFieldAccountComponent.prototype.searchTextChange = function () {
        this.f.value = this.f.searchText;
    };
    DialogFieldAccountComponent = __decorate([
        Component({
            selector: 'fieldAccount',
            inputs: ['label', 'value', 'changed', 'f'],
            styles: ["\n  field-account md-input-container {\n    padding-bottom: 0px !important;\n  }\n  "],
            template: "\n    <ng-form name=\"userForm\" ng-show=\"vm.f._visible\">\n      <md-autocomplete\n        ng-required=\"vm.f._required\"\n        ng-readonly=\"vm.f._readonly\"\n        md-input-name=\"userField\"\n        md-floating-label=\"{{vm.label}}\"\n        md-min-length=\"1\"\n        md-delay=\"1000\"\n        md-items=\"item in vm.f.search(vm.f.searchText)\"\n        md-item-text=\"item.calculatedName || item.publicName || item.id\"\n        md-search-text=\"vm.f.searchText\"\n        md-selected-item-change=\"vm.selectedItemChange()\"\n        md-search-text-change=\"vm.searchTextChange()\"\n        md-selected-item=\"vm.selectedItem\"\n        md-autoselect\n        ng-disabled=\"vm.f._disabled\">\n        <md-item-template>\n          <div layout=\"row\" flex class=\"monospace-font\">\n            <span>{{item.calculatedName || item.publicName || ''}}</span>\n            <span flex></span>\n            <span>{{item.id}}</span>\n          </span>\n        </md-item-template>\n        <md-not-found>\n          No matches found\n        </md-not-found>\n        <div ng-messages=\"userForm.userField.$error\" ng-if=\"userForm.userField.$dirty\">\n          <div ng-messages-include=\"error-messages\"></div>\n          <div ng-repeat=\"errorMessage in vm.f.errorMessages\"\n               ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n        </div>\n      </md-autocomplete>\n    </ng-form>\n  "
        }),
        __metadata("design:paramtypes", [])
    ], DialogFieldAccountComponent);
    return DialogFieldAccountComponent;
}());
var DialogFieldAsset = (function (_super) {
    __extends(DialogFieldAsset, _super);
    function DialogFieldAsset($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this.heat = heat.$inject.get('heat');
        _this.$q = heat.$inject.get('$q');
        _this.settings = heat.$inject.get('settings');
        _this.user = heat.$inject.get('user');
        _this.assetInfo = heat.$inject.get('assetInfo');
        _this.availableAssets = [];
        _this._searchAllAssets = false;
        _this.selector('field-asset');
        return _this;
    }
    DialogFieldAsset.prototype.reset = function () {
        this.assetInfo.resetCache();
        this.availableAssetsPromise = null;
        return this;
    };
    DialogFieldAsset.prototype.initAvailableAssets = function () {
        var _this = this;
        if (this.availableAssetsPromise) {
            return this.availableAssetsPromise;
        }
        var deferred = this.$q.defer();
        if (this._searchAllAssets) {
            this.heat.api.getAllAssetProtocol1(0, 100).then(function (assets) {
                assets.unshift({
                    name: "HEAT Cryptocurrency",
                    symbol: "HEAT",
                    asset: "0",
                    decimals: 8
                });
                var promises = [];
                assets.forEach(function (asset) {
                    promises.push(_this.assetInfo.getInfo(asset.asset).then(function (info2) {
                        var info = {
                            issuer: info2.issuer,
                            name: asset.name,
                            symbol: asset.symbol,
                            id: asset.asset,
                            decimals: asset.decimals,
                            certified: false,
                            type: info2.type,
                            orderFee: info2.orderFee,
                            tradeFee: info2.tradeFee,
                            feeRecipient: info2.feeRecipient,
                            expiration: info2.expiration,
                            timestamp: info2.timestamp,
                            expired: info2.expired
                        };
                        info.symbol = info2.symbol;
                        info.name = info2.name;
                        info.certified = info2.certified;
                        _this.availableAssets.push(info);
                    }));
                });
                _this.$q.all(promises).then(deferred.resolve, deferred.reject);
            }, deferred.reject);
        }
        else {
            this.heat.api.getAccountBalances(this.user.account, "0", 1, 0, 100).then(function (balances) {
                var promises = [];
                balances.forEach(function (balance) {
                    promises.push(_this.assetInfo.getInfo(balance.id).then(function (info2) {
                        var info = {
                            issuer: info2.issuer,
                            name: '*',
                            symbol: '*',
                            id: balance.id,
                            decimals: balance.decimals,
                            certified: false,
                            type: info2.type,
                            orderFee: info2.orderFee,
                            tradeFee: info2.tradeFee,
                            feeRecipient: info2.feeRecipient,
                            expiration: info2.expiration,
                            timestamp: info2.timestamp,
                            expired: info2.expired
                        };
                        info.symbol = info2.symbol;
                        info.name = info2.name;
                        info.certified = info2.certified;
                        _this.availableAssets.push(info);
                    }));
                });
                _this.$q.all(promises).then(deferred.resolve, deferred.reject);
            }, deferred.reject);
        }
        return this.availableAssetsPromise = deferred.promise;
    };
    DialogFieldAsset.prototype.search = function (_query) {
        var _this = this;
        var deferred = this.$q.defer();
        var query = _query.toLowerCase();
        if (!angular.isString(query)) {
            deferred.resolve(this.availableAssets);
        }
        else {
            this.initAvailableAssets().then(function () {
                var matches = [];
                _this.availableAssets.forEach(function (asset) {
                    if ((asset.name && asset.name.toLowerCase().indexOf(query) != -1) ||
                        (asset.symbol && asset.symbol.toLowerCase().indexOf(query) != -1) ||
                        (asset.id && asset.id.toLowerCase().indexOf(query) != -1)) {
                        matches.push(asset);
                    }
                });
                deferred.resolve(matches);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    DialogFieldAsset.prototype.getAssetInfo = function (asset) {
        return this.availableAssets.find(function (info) { return info.id == asset; }) || null;
    };
    DialogFieldAsset.prototype.searchAllAssets = function (searchAllAssets) {
        this._searchAllAssets = searchAllAssets;
        return this;
    };
    return DialogFieldAsset;
}(AbstractDialogField));
var DialogFieldAssetComponent = (function () {
    function DialogFieldAssetComponent() {
    }
    DialogFieldAssetComponent.prototype.$onInit = function () {
        var _this = this;
        this.searchText = this.f.value;
        this.f.setValue = function (value) {
            _this.f.value = value;
            _this.searchText = _this.f.value;
        };
    };
    DialogFieldAssetComponent.prototype.selectedItemChange = function () {
        this.f.value = this.selectedItem ? this.selectedItem.id : '';
    };
    DialogFieldAssetComponent.prototype.searchTextChange = function () {
        this.f.value = this.searchText;
    };
    DialogFieldAssetComponent = __decorate([
        Component({
            selector: 'fieldAsset',
            inputs: ['label', 'value', 'changed', 'f'],
            styles: ["\n  field-asset md-input-container {\n    padding-bottom: 0px !important;\n  }\n  "],
            template: "\n    <ng-form name=\"userForm\" ng-show=\"vm.f._visible\">\n      <md-autocomplete\n        ng-required=\"vm.f._required\"\n        ng-readonly=\"vm.f._readonly\"\n        md-input-name=\"userField\"\n        md-floating-label=\"{{vm.label}}\"\n        md-min-length=\"1\"\n        md-items=\"item in vm.f.search(vm.searchText)\"\n        md-item-text=\"item.symbol + '    (' + item.id + ')'\"\n        md-search-text=\"vm.searchText\"\n        md-selected-item-change=\"vm.selectedItemChange()\"\n        md-search-text-change=\"vm.searchTextChange()\"\n        md-selected-item=\"vm.selectedItem\"\n        ng-disabled=\"vm.f._disabled\">\n        <md-item-template>\n          <div ng-class=\"{expired: !!item.expired}\" layout=\"row\" flex>\n            <span>{{item.symbol}}</span>\n            <span flex></span>\n            <span>{{item.id}}</span>\n          </span>\n        </md-item-template>\n        <md-not-found>\n          No matches found.\n        </md-not-found>\n        <div ng-messages=\"userForm.userField.$error\" ng-if=\"userForm.userField.$dirty\">\n          <div ng-messages-include=\"error-messages\"></div>\n          <div ng-repeat=\"errorMessage in vm.f.errorMessages\"\n               ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n        </div>\n      </md-autocomplete>\n    </ng-form>\n  "
        }),
        __metadata("design:paramtypes", [])
    ], DialogFieldAssetComponent);
    return DialogFieldAssetComponent;
}());
var DialogFieldHidden = (function (_super) {
    __extends(DialogFieldHidden, _super);
    function DialogFieldHidden($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this.selector('field-hidden');
        return _this;
    }
    return DialogFieldHidden;
}(AbstractDialogField));
var DialogFieldHiddenComponent = (function () {
    function DialogFieldHiddenComponent() {
    }
    DialogFieldHiddenComponent = __decorate([
        Component({
            selector: 'fieldHidden',
            inputs: ['label', 'value', 'changed', 'f'],
            template: "\n    <ng-form name=\"userForm\" layout=\"row\">\n      <input type=\"hidden\" field-validator=\"vm.f\" ng-model=\"vm.value\" ng-change=\"vm.changed()\"\n          name=\"userField\" ng-required=\"vm.f._required\" ng-readonly=\"vm.f._readonly\" ng-trim=\"false\">\n    </ng-form>\n  "
        })
    ], DialogFieldHiddenComponent);
    return DialogFieldHiddenComponent;
}());
var DialogFieldMoney = (function (_super) {
    __extends(DialogFieldMoney, _super);
    function DialogFieldMoney($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default) || this;
        _this._precision = 8;
        _this._symbol = 'HEAT';
        _this.selector('field-money');
        _this.parse(function (value) {
            if (value == '')
                return '';
            if (!utils.isNumber(value))
                return undefined;
            try {
                return utils.convertToQNT(utils.unformat(value), _this._precision);
            }
            catch (e) {
                console.log('this');
                console.log(_this);
                console.log('error:', e);
            }
        });
        _this.formatter(function (value) {
            if (value === undefined || value == '')
                return undefined;
            return utils.formatQNT(value, _this._precision);
        });
        _this.formatter(function (value) {
            if (value === undefined || value == '')
                return undefined;
            return utils.commaFormat(value);
        });
        return _this;
    }
    DialogFieldMoney.prototype.precision = function (precision) {
        this._precision = precision;
        return this;
    };
    DialogFieldMoney.prototype.symbol = function (symbol) {
        this._symbol = symbol;
        return this;
    };
    return DialogFieldMoney;
}(AbstractDialogField));
var DialogFieldMoneyComponent = (function () {
    function DialogFieldMoneyComponent() {
    }
    DialogFieldMoneyComponent = __decorate([
        Component({
            selector: 'fieldMoney',
            inputs: ['label', 'value', 'changed', 'f'],
            template: "\n    <ng-form name=\"userForm\" ng-show=\"vm.f._visible\">\n      <md-input-container class=\"md-block\" ng-class=\"{'async-validator-pending':userForm.userField.$pending}\">\n        <label>{{vm.label}}<span ng-if=\"vm.f._symbol\"> ({{vm.f._symbol}})</span></label>\n        <input field-validator=\"vm.f\" ng-model=\"vm.value\" ng-change=\"vm.changed()\"\n            name=\"userField\" ng-required=\"vm.f._required\" ng-readonly=\"vm.f._readonly\" ng-disabled=\"vm.f._disabled\">\n        <md-progress-linear md-mode=\"indeterminate\" ng-if=\"userForm.userField.$pending\"></md-progress-linear>\n        <div ng-messages=\"userForm.userField.$error\" ng-if=\"userForm.userField.$dirty\">\n          <div ng-messages-include=\"error-messages\"></div>\n          <div ng-repeat=\"errorMessage in vm.f.errorMessages\"\n               ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n        </div>\n      </md-input-container>\n    </ng-form>\n  "
        })
    ], DialogFieldMoneyComponent);
    return DialogFieldMoneyComponent;
}());
var DialogFieldStatic = (function (_super) {
    __extends(DialogFieldStatic, _super);
    function DialogFieldStatic($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this.selector('field-static');
        return _this;
    }
    DialogFieldStatic.prototype.scrollable = function (scrollable) {
        this._scrollable = scrollable;
        return this;
    };
    return DialogFieldStatic;
}(AbstractDialogField));
var DialogFieldStaticComponent = (function () {
    function DialogFieldStaticComponent() {
    }
    DialogFieldStaticComponent = __decorate([
        Component({
            selector: 'fieldStatic',
            inputs: ['label', 'value', 'changed', 'f'],
            styles: ["\n    ng-form .scrollable-field {\n      max-height: 160px;\n      font-family: monospace;\n      overflow: scroll;\n    }\n  "],
            template: "\n    <ng-form name=\"userForm\" layout=\"row\" ng-show=\"vm.f._visible\">\n      <md-input-container class=\"md-block\" flex ng-class=\"{'async-validator-pending':userForm.userField.$pending}\">\n        <label ng-if=\"vm.label\">{{vm.label}}</label>\n        <p ng-if=\"!vm.f._scrollable\">{{vm.value}}</p>\n        <textarea ng-if=\"vm.f._scrollable\" class=\"scrollable-field\" readonly>{{vm.value}}</textarea>\n      </md-input-container>\n    </ng-form>\n  "
        })
    ], DialogFieldStaticComponent);
    return DialogFieldStaticComponent;
}());
var DialogFieldSwitcher = (function (_super) {
    __extends(DialogFieldSwitcher, _super);
    function DialogFieldSwitcher($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this._trueLabel = "YES";
        _this._falseLabel = "NO";
        _this.selector('field-switcher');
        return _this;
    }
    DialogFieldSwitcher.prototype.valueLabels = function (trueLabel, falseLabel) {
        this._trueLabel = trueLabel;
        this._falseLabel = falseLabel;
        return this;
    };
    DialogFieldSwitcher.prototype.valueNotes = function (trueNote, falseNote) {
        this._trueNote = trueNote;
        this._falseNote = falseNote;
        return this;
    };
    return DialogFieldSwitcher;
}(AbstractDialogField));
var DialogFieldSwitcherComponent = (function () {
    function DialogFieldSwitcherComponent() {
    }
    DialogFieldSwitcherComponent = __decorate([
        Component({
            selector: 'fieldSwitcher',
            inputs: ['label', 'value', 'changed', 'f'],
            styles: ["\n    ng-form .note {max-width: 300px; margin-left: 20px; color: grey;}\n  "],
            template: "\n    <ng-form name=\"userForm\" layout=\"row\" ng-show=\"vm.f._visible\">\n      <label>{{vm.label}}</label>\n      <div>\n        <md-switch ng-model=\"vm.value\" ng-change=\"vm.changed()\"\n            name=\"userField\" ng-required=\"vm.f._required\" ng-readonly=\"vm.f._readonly\" ng-trim=\"false\" ng-disabled=\"vm.f._disabled\"\n            class=\"md-primary\">\n          <span ng-show=\"vm.value\">{{vm.f._trueLabel || 'YES'}}</span>\n          <span ng-hide=\"vm.value\">{{vm.f._falseLabel || 'NO'}}</span>\n        </md-switch>\n      </div>\n      <div class=\"note\" ng-if=\"vm.value\">{{vm.f._trueNote}}</div>\n      <div class=\"note\" ng-hide=\"vm.value\">{{vm.f._falseNote}}</div>\n      <div ng-messages=\"userForm.userField.$error\" ng-if=\"userForm.userField.$dirty\">\n        <div ng-messages-include=\"error-messages\"></div>\n        <div ng-repeat=\"errorMessage in vm.f.errorMessages\" ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n      </div>\n    </ng-form>\n  "
        })
    ], DialogFieldSwitcherComponent);
    return DialogFieldSwitcherComponent;
}());
var DialogFieldText = (function (_super) {
    __extends(DialogFieldText, _super);
    function DialogFieldText($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this._rows = 0;
        _this.selector('field-text');
        return _this;
    }
    DialogFieldText.prototype.rows = function (rows) {
        this._rows = rows;
        return this;
    };
    return DialogFieldText;
}(AbstractDialogField));
var DialogFieldTextComponent = (function () {
    function DialogFieldTextComponent() {
    }
    DialogFieldTextComponent = __decorate([
        Component({
            selector: 'fieldText',
            inputs: ['label', 'value', 'changed', 'f'],
            template: "\n    <ng-form name=\"userForm\" layout=\"row\" ng-show=\"vm.f._visible\">\n      <md-input-container class=\"md-block\" flex ng-class=\"{'async-validator-pending':userForm.userField.$pending}\">\n        <label>{{vm.label}}</label>\n        <input ng-if=\"!vm.f._rows\" field-validator=\"vm.f\" ng-model=\"vm.value\" ng-change=\"vm.changed()\"\n            name=\"userField\" ng-required=\"vm.f._required\" ng-readonly=\"vm.f._readonly\" ng-trim=\"false\" ng-disabled=\"vm.f._disabled\">\n        <textarea ng-if=\"vm.f._rows\" field-validator=\"vm.f\" ng-model=\"vm.value\" ng-change=\"vm.changed()\"\n            name=\"userField\" ng-required=\"vm.f._required\" ng-readonly=\"vm.f._readonly\"\n            ng-trim=\"false\" rows=\"{{vm.f._rows}}\" ng-disabled=\"vm.f._disabled\"></textarea>\n        <md-progress-linear md-mode=\"indeterminate\" ng-if=\"userForm.userField.$pending\"></md-progress-linear>\n        <div ng-messages=\"userForm.userField.$error\" ng-if=\"userForm.userField.$dirty\">\n          <div ng-messages-include=\"error-messages\"></div>\n          <div ng-repeat=\"errorMessage in vm.f.errorMessages\"\n               ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n        </div>\n      </md-input-container>\n    </ng-form>\n  "
        })
    ], DialogFieldTextComponent);
    return DialogFieldTextComponent;
}());
var TransactionMessageType;
(function (TransactionMessageType) {
    TransactionMessageType[TransactionMessageType["TO_SELF"] = 0] = "TO_SELF";
    TransactionMessageType[TransactionMessageType["TO_RECIPIENT"] = 1] = "TO_RECIPIENT";
    TransactionMessageType[TransactionMessageType["PUBLIC"] = 2] = "PUBLIC";
})(TransactionMessageType || (TransactionMessageType = {}));
var TransactionBuilder = (function () {
    function TransactionBuilder(transaction) {
        this.transaction = transaction;
        this.$q = heat.$inject.get('$q');
        this.user = heat.$inject.get('user');
        this.settings = heat.$inject.get('settings');
        this.heat = heat.$inject.get('heat');
        this._deadline = 1440;
        this._messageIsBinary = false;
    }
    TransactionBuilder.prototype.deadline = function (deadline) {
        this._deadline = deadline;
        return this;
    };
    TransactionBuilder.prototype.feeNQT = function (feeHQT) {
        this._feeHQT = feeHQT;
        return this;
    };
    TransactionBuilder.prototype.secretPhrase = function (secretPhrase) {
        this._secretPhrase = secretPhrase;
        return this;
    };
    TransactionBuilder.prototype.recipientPublicKey = function (recipientPublicKey) {
        this._recipientPublicKey = recipientPublicKey;
        return this;
    };
    TransactionBuilder.prototype.recipient = function (recipient) {
        this._recipient = recipient;
        return this;
    };
    TransactionBuilder.prototype.message = function (message, messageType, isBinary) {
        this._message = message;
        this._messageType = messageType;
        this._messageIsBinary = isBinary;
        return this;
    };
    TransactionBuilder.prototype.attachment = function (name, attachment) {
        this._attachment = {};
        this._attachment[name] = attachment;
        return this;
    };
    TransactionBuilder.prototype.create = function (createTransactionApiFunc) {
        var _this = this;
        if (createTransactionApiFunc === void 0) { createTransactionApiFunc = function (input) { return _this.heat.api.createTransaction(input); }; }
        var deferred = this.$q.defer();
        try {
            this._transactionArgs = this.getCreateTransactionArgs();
            createTransactionApiFunc(this._transactionArgs)
                .then(function (data) {
                _this._transactionData = data;
                deferred.resolve();
            })
                .catch(function (error) {
                console.log(error);
                deferred.reject(error);
            });
        }
        catch (e) {
            console.log(e);
            deferred.reject(e);
        }
        return deferred.promise;
    };
    TransactionBuilder.prototype.sign = function () {
        var deferred = this.$q.defer();
        var signature = heat.crypto.signBytes(this._transactionData.unsignedTransactionBytes, converters.stringToHexString(this._secretPhrase));
        var publicKey = heat.crypto.secretPhraseToPublicKey(this._secretPhrase);
        if (!heat.crypto.verifyBytes(signature, this._transactionData.unsignedTransactionBytes, publicKey)) {
            deferred.reject({
                description: 'Server returned invalid transaction',
                code: 1
            });
        }
        else {
            var payload = this.transaction.verifyAndSignTransactionBytes(this._transactionData.unsignedTransactionBytes, signature, this._transactionArgs);
            if (!payload) {
                deferred.reject({
                    description: 'Could not confirm client signature',
                    code: 2
                });
            }
            else {
                this._transactionBytes = payload;
                this.transactionFullHash = heat.crypto.calculateFullHash(this._transactionData.unsignedTransactionBytes, signature);
                this.transactionId = heat.crypto.calculateTransactionId(this.transactionFullHash);
                deferred.resolve();
            }
        }
        return deferred.promise;
    };
    TransactionBuilder.prototype.broadcast = function () {
        var _this = this;
        var deferred = this.$q.defer();
        var p = this.heat.api.broadcast({ transactionBytes: this._transactionBytes });
        p.then(function (data) {
            if (data.fullHash != _this.transactionFullHash) {
                deferred.resolve({
                    success: false,
                    internalError: 'Fullhash from server does not match expected fullHash'
                });
            }
            else if (data.transaction != _this.transactionId) {
                deferred.resolve({
                    success: false,
                    internalError: 'Transaction id from server does not match expected id'
                });
            }
            else {
                deferred.resolve({
                    success: true
                });
            }
        }).catch(function (error) {
            if (error instanceof InternalServerTimeoutError) {
                deferred.resolve({
                    success: false,
                    internalTimeout: true
                });
            }
            else {
                deferred.resolve({
                    success: false,
                    serverError: error.description
                });
            }
        });
        return deferred.promise;
    };
    TransactionBuilder.prototype.getCreateTransactionArgs = function () {
        var attachment = angular.isFunction(this._attachment) ? this._attachment.call(null) : (this._attachment || {});
        if (!angular.isDefined(this._feeHQT)) {
            throw new Error("You must provide a fee");
        }
        var args = {
            fee: this._feeHQT,
            deadline: this._deadline,
            publicKey: heat.crypto.secretPhraseToPublicKey(this._secretPhrase),
            broadcast: false
        };
        angular.extend(args, attachment);
        if (utils.emptyToNull(this._recipientPublicKey)) {
            args.recipientPublicKey = this._recipientPublicKey;
        }
        if (utils.emptyToNull(this._recipient)) {
            args.recipient = this._recipient;
        }
        if (utils.emptyToNull(this._message)) {
            switch (this._messageType) {
                case TransactionMessageType.TO_SELF: {
                    angular.extend(args, this.encryptToSelf(this._message));
                    break;
                }
                case TransactionMessageType.TO_RECIPIENT: {
                    if (!angular.isDefined(args.recipientPublicKey)) {
                        throw new Error("You must provide a recipient that has a publickey");
                    }
                    var publicKey = converters.hexStringToByteArray(args.recipientPublicKey);
                    angular.extend(args, this.encryptToRecipient(this._message, args.recipient, publicKey));
                    break;
                }
                case TransactionMessageType.PUBLIC: {
                    args.message = this._message;
                    args.messageIsText = !this._messageIsBinary;
                    break;
                }
            }
        }
        return args;
    };
    TransactionBuilder.prototype.encryptToSelf = function (message, isBinary) {
        var publicKey = converters.hexStringToByteArray(heat.crypto.secretPhraseToPublicKey(this._secretPhrase));
        var encrypted = isBinary ?
            heat.crypto.encryptBinaryNote(message, { "publicKey": publicKey }, this._secretPhrase, true) :
            heat.crypto.encryptNote(message, { "publicKey": publicKey }, this._secretPhrase);
        return {
            "encryptToSelfMessageData": encrypted.message,
            "encryptToSelfMessageNonce": encrypted.nonce,
            "messageToEncryptToSelfIsText": !isBinary
        };
    };
    TransactionBuilder.prototype.encryptToRecipient = function (message, recipient, recipientPublicKey, isBinary) {
        var options = {
            "account": recipient,
            "publicKey": recipientPublicKey
        };
        var encrypted = isBinary ?
            heat.crypto.encryptBinaryNote(message, options, this._secretPhrase, true) :
            heat.crypto.encryptNote(message, options, this._secretPhrase);
        return {
            "encryptedMessageData": encrypted.message,
            "encryptedMessageNonce": encrypted.nonce,
            "messageToEncryptIsText": !isBinary
        };
    };
    return TransactionBuilder;
}());
var ArdorTraderQuickBuySellComponent = (function () {
    function ArdorTraderQuickBuySellComponent($scope, $q, $mdToast, user, settings, ardorBlockExplorerService) {
        var _this = this;
        this.$scope = $scope;
        this.$q = $q;
        this.$mdToast = $mdToast;
        this.user = user;
        this.settings = settings;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.quantity = '0';
        this.price = '0';
        this.total = null;
        this.fee = utils.formatQNT(HeatAPI.fee.standard, 8);
        this.EXPIRY_MIN = 3600;
        this.EXPIRY_MAX = 3600 * 24 * 30;
        this.expiryUnitsOptions = {
            'minutes': {
                label: 'Minutes',
                min: Math.round(this.EXPIRY_MIN / 60),
                max: Math.round(this.EXPIRY_MAX / 60),
                delta: 60
            },
            'hours': {
                label: 'Hours',
                min: Math.round(this.EXPIRY_MIN / (60 * 60)),
                max: Math.round(this.EXPIRY_MAX / (60 * 60)),
                delta: 60 * 60
            },
            'days': {
                label: 'Days',
                min: 1,
                max: 30,
                delta: (60 * 60 * 24)
            },
            'weeks': {
                label: 'Weeks',
                min: 1,
                max: 4,
                delta: (60 * 60 * 24 * 7)
            }
        };
        this.expiryUnits = 'days';
        this.expiryUnitsValue = 30;
        this.expiresTooltip = '';
        $scope.$on('price', function (event, opts) {
            _this.price = opts.price.toFixed(8);
            _this.quantity = opts.balance.toFixed(8);
            _this.total = opts.total.toFixed(8);
        });
        $scope.$watch('vm.selectedOrder', function () {
            if (_this.selectedOrder) {
                var price = parseFloat(utils.formatQNT(_this.selectedOrder.price));
                price = 1 / price;
                _this.price = price.toFixed(_this.currencyInfo.decimals);
                if (_this.selectedOrder.type == 'bid' && angular.isString(_this.assetInfo.userBalance)) {
                    _this.quantity = utils.formatQNT(_this.assetInfo.userBalance, _this.assetInfo.decimals);
                    var total = parseFloat(utils.unformat(_this.price)) * parseFloat(utils.unformat(_this.quantity));
                    _this.total = String(total);
                }
                else if (_this.selectedOrder.type == 'ask' && angular.isString(_this.currencyInfo.userBalance)) {
                    _this.total = utils.formatQNT(_this.currencyInfo.userBalance, _this.currencyInfo.decimals);
                    var quantity = parseFloat(utils.unformat(_this.total)) / parseFloat(utils.unformat(_this.price));
                    _this.quantity = String(quantity);
                }
            }
        });
        this.notifyUser = utils.debounce(function (text) {
            $mdToast.show($mdToast.simple().textContent(text).hideDelay(3000));
        }, 500, true);
        this.expiryUnitsValueChanged(true);
    }
    ArdorTraderQuickBuySellComponent.prototype.expiryUnitsValueChanged = function (suppressNotification) {
        this.expiry = parseInt(this.expiryUnitsValue + '') * this.expiryUnitsOptions[this.expiryUnits].delta;
        this.expiryValid = false;
        this.expiresTooltip = '';
        if (this.expiry <= this.EXPIRY_MAX && this.expiry >= this.EXPIRY_MIN) {
            this.expiryValid = true;
            var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
            var date = new Date(Date.now() + (this.expiry * 1000));
            var dateFormatted = dateFormat(date, format);
            this.expiresTooltip = "This order will expiry if (even partially) unfilled by ".concat(dateFormatted);
        }
        else {
            var min = this.expiryUnitsOptions[this.expiryUnits].min;
            var max = this.expiryUnitsOptions[this.expiryUnits].max;
            var units = this.expiryUnitsOptions[this.expiryUnits].label;
            this.expiresTooltip = "Min expiry in ".concat(units, " is ").concat(min, ", max expiry in ").concat(units, " is ").concat(max);
            this.notifyUser(this.expiresTooltip);
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.quickAsk = function ($event) {
        console.log('qa');
        if (angular.isString(this.assetInfo.userBalance)) {
            var quantityQNT = parseInt(utils.unformat(this.quantity));
            var balanceQNT = parseInt(utils.unformat(this.currencyInfo.userBalance));
            if (balanceQNT < quantityQNT) {
                this.notifyUser("Insufficient ".concat(this.assetInfo.symbol, " balance"));
                return;
            }
            var price = parseInt(this.price);
            this.ardorBlockExplorerService.sendTransactionWithSecret("placeAskOrder&chain=2&asset=".concat(this.currencyInfo.id, "&quantityQNT=").concat(quantityQNT, "&priceNQTPerShare=").concat(price, "&secretPhrase=").concat(this.user.secretPhrase, "&feeNQT=3030000"));
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.quickBid = function ($event) {
        console.log('qb');
        if (angular.isString(this.currencyInfo.userBalance)) {
            var total = parseInt(utils.unformat(this.total));
            var balanceQNT = parseInt(utils.unformat(this.currencyInfo.userBalance));
            if (balanceQNT < total) {
                this.notifyUser("Insufficient ".concat(this.currencyInfo.symbol, " balance"));
                return;
            }
            var price = parseInt(this.price);
            this.ardorBlockExplorerService.sendTransactionWithSecret("placeBidOrder&chain=2&asset=".concat(this.currencyInfo.id, "&quantityQNT=").concat(total, "&priceNQTPerShare=").concat(price, "&secretPhrase=").concat(this.user.secretPhrase, "&feeNQT=3030000"));
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.calculateTotalPrice = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var quantity = utils.unformat(this.quantity) || "0";
            if (price == "0" || quantity == "0") {
                return "";
            }
            else {
                var quantityQNT = utils.convertToQNT(quantity);
                var priceQNT = utils.convertToQNT(price);
                var totalQNT = utils.calculateTotalOrderPriceQNT(quantityQNT, priceQNT);
                return utils.formatQNT(totalQNT, this.currencyInfo.decimals, true);
            }
        }
        catch (e) {
            return "";
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.recalculateTotal = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var quantity = utils.unformat(this.quantity) || "0";
            if (price == "0" || quantity == "0") {
                this.total = "0";
            }
            else {
                this.total = String(parseFloat(utils.unformat(this.price)) * parseFloat(utils.unformat(this.quantity)));
            }
        }
        catch (e) {
            console.log(e);
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.recalculateAmount = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var total = utils.unformat(this.total) || "0";
            if (price == "0" || total == "0") {
                this.quantity = "0";
            }
            else {
                this.quantity = String(parseFloat(utils.unformat(this.total)) / parseFloat(utils.unformat(this.price)));
            }
        }
        catch (e) {
            console.log(e);
        }
    };
    ArdorTraderQuickBuySellComponent = __decorate([
        Component({
            selector: 'ardorTraderQuickBuySell',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder', 'oneClickOrders'],
            template: "\n    <div>\n      <div class=\"trader-component-title\">Buy/Sell&nbsp;<elipses-loading ng-show=\"vm.loading\"></elipses-loading></div>\n      <form name=\"quickBuySellForm\">\n        <div class=\"row\">\n          <div class=\"label\">\n            Unit price\n          </div>\n          <div class=\"input\">\n            <input id=\"trader-quick-buy-sell-price-input\" type=\"text\" ng-model=\"vm.price\" required\n              ng-change=\"vm.recalculateTotal()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.currencyInfo.symbol}} / {{vm.assetInfo.symbol}}\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Amount\n          </div>\n          <div class=\"input\">\n            <input id=\"trader-quick-buy-sell-quantity-input\" type=\"text\" ng-model=\"vm.quantity\"\n              ng-change=\"vm.recalculateTotal()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.assetInfo.symbol}}\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\" ng-class=\"{'expires-invalid': !vm.expiryValid}\">\n            Expires in\n          </div>\n          <div class=\"input\">\n            <input type=\"number\" ng-model=\"vm.expiryUnitsValue\" required name=\"expiry\"\n                      ng-change=\"vm.expiryUnitsValueChanged()\"\n                      min=\"{{vm.expiryUnitsOptions[vm.expiryUnits].min}}\"\n                      max=\"{{vm.expiryUnitsOptions[vm.expiryUnits].max}}\"\n                      ng-disabled=\"true\">\n          </div>\n          <div class=\"label\">\n            <md-menu>\n              <a ng-click=\"$mdMenu.open($event)\">\n                <md-tooltip>{{vm.expiresTooltip}}</md-tooltip>\n                {{vm.expiryUnitsOptions[vm.expiryUnits].label}}\n              </a>\n              <md-menu-content width=\"4\">\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='minutes';vm.expiryUnitsValueChanged()\">Minutes</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='hours';vm.expiryUnitsValueChanged()\">Hours</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='days';vm.expiryUnitsValueChanged()\">Days</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='weeks';vm.expiryUnitsValueChanged()\">Weeks</md-button>\n                </md-menu-item>\n              </md-menu-content>\n            </md-menu>\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Total\n          </div>\n          <div class=\"input\">\n            <input type=\"text\" id=\"trader-quick-buy-sell-total-input\" ng-model=\"vm.total\" required max-decimals=\"{{vm.currencyInfo.decimals}}\"\n              ng-change=\"vm.recalculateAmount()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.currencyInfo.symbol}}\n          </div>\n        </div>\n        <div ng-hide=\"vm.user.unlocked\" class=\"row bottom-row\">\n          <md-button class=\"md-primary\" aria-label=\"Sign in\" href=\"#/login\">\n            Sign in to trade\n          </md-button>\n        </div>\n        <div ng-show=\"vm.user.unlocked\" class=\"row bottom-row\">\n          <div>\n            <md-button class=\"md-primary\" aria-label=\"Buy\" ng-click=\"vm.quickBid($event)\" ng-disabled=\"quickBuySellForm.$invalid||!vm.expiryValid\">\n              BUY\n            </md-button>\n          </div>\n          <div>\n          <md-switch ng-model=\"vm.oneClickOrders\" aria-label=\"1-click orders\" class=\"md-primary\" ng-disabled=\"true\">\n            <span ng-show=\"vm.oneClickOrders\"><b>1-click orders enabled</b></span><span ng-hide=\"vm.oneClickOrders\">1-click orders disabled</span>\n          </md-switch>\n        </div>\n          <div>\n            <md-button class=\"md-warn\" aria-label=\"Sell\" ng-click=\"vm.quickAsk($event)\" ng-disabled=\"quickBuySellForm.$invalid||!vm.expiryValid\">\n              SELL\n            </md-button>\n          </div>\n        </div>\n      </form>\n    </div>\n  "
        }),
        Inject('$scope', '$q', '$mdToast', 'user', 'settings', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Function, Object, UserService,
            SettingsService,
            ArdorBlockExplorerService])
    ], ArdorTraderQuickBuySellComponent);
    return ArdorTraderQuickBuySellComponent;
}());
var ArdorTraderBalancesComponent = (function () {
    function ArdorTraderBalancesComponent($scope, user, assetInfoService, $q, ardorBlockExplorerService) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.assetInfoService = assetInfoService;
        this.$q = $q;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.assetBalances = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                var refresh = utils.debounce((angular.bind(_this, _this.loadBalances)), 1 * 1000, false);
                _this.loadBalances();
                unregister.forEach(function (fn) { fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    ArdorTraderBalancesComponent.prototype.loadBalances = function () {
        var _this = this;
        this.ardorBlockExplorerService.getBalance(this.user.account, 2).then(function (balance) {
            _this.assetBalances.push({ symbol: 'IGNIS', balance: new Big(utils.convertToQNTf(balance)).toFixed(8), name: 'IGNIS' });
            _this.assetInfo.userBalance = balance;
        });
        this.ardorBlockExplorerService.getAccountAssets(this.user.account).then(function (assets) {
            _this.$scope.$evalAsync(function () {
                var promises = [];
                assets.forEach(function (balance) {
                    promises.push(_this.assetInfoService.getInfo(balance.asset).then(function (info) {
                        _this.$scope.$evalAsync(function () {
                            balance.symbol = info.symbol;
                            balance.name = info.name;
                            balance.balance = utils.formatQNT(balance.quantityQNT, info.decimals).replace(/.00000000$/, '');
                            ;
                            _this.assetBalances.push(balance);
                        });
                    }));
                    balance.symbol = '*';
                    balance.name = '*';
                    balance.balance = '*';
                    if (_this.currencyInfo.id == balance.asset)
                        _this.currencyInfo.userBalance = balance.quantityQNT;
                    if (_this.assetInfo.id == balance.asset)
                        _this.assetInfo.userBalance = balance.quantityQNT;
                });
                Promise.all(promises).then(function () {
                    _this.$scope.$evalAsync(function () {
                        _this.assetBalances.sort(function (a, b) {
                            if (a.symbol < b.symbol)
                                return 1;
                            if (a.symbol > b.symbol)
                                return -1;
                            return 0;
                        });
                    });
                });
            });
        });
    };
    ArdorTraderBalancesComponent = __decorate([
        Component({
            selector: 'ardorTraderBalances',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div layout=\"row\" class=\"trader-component-title\">Account&nbsp;\n      <span flex></span>\n      <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n    </div>\n    <md-list>\n      <md-list-item class=\"header\">\n        <div class=\"truncate-col symbol-col\">Asset</div>\n        <div class=\"truncate-col balance-col right-align\" flex>Balance</div>\n      </md-list-item>\n      <md-virtual-repeat-container  flex layout-fill layout=\"column\" virtual-repeat-flex-helper  class=\"content\">\n        <md-list-item md-virtual-repeat=\"item in vm.assetBalances\">\n          <div class=\"truncate-col symbol-col\" >{{item.symbol}}</div>\n          <div class=\"truncate-col balance-col right-align\" flex>{{item.balance}}</div>\n        </md-list-item>\n      </md-virtual-repeat-container>\n    </md-list>\n  "
        }),
        Inject('$scope', 'user', 'ardorAssetInfo', '$q', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, UserService,
            ArdorAssetInfoService, Function, ArdorBlockExplorerService])
    ], ArdorTraderBalancesComponent);
    return ArdorTraderBalancesComponent;
}());
var ArdorTraderInfoAssetDescriptionComponent = (function () {
    function ArdorTraderInfoAssetDescriptionComponent($scope, assetInfoService, $q, heat, user) {
        var _this = this;
        this.$scope = $scope;
        this.assetInfoService = assetInfoService;
        this.$q = $q;
        this.heat = heat;
        this.user = user;
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.$scope.$evalAsync(function () {
                    _this.currencyIssuer = _this.currencyInfo.issuer;
                    _this.currencyIssuerPublicName = _this.currencyInfo.issuerPublicName;
                    _this.assetIssuer = _this.assetInfo.issuer;
                    _this.assetIssuerPublicName = _this.assetInfo.issuerPublicName;
                });
                unregister.forEach(function (fn) { return fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    ArdorTraderInfoAssetDescriptionComponent.prototype.showDescription = function ($event, info) {
        dialogs.assetInfo($event, info);
    };
    ArdorTraderInfoAssetDescriptionComponent = __decorate([
        Component({
            selector: 'ardorTraderInfoAssetDescription',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div class=\"asset-container\">\n      <div class=\"asset-description\">\n        <div class=\"col\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Asset name:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.showDescription($event, vm.currencyInfo)\">{{vm.currencyInfo.name}}</a>\n            </div>\n          </div>\n          <div class=\"col-item issued-by\">\n            <div class=\"title\">\n              Issuer:\n            </div>\n            <div class=\"value\">\n              {{vm.currencyIssuerPublicName||vm.currencyIssuer}}\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"asset-description\">\n        <div class=\"col\">\n          <div class=\"col-item header\">\n            <div class=\"title\">\n              Asset name:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.showDescription($event, vm.assetInfo)\">{{vm.assetInfo.name}}</a>\n            </div>\n          </div>\n          <div class=\"col-item issued-by\">\n            <div class=\"title\">\n              Issuer:\n            </div>\n            <div class=\"value\">\n              {{vm.assetIssuerPublicName||vm.assetIssuer}}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'assetInfo', '$q', 'heat', 'user'),
        __metadata("design:paramtypes", [Object, AssetInfoService, Function, HeatService,
            UserService])
    ], ArdorTraderInfoAssetDescriptionComponent);
    return ArdorTraderInfoAssetDescriptionComponent;
}());
var ArdorTraderInfoComponent = (function () {
    function ArdorTraderInfoComponent() {
    }
    ArdorTraderInfoComponent = __decorate([
        Component({
            selector: 'ardorTraderInfo',
            inputs: ['currencyInfo', 'assetInfo', 'toggleMarkets', 'marketsSidenavOpen'],
            template: "\n    <div>\n      <div class=\"top-row\">\n        <div class=\"market-title\">\n          <span>\n            <md-button class=\"md-icon-button show-hide\" aria-label=\"Show/hide markets\" ng-click=\"vm.toggleMarkets()\">\n              <md-tooltip md-direction=\"bottom\">Show/Hide markets</md-tooltip>\n              <i><img src=\"assets/{{vm.marketsSidenavOpen?'minusIcon':'plusIcon'}}.png\"></i>\n            </md-button>\n          </span>\n          <span class=\"market-title-text\">\n            <span ng-class=\"{certified:vm.currencyInfo.certified}\">{{vm.currencyInfo.symbol}}</span>/<span ng-class=\"{certified:vm.assetInfo.certified}\">{{vm.assetInfo.symbol}}</span>\n          </span>\n        </div>\n      </div>\n      <ardor-trader-info-asset-description currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-info-asset-description>\n    </div>\n  "
        })
    ], ArdorTraderInfoComponent);
    return ArdorTraderInfoComponent;
}());
var ArdorTraderMarketsComponent = (function () {
    function ArdorTraderMarketsComponent($scope, heat, assetInfo, storage, $q, $mdToast, $interval, ardorBlockExplorerService) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.assetInfo = assetInfo;
        this.storage = storage;
        this.$q = $q;
        this.$mdToast = $mdToast;
        this.$interval = $interval;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.sort = 'change';
        this.asc = true;
        this.filter = '';
        this.preMarkets = [null, null];
        this.markets = [];
        this.showFakeMarketsWarning = true;
        this.filterFunc = function (item) { return _this.filterFuncImpl(item); };
        var refresh = utils.debounce(angular.bind(this, this.loadMarkets), 5 * 1000, false);
        heat.subscriber.trade({}, function (trade) { return refresh; }, $scope);
        this.loadMarkets();
        var interval = $interval(function () {
            _this.loadMarkets();
        }, 20 * 1000, 0, false);
        $scope.$on('$destroy', function () { $interval.cancel(interval); });
    }
    ArdorTraderMarketsComponent.prototype.loadMarkets = function () {
        var _this = this;
        this.ardorBlockExplorerService.getAllAssets().then(function (assets) {
            _this.markets = assets;
            _this.markets.forEach(function (market) {
                market.currencyInfo = { symbol: market.name, name: market.name, description: market.description };
                market.assetInfo = { symbol: 'IGNIS' };
            });
        });
    };
    ArdorTraderMarketsComponent.prototype.isSpecialMarket = function (market) {
        return market.currency == '5592059897546023466' && market.asset == '0';
    };
    ArdorTraderMarketsComponent.prototype.compareMarketAlphabetical = function (a, b) {
        var currencyA = a['currencyInfo'];
        var assetA = a['assetInfo'];
        var currencyB = b['currencyInfo'];
        var assetB = b['assetInfo'];
        if (currencyA.symbol < currencyB.symbol)
            return -1;
        if (currencyA.symbol > currencyB.symbol)
            return 1;
        if (assetA.symbol < assetB.symbol)
            return -1;
        if (assetA.symbol > assetB.symbol)
            return 1;
        return 0;
    };
    ArdorTraderMarketsComponent.prototype.onFilterChange = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.markets = [].concat(_this.markets);
        });
    };
    ArdorTraderMarketsComponent.prototype.filterFuncImpl = function (market) {
        if (this.filter) {
            var mask = this.filter.toUpperCase();
            if (!(market.currencyInfo.symbol.toUpperCase().indexOf(mask) >= 0 ||
                market.assetInfo.symbol.toUpperCase().indexOf(mask) >= 0 ||
                market.currencyInfo.name.toUpperCase().indexOf(mask) >= 0 ||
                (market.currencyInfo.description !== null && market.currencyInfo.description.toUpperCase().indexOf(mask) >= 0))) {
                return false;
            }
        }
        return true;
    };
    ArdorTraderMarketsComponent = __decorate([
        Component({
            selector: 'ardorTraderMarkets',
            template: "\n    <div class=\"trader-component-title\" layout=\"row\">Markets&nbsp;\n      <span flex></span>\n      <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n    </div>\n    <input type=\"text\" placeholder=\"Search markets\" ng-model=\"vm.filter\" ng-change=\"vm.onFilterChange()\"></input>\n    <md-list flex layout-fill layout=\"column\">\n      <md-list-item>\n        <div class=\"truncate-col market-col\">Market</div>\n        <div class=\"truncate-col change-col\">Change</div>\n        <div class=\"truncate-col price-col\">Price</div>\n        <div class=\"truncate-col vol-col\" flex>Vol</div>\n      </md-list-item>\n      <md-virtual-repeat-container flex layout-fill layout=\"column\"\n          virtual-repeat-flex-helper ng-if=\"vm.markets.length>0\">\n        <md-list-item md-virtual-repeat=\"item in vm.markets | filter: vm.filterFunc\">\n          <div class=\"truncate-col market-col\">\n            <a href=\"#/ardor-trader/{{item.asset}}/ardor\">\n              <span ng-class=\"{certified:item.currencyInfo.certified}\">{{item.currencyInfo.symbol}}</span>/<span ng-class=\"{certified:item.assetInfo.certified}\">{{item.assetInfo.symbol}}</span>\n            </a>\n          </div>\n          <div class=\"truncate-col change-col\">{{item.change}}</div>\n          <div class=\"truncate-col price-col\">{{item.price}}</div>\n          <div class=\"truncate-col vol-col right-align\" flex>{{ item.vol }}</div>\n        </md-list-item>\n      </md-virtual-repeat-container>\n    </md-list>\n  "
        }),
        Inject('$scope', 'heat', 'ardorAssetInfo', 'storage', '$q', '$mdToast', '$interval', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, HeatService,
            ArdorAssetInfoService,
            StorageService, Function, Object, Function, ArdorBlockExplorerService])
    ], ArdorTraderMarketsComponent);
    return ArdorTraderMarketsComponent;
}());
var ArdorTraderOrdersBuyComponent = (function (_super) {
    __extends(ArdorTraderOrdersBuyComponent, _super);
    function ArdorTraderOrdersBuyComponent($scope, $rootScope, ordersProviderFactory, $q, user, ardorBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$rootScope = $rootScope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.user = user;
        _this.ardorBlockExplorerService = ardorBlockExplorerService;
        _this.currencyBalance = "*";
        _this.PAGE_SIZE = 100;
        _this.orders = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                var sum_1 = 0;
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, null, false), function (order, context) {
                    order.price = order.priceNQTPerShare;
                    order.quantity = order.quantityQNT;
                    order.unconfirmedQuantity = order.quantity;
                    order.priceDisplay = utils.formatQNT(order.price, _this.assetInfo.decimals);
                    order.quantityDisplay = utils.formatQNT(order.unconfirmedQuantity, _this.currencyInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.unconfirmedQuantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    sum_1 += parseFloat(totalQNT);
                    order.sum = utils.formatQNT(sum_1.toString(), _this.currencyInfo.decimals);
                    _this.orders.push(order);
                });
                unregister.forEach(function (fn) { return fn(); });
                if (_this.user.unlocked) {
                    _this.updateCurrencyBalance();
                }
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 2000, false);
        _this.refreshBalance = utils.debounce(angular.bind(_this, _this.updateCurrencyBalance), 2000, false);
        $scope.$on('balance', function (event, opts) {
            var price = parseInt(_this.orders[0].price);
            var totalQuantity = 0;
            var balance = parseFloat(opts.balance);
            for (var i = 0; i < _this.orders.length; i++) {
                totalQuantity += parseInt(_this.orders[i].quantity);
                if (totalQuantity >= balance) {
                    price = parseInt(_this.orders[i].price);
                    break;
                }
            }
            price = price / 100000000;
            var total = balance * (price);
            _this.$rootScope.$broadcast('price', { price: price, balance: balance, total: total });
        });
        return _this;
    }
    ArdorTraderOrdersBuyComponent.prototype.broadcast = function () {
        this.$rootScope.$broadcast('total', { total: this.currencyBalance });
    };
    ArdorTraderOrdersBuyComponent.prototype.onSelect = function (selectedOrder) {
        this.selectedOrder = selectedOrder;
    };
    ArdorTraderOrdersBuyComponent.prototype.updateCurrencyBalance = function () {
        var _this = this;
        this.ardorBlockExplorerService.getAccountAssets(this.user.account).then(function (assetBalances) {
            assetBalances.forEach(function (assetBalance) {
                if (assetBalance.asset === _this.currencyInfo.id)
                    _this.currencyBalance = utils.formatQNT(assetBalance.quantityQNT, _this.currencyInfo.decimals);
            });
        }), function () {
            _this.currencyBalance = "0";
        };
    };
    ArdorTraderOrdersBuyComponent = __decorate([
        Component({
            selector: 'ardorTraderOrdersBuy',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder'],
            template: "\n    <script type=\"text/ng-template\" id=\"popover.html\">\n      <div class=\"account-popover\">\n        {{item.account||item.accountName}}\n      </div>\n    </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.assetInfo.symbol}} Buyers&nbsp;\n        <span flex></span>\n        <span class=\"balance clickable-text\" ng-click=\"vm.broadcast()\" ng-if=\"vm.user.unlocked\">BALANCE: {{vm.currencyBalance}}&nbsp;{{vm.currencyInfo.symbol}}</span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col total-col\">Total</div>\n          <div class=\"truncate-col sum-col\">Sum ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper  class=\"content\">\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand\n               ng-click=\"vm.select(item)\" aria-label=\"Entry\"\n               ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n            <div class=\"truncate-col info-col\">\n              <div\n                class=\"info\"\n                angular-popover\n                direction=\"right\"\n                template-url=\"popover.html\"\n                mode=\"mouseover\"\n                style=\"position: absolute;\",\n              >\n              </div>\n              <img src=\"assets/info.png\">\n            </div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col sum-col\">{{item.sum}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$rootScope', 'ardorOrdersProviderFactory', '$q', 'user', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Object, ArdorOrdersProviderFactory, Function, UserService,
            ArdorBlockExplorerService])
    ], ArdorTraderOrdersBuyComponent);
    return ArdorTraderOrdersBuyComponent;
}(VirtualRepeatComponent));
var ArdorTraderOrdersMyComponent = (function (_super) {
    __extends(ArdorTraderOrdersMyComponent, _super);
    function ArdorTraderOrdersMyComponent($scope, ordersProviderFactory, $q, user, settings, cancelBidOrder, cancelAskOrder) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.user = user;
        _this.cancelBidOrder = cancelBidOrder;
        _this.cancelAskOrder = cancelAskOrder;
        var format = settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, user.account), function (order) {
                    order.price = order.priceNQTPerShare;
                    order.quantity = order.quantityQNT;
                    order.typeDisplay = order.type == 'ask' ? 'Sell' : 'Buy';
                    order.market = _this.currencyInfo.symbol + '/' + _this.assetInfo.symbol;
                    order.quantityDisplay = utils.formatQNT(order.quantity, _this.assetInfo.decimals);
                    order.priceDisplay = utils.formatQNT(order.price, _this.currencyInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.quantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    var date = utils.timestampToDate(order.expiration);
                    order.expires = dateFormat(date, format);
                });
                unregister.forEach(function (fn) { return fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 1000, false);
        return _this;
    }
    ArdorTraderOrdersMyComponent.prototype.onSelect = function (item) { };
    ArdorTraderOrdersMyComponent.prototype.cancelOrder = function (order) {
        var dialog = order.type == 'ask' ?
            this.cancelAskOrder.dialog(order.order) :
            this.cancelBidOrder.dialog(order.order);
        if (this.oneClickOrders)
            dialog.send();
        else
            dialog.show();
    };
    ArdorTraderOrdersMyComponent = __decorate([
        Component({
            selector: 'ardorTraderOrdersMy',
            inputs: ['currencyInfo', 'assetInfo', 'oneClickOrders'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.user.unlocked?'My':'All'}} pending orders&nbsp;\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col type-col\">Type</div>\n          <div class=\"truncate-col market-col\">Market</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col total-col\">Total ({{vm.currencyInfo.symbol}})</div>\n          <div class=\"truncate-col expires-col\" flex>Expires</div>\n          <div class=\"truncate-col cancel-col\" layout=\"row\" layout-align=\"end\" ng-if=\"vm.user.unlocked\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\"\n              ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n            <div class=\"truncate-col type-col\">{{item.typeDisplay}}</div>\n            <div class=\"truncate-col market-col\">{{item.market}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col expires-col\" flex tooltip=\"{{item.expires}}\">{{item.expires}}</div>\n            <div class=\"truncate-col cancel-col\" layout=\"row\" layout-align=\"end\" ng-if=\"vm.user.unlocked\">\n              <a ng-if=\"!item.cancelled && !item.unconfirmed\" ng-click=\"vm.cancelOrder(item)\">Cancel</a>\n            </div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', 'ardorOrdersProviderFactory', '$q', 'user', 'settings', 'cancelBidOrder', 'cancelAskOrder'),
        __metadata("design:paramtypes", [Object, ArdorOrdersProviderFactory, Function, UserService,
            SettingsService,
            CancelBidOrderService,
            CancelAskOrderService])
    ], ArdorTraderOrdersMyComponent);
    return ArdorTraderOrdersMyComponent;
}(VirtualRepeatComponent));
var ArdorTraderOrdersSellComponent = (function (_super) {
    __extends(ArdorTraderOrdersSellComponent, _super);
    function ArdorTraderOrdersSellComponent($scope, $rootScope, ordersProviderFactory, $q, user, ardorBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$rootScope = $rootScope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.user = user;
        _this.ardorBlockExplorerService = ardorBlockExplorerService;
        _this.assetBalance = "*";
        _this.PAGE_SIZE = 100;
        _this.orders = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                var sum_2 = 0;
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, null, true), function (order, context) {
                    order.price = order.priceNQTPerShare;
                    order.quantity = order.quantityQNT;
                    order.unconfirmedQuantity = order.quantity;
                    order.priceDisplay = utils.formatQNT(order.price, _this.assetInfo.decimals);
                    order.quantityDisplay = utils.formatQNT(order.unconfirmedQuantity, _this.currencyInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.unconfirmedQuantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    sum_2 += parseFloat(totalQNT);
                    order.sum = utils.formatQNT(sum_2.toString(), _this.currencyInfo.decimals);
                    _this.orders.push(order);
                });
                unregister.forEach(function (fn) { return fn(); });
                if (_this.user.unlocked) {
                    _this.updateAssetBalance();
                }
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 2000, false);
        _this.refreshBalance = utils.debounce(angular.bind(_this, _this.updateAssetBalance), 2000, false);
        $scope.$on('total', function (event, opts) {
            var price = parseInt(_this.orders[0].price);
            var totalQuantity = 0;
            var total = parseFloat(opts.total);
            for (var i = 0; i < _this.orders.length; i++) {
                totalQuantity += (parseFloat(_this.orders[i].quantity) / 100000000);
                if (totalQuantity >= total) {
                    price = parseInt(_this.orders[i].price);
                    break;
                }
            }
            price = price / 100000000;
            var balance = total / price;
            _this.$rootScope.$broadcast('price', { price: price, balance: balance, total: total });
        });
        return _this;
    }
    ArdorTraderOrdersSellComponent.prototype.broadcast = function () {
        this.$rootScope.$broadcast('balance', { balance: this.assetBalance });
    };
    ArdorTraderOrdersSellComponent.prototype.onSelect = function (selectedOrder) {
        this.selectedOrder = selectedOrder;
    };
    ArdorTraderOrdersSellComponent.prototype.updateAssetBalance = function () {
        var _this = this;
        this.ardorBlockExplorerService.getBalance(this.user.account, 2).then(function (balance) {
            _this.assetBalance = utils.formatQNT(balance, _this.assetInfo.decimals);
        }), function () {
            _this.assetBalance = "0";
        };
    };
    ArdorTraderOrdersSellComponent = __decorate([
        Component({
            selector: 'ardorTraderOrdersSell',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder'],
            template: "\n    <script type=\"text/ng-template\" id=\"templateId.tml\">\n      <div class=\"account-popover\">\n        {{item.account||item.accountName}}\n      </div>\n    </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.assetInfo.symbol}} Sellers&nbsp;\n        <span flex></span>\n        <span class=\"balance clickable-text\" ng-click=\"vm.broadcast()\" ng-if=\"vm.user.unlocked\">BALANCE: {{vm.assetBalance}}&nbsp;{{vm.assetInfo.symbol}}</span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item  class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col total-col\">Total</div>\n          <div class=\"truncate-col sum-col\">Sum ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper class=\"content\">\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand\n               ng-click=\"vm.select(item)\" aria-label=\"Entry\"\n               ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n           <div class=\"truncate-col info-col\">\n             <div\n              class=\"info\"\n              angular-popover\n              direction=\"right\"\n              template-url=\"templateId.tml\"\n              mode=\"mouseover\"\n              style=\"position: absolute;\">\n             </div>\n             <img src=\"assets/info.png\">\n           </div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col sum-col\">{{item.sum}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$rootScope', 'ardorOrdersProviderFactory', '$q', 'user', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Object, ArdorOrdersProviderFactory, Function, UserService,
            ArdorBlockExplorerService])
    ], ArdorTraderOrdersSellComponent);
    return ArdorTraderOrdersSellComponent;
}(VirtualRepeatComponent));
var ArdorTraderTradeHistoryComponent = (function (_super) {
    __extends(ArdorTraderTradeHistoryComponent, _super);
    function ArdorTraderTradeHistoryComponent($scope, $window, tradesProviderFactory, $q, user, settings) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$window = $window;
        _this.tradesProviderFactory = tradesProviderFactory;
        _this.user = user;
        _this.settings = settings;
        _this.showTheseTrades = "all";
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.createProvider();
                unregister.forEach(function (fn) { return fn(); });
                angular.element($window).bind('resize', function () { return _this.onResize(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        return _this;
    }
    ArdorTraderTradeHistoryComponent.prototype.createProvider = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        if (this.$window.innerWidth < 870) {
            format = this.settings.get(SettingsService.TIMEFORMAT_DEFAULT);
        }
        var account = this.showTheseTrades == 'all' ? null : this.user.account;
        this.initializeVirtualRepeat(this.tradesProviderFactory.createProvider(this.currencyInfo.id, this.assetInfo.id, account), function (trade) {
            var date = utils.ardorTimestampToDate(trade.timestamp);
            trade.time = dateFormat(date, format);
            if (account) {
                trade.type = trade.seller == account ? 'Sell' : 'Buy';
            }
            else {
                trade.type = trade.isBuy ? 'Buy' : 'Sell';
            }
            trade.price = trade.priceNQTPerShare;
            trade.quantity = trade.quantityQNT;
            trade.priceDisplay = utils.formatQNT(trade.price, _this.assetInfo.decimals);
            trade.quantityDisplay = utils.formatQNT(trade.quantity, _this.currencyInfo.decimals);
            var totalQNT = utils.calculateTotalOrderPriceQNT(trade.quantity, trade.price);
            trade.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
            trade.virtual = trade.block == "0";
        });
    };
    ArdorTraderTradeHistoryComponent.prototype.onSelect = function (item) { };
    ArdorTraderTradeHistoryComponent.prototype.updateView = function () {
        if (this.currencyInfo && this.assetInfo) {
            this.createProvider();
        }
    };
    ArdorTraderTradeHistoryComponent.prototype.onResize = function () {
        this.updateView();
    };
    ArdorTraderTradeHistoryComponent = __decorate([
        Component({
            selector: 'ardorTraderTradeHistory',
            inputs: ['currencyInfo', 'assetInfo', 'oneClickOrders'],
            template: "\n  <script type=\"text/ng-template\" id=\"popoverHistory.html\">\n    <div class=\"account-popover\">\n      <div>Buyer: {{item.buyerName||item.buyer}}</div>\n      <div>Seller: {{item.sellerName||item.seller}}</div>\n    </div>\n  </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">Past trades&nbsp;\n        <span flex></span>\n        <span layout=\"row\" ng-if=\"vm.user.unlocked\" class=\"selector\">\n          <label>\n            <input type=\"radio\" name=\"trader-show-trades\" value=\"all\" ng-model=\"vm.showTheseTrades\" ng-change=\"vm.updateView()\">\n            <i>Show all trades</i>\n          </label>\n          <label>\n            <input type=\"radio\" name=\"trader-show-trades\" value=\"my\" ng-model=\"vm.showTheseTrades\" ng-change=\"vm.updateView()\">\n            <i>Show my trades</i>\n          </label>\n        </span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col type-col\">Type</div>\n          <div class=\"truncate-col time-col\" flex>Time</div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">{{vm.assetInfo.symbol}}</div>\n          <div class=\"truncate-col total-col\" flex>Total ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" ng-class=\"{'virtual': item.virtual}\">\n            <div class=\"truncate-col info-col\">\n              <div\n                class=\"info\"\n                angular-popover\n                direction=\"right\"\n                template-url=\"popoverHistory.html\"\n                mode=\"mouseover\"\n                style=\"position: absolute;\">\n              </div>\n              <img src=\"assets/info.png\">\n            </div>\n            <div class=\"truncate-col type-col\">{{item.type}}</div>\n            <div class=\"truncate-col time-col\" flex>{{item.time}}</div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\" flex>{{item.total}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$window', 'ardorTradesProviderFactory', '$q', 'user', 'settings'),
        __metadata("design:paramtypes", [Object, Object, ArdorTradesProviderFactory, Function, UserService,
            SettingsService])
    ], ArdorTraderTradeHistoryComponent);
    return ArdorTraderTradeHistoryComponent;
}(VirtualRepeatComponent));
var ArdorTraderComponent = (function () {
    function ArdorTraderComponent($scope, user, $timeout, assetInfoService, $mdSidenav) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.$timeout = $timeout;
        this.assetInfoService = assetInfoService;
        this.$mdSidenav = $mdSidenav;
        this.marketCurrency = "0";
        this.marketSort = "change";
        this.marketAsc = "false";
        this.marketsSidenavOpen = true;
        this.marketsSidenavLockedOpen = true;
        this.toggleMarkets = function () {
            var sidenav = _this.$mdSidenav("trader-markets-sidenav");
            if (sidenav.isOpen()) {
                _this.marketsSidenavLockedOpen = false;
                sidenav.close();
            }
            else {
                _this.marketsSidenavLockedOpen = true;
                sidenav.open();
            }
        };
    }
    ArdorTraderComponent.prototype.$onInit = function () {
        var _this = this;
        this.assetInfoService.getInfo(this.currency).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.currencyInfo = info;
            });
        });
        this.assetInfoService.getInfo(this.asset).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.assetInfo = info;
            });
        });
        this.user.account = this.user.account || "";
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                unregister.forEach(function (fn) {
                    fn();
                });
            }
        };
        var unregister = [this.$scope.$watch('vm.currencyInfo', ready), this.$scope.$watch('vm.assetInfo', ready)];
    };
    ArdorTraderComponent = __decorate([
        RouteConfig('/ardor-trader/:currency/:asset'),
        Component({
            selector: 'ardorTrader',
            inputs: ['currency', 'asset'],
            template: "\n    <div layout=\"row\">\n      <!--\n      <div>\n        <md-button class=\"md-icon-button show-hide\" aria-label=\"Show/hide markets\" ng-click=\"vm.toggleMarkets()\">\n          <md-tooltip md-direction=\"bottom\">Show/Hide markets</md-tooltip>\n          <i><img src=\"assets/{{vm.marketsSidenavOpen?'minusIcon':'plusIcon'}}.png\"></i>\n        </md-button>\n      </div>\n      -->\n      <span flex></span>\n      <trader-volume class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\" layout=\"column\"></trader-volume>\n    </div>\n    <div layout=\"row\" flex layout-fill>\n      <md-sidenav class=\"md-sidenav-left\" md-component-id=\"trader-markets-sidenav\"\n          md-is-locked-open=\"vm.marketsSidenavLockedOpen\" md-is-open=\"vm.marketsSidenavOpen\"\n          md-disable-backdrop flex layout-fill>\n        <div class=\"sidenav-container\">\n          <ardor-trader-balances currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\" ng-if=\"vm.user.unlocked\"></ardor-trader-balances>\n          <ardor-trader-markets></ardor-trader-markets>\n        </div>\n      </md-sidenav>\n      <div layout=\"column\" flex layout-fill class=\"main-display\">\n        <div>\n          <div class=\"trader-row top\">\n              <ardor-trader-info class=\"trader-component\" toggle-markets=\"vm.toggleMarkets\" markets-sidenav-open=\"vm.marketsSidenavOpen\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-info>\n              <trader-chart class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-chart>\n          </div>\n          <div class=\"trader-row middle\">\n            <ardor-trader-orders-buy class=\"trader-component\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-orders-buy>\n            <ardor-trader-quick-buy-sell class=\"trader-component\" one-click-orders=\"vm.oneClickOrders\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-quick-buy-sell>\n            <ardor-trader-orders-sell class=\"trader-component\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"l></ardor-trader-orders-sell>\n          </div>\n          <div class=\"trader-row bottom\">\n            <ardor-trader-trade-history class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-trade-history>\n            <ardor-trader-orders-my ng-if=\"vm.user.unlocked\" class=\"trader-component\" one-click-orders=\"vm.oneClickOrders\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-orders-my>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'user', '$timeout', 'ardorAssetInfo', '$mdSidenav'),
        __metadata("design:paramtypes", [Object, UserService, Function, ArdorAssetInfoService, Function])
    ], ArdorTraderComponent);
    return ArdorTraderComponent;
}());
var ArdorOrdersProviderFactory = (function () {
    function ArdorOrdersProviderFactory(ardorBlockExplorerService, $q) {
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.$q = $q;
    }
    ArdorOrdersProviderFactory.prototype.createProvider = function (currency, asset, account, isAsk) {
        return new ArdorOrdersProvider(currency, asset, account, isAsk, this.ardorBlockExplorerService, this.$q);
    };
    ArdorOrdersProviderFactory = __decorate([
        Service('ardorOrdersProviderFactory'),
        Inject('ardorBlockExplorerService', '$q'),
        __metadata("design:paramtypes", [ArdorBlockExplorerService, Function])
    ], ArdorOrdersProviderFactory);
    return ArdorOrdersProviderFactory;
}());
var ArdorOrdersProvider = (function () {
    function ArdorOrdersProvider(currency, asset, account, isAsk, ardorBlockExplorerService, $q) {
        this.currency = currency;
        this.asset = asset;
        this.account = account;
        this.isAsk = isAsk;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.$q = $q;
    }
    ArdorOrdersProvider.prototype.getPaginatedLength = function () {
        if (this.account) {
            return this.ardorBlockExplorerService.getMyPendingOrdersCount(this.account, this.currency);
        }
        else if (this.isAsk) {
            return this.ardorBlockExplorerService.getAskOrdersCount(this.currency);
        }
        return this.ardorBlockExplorerService.getBidOrdersCount(this.currency);
    };
    ArdorOrdersProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (this.account) {
            return this.ardorBlockExplorerService.getMyPendingOrders(this.account, this.currency, firstIndex, lastIndex);
        }
        else if (this.isAsk) {
            return this.ardorBlockExplorerService.getAskOrders(this.currency, firstIndex, lastIndex);
        }
        return this.ardorBlockExplorerService.getBidOrders(this.currency, firstIndex, lastIndex);
    };
    return ArdorOrdersProvider;
}());
var ArdorTradesProviderFactory = (function () {
    function ArdorTradesProviderFactory(ardorBlockExplorerService, $q) {
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.$q = $q;
    }
    ArdorTradesProviderFactory.prototype.createProvider = function (currency, asset, account) {
        return new ArdorTradesProvider(currency, asset, account, this.ardorBlockExplorerService, this.$q);
    };
    ArdorTradesProviderFactory = __decorate([
        Service('ardorTradesProviderFactory'),
        Inject('ardorBlockExplorerService', '$q'),
        __metadata("design:paramtypes", [ArdorBlockExplorerService, Function])
    ], ArdorTradesProviderFactory);
    return ArdorTradesProviderFactory;
}());
var ArdorTradesProvider = (function () {
    function ArdorTradesProvider(currency, asset, account, ardorBlockExplorerService, $q) {
        this.currency = currency;
        this.asset = asset;
        this.account = account;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.$q = $q;
    }
    ArdorTradesProvider.prototype.getPaginatedLength = function () {
        if (this.account)
            return this.ardorBlockExplorerService.getTradesCount(this.currency, this.account);
        return this.ardorBlockExplorerService.getTradesCount(this.currency);
    };
    ArdorTradesProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (this.account)
            return this.ardorBlockExplorerService.getTrades(this.currency, firstIndex, lastIndex, this.account);
        return this.ardorBlockExplorerService.getTrades(this.currency, firstIndex, lastIndex);
    };
    return ArdorTradesProvider;
}());

//# sourceMappingURL=../dist/maps/heat-ui-MJ8X45.js.map
